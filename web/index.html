<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">

<head>
<title>Tetris is Capable of Universal Computation</title>
<link rel="stylesheet" href="style.css?v=2022-12-03" type="text/css"/>
<link rel="icon" href="favicon.svg" type="image/svg+xml"/>
<link rel="icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="shortcut icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="mask-icon" href="mask-icon.svg" color="#000000"/>
<link rel="apple-touch-icon" href="apple-touch-icon.png"/>
<link rel="manifest" href="manifest.json"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Bentham&family=Open+Sans&family=Source+Code+Pro&family=Source+Serif+Pro&family=Roboto+Mono&display=swap" rel="stylesheet"/>
<meta name="theme-color" content="#FFFFFF"/>
<meta name="date" content="2022-12-03"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

<body>

<p class="title">Tetris is Capable of <span class="nowrap">Universal Computation</span></p>

<p>This text presents a method for embedding a programmable, general-purpose, digital computer into Tetris. It describes the capabilities and performance of an implementation that runs Tetris on Tetris.</p>

<h1 id="introduction">Introduction</h1>

<p>The section provides a foundation for understanding the way to compute within Tetris.</p>

<h2 id="fundamentals">Fundamentals</h1>

<p>The <span class="term">playfield</span> is the grid of square cells where Tetris is played. The standard playfield, shown below, consists of twenty visible rows and ten columns, but the dimensions are arbitrary.</p>

<object id="standard-playfield.svg" data="standard-playfield.svg" type="image/svg+xml" class="diagram">Standard Playfield</object>

<p>Each playfield cell is in one of two states: empty or solid.</p>

<p><span class="term">Tetrominoes</span>&mdash;the falling pieces&mdash;are composed of four adjacent solid cells, painted any color. Each has a single-character, shape-based name:</p>

<object id="seven-tetrominoes.svg" data="seven-tetrominoes.svg" type="image/svg+xml" class="diagram">Seven tetrominoes</object>

<p>A <span class="term">move</span> is a rotation or a translation of the piece in play. The following terms apply to translation.</p>

<ul>
    <li>A <span class="term">shift</span> is a horizontal translation.</li>
    <li>A <span class="term">drop</span> is a downward translation.
        <ul>
            <li>A <span class="term">soft drop</span> is a player-controlled, one-row drop.</li>
            <li>A <span class="term">hard drop</span> is a player-controlled, drop as far down as the piece can go. The move <span class="term">locks</span> the piece where it lands.</li>
            <li>A <span class="term">gravity drop</span> is an automatic, one-row drop triggered by the <span class="term">fall timer</span>.</li>
        </ul>
    </li>
</ul>

<p>A move is preceded by a <span class="term">request to move</span>. The game will deny a request to translate a piece out of bounds or into solid cells. If the game denies the fall timerâ€™s request for a gravity drop, then the piece locks and the next piece spawns.</p>

<p>The <span class="term"><a href="https://tetris.wiki/Category:Rotation_systems" target="_blank">rotation system</a></span> determines if and how the game responds to a request to rotate. Modern versions of Tetris employ complicated rotation systems that take into account the states of the surrounding cells, the playfield boundaries, and other factors.</p>

<p>The <span class="term">randomizer</span> is the mechanism that determines the sequence of pieces presented to the player.</p>

<h2 id="method-overview">Method Overview</h2>

<p>A process encodes input data into the cells of the <span class="nowrap">bottom-two</span> rows of a playfield that is infinite in width and height, but bounded by the floor. An <span class="term">agent</span> drops tetrominoes onto those cells, forming a structure that emulates <a href="https://en.wikipedia.org/wiki/Combinational_logic" target="_blank">combinational logic</a>. A process decodes output data from the <span class="nowrap">top-two</span> rows of that structure:</p>

<object id="boolean-circuit.svg" data="boolean-circuit.svg" type="image/svg+xml" class="diagram">Boolean Circuit</object>

<p>The agent builds a second structure above the first, such that the output rows of the first structure serve as the input rows of the second structure. By repeating this procedure, the agent effectuates a state machine, where the data rows are states and the structures are transition functions:</p>

<object id="state-machine.svg" data="state-machine.svg" type="image/svg+xml" class="diagram">State Machine</object>

<p>There exists a modification of this technique where the data capacity of a state always exceeds its predecessor. The modification provides a way to build an abstract computing device with unbounded storage that can simulate an arbitrary Turing machine operating on given input.</p>

<h2 id="nodes">Nodes</h2>

<p>A pair of vertically-adjacent playfield cells stores a Boolean value via the following scheme.</p>

<object id="boolean-circuit-nodes.svg" data="boolean-circuit-nodes.svg" type="image/svg+xml" class="diagram">Boolean Circuit Nodes</object>

<ul>
    <li><span class="mono">0</span> (false) &mdash; lower-cell solid, upper-cell empty</li> 
    <li><span class="mono">1</span> (true) &mdash; upper-cell solid, lower-cell empty or solid</li>  
    <li><span class="mono">?</span> (unassigned) &mdash; both cells empty</li>  
</ul>

<p>The input, intermediate, and output nodes of combinational logic structures are composed of one or more pairs, all in the same state. Typically, a node is a contiguous, horizontal line of pairs, but not necessarily. The pairs of a node can be separated in space, even vertically separated. For instance, the image below shows one possible encoding of <span class="mono">01010</span>, where a noncontiguous node stores the rightmost bit.</p>

<object id="encoding-01010.svg" data="encoding-01010.svg" type="image/svg+xml" class="diagram">01010</object>

<h2 id="infinite-playfield">Infinite Playfield</h2>

<p>On an infinite playfield, tetrominoes spawn at <span class="nowrap">&ldquo;row infinity&rdquo;</span> and <span class="nowrap">column zero</span>. When a newly spawned piece falls, it never gets closer to the floor due to the nature of infinity. This means, in finite&mdash;though potentially vast&mdash;time, the agent can shift the piece into any finite column. And once in position, the agent can hard drop the piece.</p>  

<p>A hard drop attempts to vertically translate the piece from <span class="nowrap">&ldquo;row infinity&rdquo;</span> to <span class="nowrap">row zero</span>, crossing all the space in between in the same time it takes to perform a soft drop. Along the way, the piece can encounter a barrier of solid cells that stops it. And, once stopped, the piece locks into place.</p> 

<p>A more generalized version, the <span class="term">semihard drop</span>, attempts to vertically translate the piece from <span class="nowrap">&ldquo;row infinity&rdquo;</span> to a specified, finite row. If it encounters a barrier along the way, it locks into place. Otherwise, the agent is free to shift, rotate, and drop the piece from there. A semihard dropped piece does get closer to the floor as it falls because the move puts it on a finite row.</p>

<p>The agent is limited to actions that take finite time. For instance, it cannot clear a line because it cannot carry out the infinite moves required to arrange infinite pieces into a line. Consequentially, the game never advances to the second level. It permanently runs at the lowest drop speed.</p>

<h2 id="input-language">Input Language</h2>

<p>The agent is a device that enters precisely timed input sequences per the instructions of an <span class="nowrap"><span class="term">Input Language</span> (IL)</span> program. Each instruction contains a tetromino type, <span class="nowrap"><span class="mono">t</span><span class="roboto">&isin;{T,J,Z,O,S,L,I}</span></span>, followed by a sequence of moves, <span class="mono">m</span>:</p>

<p class="definition">t m<span class="sub3">0</span> m<span class="sub3">1</span> m<span class="sub3">2</span> &mldr; m<span class="sub3">N&minus;1</span></p> 

<p>Each element of the sequence, <span class="mono">m<span class="sub3">i</span></span>, is one of the following.</p>

<ul>
    <li><span class="mono nowrap">ROTATE_NINETY_DEGREES_COUNTERCLOCKWISE</span></li>
    <li><span class="mono nowrap">ROTATE_NINETY_DEGREES_CLOCKWISE</span></li>
    <li><span class="mono nowrap">SHIFT_LEFT_ONE_COLUMN</span></li>
    <li><span class="mono nowrap">SHIFT_RIGHT_ONE_COLUMN</span></li>
    <li><span class="mono nowrap">SOFT_DROP_ONE_ROW</span></li>
    <li><span class="mono nowrap">SEMIHARD_DROP_TO_ROW y</span></li>
    <li><span class="mono nowrap">HARD_DROP</span></li>  
</ul>

<p>Note: <span class="mono">SEMIHARD_DROP_TO_ROW</span> requires a parameter, the target row, <span class="mono">y</span>.</p>

<p>When a tetromino spawns, the agent compares the tetromino type with <span class="mono">t</span>. If they match, the agent enters sequence <span class="mono">m</span>, and it advances to the next instruction. Otherwise, the agent hard drops the tetromino onto an unbounded pile of discards in <span class="nowrap">column &minus;2</span>, and it stays on the current instruction:</p> 

<object id="discards-pile.svg" data="discards-pile.svg" type="image/svg+xml" class="diagram">Discards Pile</object>

<p>IL programs direct the agent to assemble structures only in <span class="nowrap">columns &ge; 0</span>.</p> 

<p>The way the agent enters moves depends on the mechanics of the Tetris implementation. For instance, to shift left by two columns, the agent may need to press the left button, release the left button, and press the left button again with a particular timing.</p>

<p>In practice, <span class="nowrap">IL programs</span> direct the agent to construct a pile near the origin that progressively grows taller and wider. That being the case, it can work with a Tetris implementation that defines <span class="nowrap">&ldquo;row infinity&rdquo;</span> as a finite row whose index increases as a function of the number of spawns. In such an implementation, the agent emulates a <span class="nowrap">semihard drop</span> with a finite number of <span class="nowrap">soft drops</span>.</p>

<p>Since the game denies requests to move a piece into solid cells, the content of the playfield determines where a piece ultimately ends up. For example, in the animation below, the agent attempts to shift the <span class="nowrap">O-tetromino</span> into <span class="nowrap">column 1</span>. The attempt works on the empty playfield on the left, but it fails on the nonempty playfield on the right.</p>

<object id="shift-interruption.svg" data="shift-interruption.svg" type="image/svg+xml" class="diagram">Shift Interruption</object>

<p>In the following example, the agent attempts to drop the <span class="nowrap">O-tetromino</span> onto the floor. Again, the attempt works on the empty playfield on the left, but it fails on the nonempty playfield on the right.</p>

<object id="drop-interruption.svg" data="drop-interruption.svg" type="image/svg+xml" class="diagram">Drop Interruption</object>

<p>An <span class="nowrap">IL program</span> program resembles a <span class="nowrap"><a href="https://en.wikipedia.org/wiki/Tool-assisted_speedrun" target="_blank">tool-assisted speedrun</a> (TAS)</span> recording. Both rely on deterministic responses to precisely timed inputs. But IL supports nondeterministic randomizers because it instructs the agent to wait for spawns and to discard unwanted pieces. And the agent acts as an interpreter between a move sequence and the input requirements ofÂ a specific Tetris implementation. Nonetheless, if an implementation employs a seedable <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_blank">pseudorandom number generator</a>, then a <span class="nowrap">TAS recording</span> along with the seed will work just as well.</p>

<h2 id="tetrominoscript">TetrominoScript</h2>

<p><span class="nowrap"><span class="term">TetrominoScript</span> (TS)</span> is a language that provides a concise way to express where to put the pieces. It compiles to IL.</p>

<p>TS refers to each of the nineteen distinct tetromino orientations with a mnemonic consisting of the tetromino type concatenated with the first letter of &ldquo;down&rdquo;, &ldquo;left&rdquo;, &ldquo;up&rdquo;, &ldquo;right&rdquo;, &ldquo;horizontal&rdquo;, &ldquo;vertical&rdquo;, or nothing for the <span class="nowrap">O-tetromino</span>:</p>

<object id="mnemonic-table.svg" data="mnemonic-table.svg" type="image/svg+xml" class="diagram">Mnemonic Table</object>

<p>TS specifies locations relative to the center block of each tetromino.</p>

<p>TS has three instruction types. The first directs the agent to hard drop a tetromino. It consists of the tetromino's mnemonic, <span class="mono">m</span>, and theÂ hard drop's column index, <span class="mono">x<span class="sub3">h</span></span>:</p>

<p class="definition">m x<span class="sub3">h</span></p>

<p>It commands the agent to:</p>

<ol>
    <li>Discard tetrominoes until the randomizer spawns the one specified by <span class="mono">m</span>'s type.</li> 
    <li>Rotate the tetromino into <span class="mono">m</span>'s orientation.</li>   
    <li>Shift the tetromino to column <span class="mono">x<span class="sub3">h</span></span>.</li>   
    <li>Hard drop the tetromino.</li> 
</ol>

<p>The example below demonstrates this instructions type.</p>

<pre class="code">
<span class="filename">example1.t</span>
<span class="line"><span class="normal">td </span><span class="number">1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">5</span></span>
<span class="line"><span class="normal">zh </span><span class="number">9</span></span>
<span class="line"><span class="normal">o </span><span class="number">13</span></span>
<span class="line"><span class="normal">sh </span><span class="number">16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">20</span></span>
<span class="line"><span class="normal">ih </span><span class="number">25</span></span>
</pre>

<p>The program instructs the agent to produce the following.</p>

<object id="example1.svg" data="example1.svg" type="image/svg+xml" class="diagram">example1</object>

<p>The second instruction type directs the agent to perform a semihard drop followed by a hard drop in a different column. It consists of the tetrominoâ€™s mnemonic, <span class="mono">m</span>, the semihard dropâ€™s column index, <span class="mono">x<span class="sub3">s</span></span>, the semihard drop's row index, <span class="mono">y<span class="sub3">s</span></span>, and the hard drop's column index, <span class="mono">x<span class="sub3">h</span></span>:</p>

<p class="definition">m x<span class="sub3">s</span> y<span class="sub3">s</span> x<span class="sub3">h</span></p>

<p>It commands the agent to:</p>

<ol>
    <li>Discard tetrominoes until the randomizer spawns the one specified by <span class="mono">m</span>'s type.</li> 
    <li>Rotate the tetromino into <span class="mono">m</span>'s orientation.</li>   
    <li>Shift the tetromino to column <span class="mono">x<span class="sub3">s</span></span>.</li>
    <li>Semihard drop the tetromino to row <span class="mono">y<span class="sub3">s</span></span>.</li>
    <li>Shift the tetromino to column <span class="mono">x<span class="sub3">h</span></span>.</li>
    <li>Hard drop the tetromino.</li> 
</ol>

<p>If a gravity drop occurs after <span class="nowrap">step 4</span>, but before <span class="nowrap">step 5</span> finishes, the agent will misplace the piece. To avert that possibility, the agent times a semihard drop to coincide with a gravity drop. How it does that depends on the Tetris implementation. For instance, if the agentÂ emulates a semihard drop with a finite number of soft drops, then it will let a gravity drop serve as the final soft drop. That maximizes the time to shift from column <span class="mono">x<span class="sub3">s</span></span> to column <span class="mono">x<span class="sub3">h</span></span>. The strategy works as long as the distance between the columns does not exceed the maximum shift achievable in the period between gravity drops.</p>

<p>The following codeÂ demonstratesÂ the second instruction type.</p>

<pre class="code">
<span class="filename">example2.t</span>
<span class="line"><span class="normal">td </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">jd </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">zh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">o </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ld </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1 15 2</span></span>
</pre>

<p>Those are the instructions for the structure below.</p>

<object id="example2.svg" data="example2.svg" type="image/svg+xml" class="diagram">example2</object>

<p>The third instruction directs the agent to build a previously defined structure. It consists of the structure's name, <span class="mono">s</span>, and the coordinates of where to build it, <span class="nowrap"><span class="mono">x</span> and <span class="mono">y</span></span>:</p>

<p class="definition">s x y</p>

<p>The <span class="nowrap">TS compiler</span> replaces the instruction with the contents of <span class="mono">s</span>â€™s program, such that the column and row arguments of <span class="mono">n</span>â€™s instructions are incremented by <span class="mono">x</span> and <span class="mono">y</span>, respectively. The compiler recursively repeats that process until all what remains are instructions of the first and second types. To ensure the process finishes, the compiler does not permit <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank">circular dependencies</a>.</p>

<p>The following code demonstrates the third instruction type by referencing the prior examples.</p>

<pre class="code">
<span class="filename">example3.t</span>
<span class="line"><span class="normal">example1 </span><span class="number">3 0</span></span>
<span class="line"><span class="normal">example2 </span><span class="number">14 2</span></span>
</pre>

<p>The compiler expands those instructions, offsetting the column and row indices per the provided coordinates:</p>

<pre class="code">
<span class="filename">example3Expanded.t</span>
<span class="line"><span class="comment"># example1 3 0</span></span>
<span class="line"><span class="normal">td </span><span class="number">4</span></span>
<span class="line"><span class="normal">jd </span><span class="number">8</span></span>
<span class="line"><span class="normal">zh </span><span class="number">12</span></span>
<span class="line"><span class="normal">o </span><span class="number">16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">19</span></span>
<span class="line"><span class="normal">ld </span><span class="number">23</span></span>
<span class="line"><span class="normal">ih </span><span class="number">28</span></span>
<span class="line"></span>
<span class="line"><span class="comment"># example2 14 2</span></span>
<span class="line"><span class="normal">td </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">jd </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">zh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">o </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ih </span><span class="number">15 17 16</span></span>
</pre>

<p><a href="https://en.wikipedia.org/wiki/Comment_(computer_programming)#Line_comments" target="_blank">Line comments</a> begin with <span class="mono">#</span> and end with <a href="https://en.wikipedia.org/wiki/Newline" target="_blank">newline</a>, as demonstrated by <span class="nowrap">lines 1 and 10</span>. TS does not support <a href="https://en.wikipedia.org/wiki/Comment_(computer_programming)#Block_comment" target="_blank">block comments</a>.</p>

<p>The code above instructs the agent to create the structure below.</p>

<object id="example3.svg" data="example3.svg" type="image/svg+xml" class="diagram">example3</object>

<p>To make testing easier, TS provides <a href="https://en.wikipedia.org/wiki/Directive_(programming)" target="_blank">directives</a> for labeling nodes:</p>

<pre class="definition">
<span class="keyword2">in</span> n x<span class="sub3">0</span> y<span class="sub3">0</span> x<span class="sub3">1</span> y<span class="sub3">1</span> &mldr; x<span class="sub3">N&minus;1</span> y<span class="sub3">N&minus;1</span>

<span class="keyword2">out</span> n x<span class="sub3">0</span> y<span class="sub3">0</span> x<span class="sub3">1</span> y<span class="sub3">1</span> &mldr; x<span class="sub3">N&minus;1</span> y<span class="sub3">N&minus;1</span>
</pre>

<p>The node type, <span class="mono keyword2">in</span> or <span class="mono keyword2">out</span>, is followed by the node name, <span class="mono">n</span>. The successive coordinates, <span class="mono">x<span class="sub3">i</span> y<span class="sub3">i</span></span>, refer to the lower-cells of the node's vertically-adjacent pairs. Each coordinate is either a single integer or a range of integers, <span class="mono nowrap">min..max</span>.</p>

<p>The example below declares five input nodes.</p>

<pre class="code">
<span class="filename">nodes.t</span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">2..4 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">c </span><span class="number">6 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">d </span><span class="number">7 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">e </span><span class="number">9..10 0 12..13 0</span></span>
</pre>

<p>Node <span class="mono">a</span> is a single pair. Node <span class="mono">b</span> is a horizontal line consisting of three pairs. Nodes <span class="mono">c</span> and <span class="mono">d</span> are adjoining, single pairs. Node <span class="mono">e</span> is disjoint. They are illustrated below, where nodes <span class="mono">a</span>, <span class="mono">b</span>, <span class="mono">c</span>, <span class="mono">d</span>, and <span class="mono">e</span> are set to <span class="mono">0</span>, <span class="mono">1</span>, <span class="mono">0</span>, <span class="mono">1</span>, and <span class="mono">0</span>, respectively.</p>

<object id="nodes.svg" data="nodes.svg" type="image/svg+xml" class="diagram">Nodes</object>

<h1 id="logic-gates">Logic Gates</h1>

<p>This section explains how to construct logic gates, structures that produce a single binary output from one or more binary inputs.</p>

<h2 id="buffer">Buffer</h2>

<p>A buffer is a single-input, binary <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a>. The output value is the input value, unchanged.</p>

<p>The code below realizes a buffer by dropping a vertical <span class="nowrap">I-tetromino</span> onto an input node.</p>

<pre class="code">
<span class="filename">buffer.t</span>
<span class="line"><span class="normal">iv </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 4</span></span>
</pre>

<p>The result for both input values follows.</p>

<object id="animated-buffer.svg" data="animated-buffer.svg" type="image/svg+xml" class="diagram">Animated Buffer</object>

<p>The cells of the output node mirror the cells of the input node. Any tetromino or any stack of tetrominoes can be used to copy data in this way.</p>

<h2 id="inverter-not">Inverter (NOT)</h2>

<p>An inverter is a single-input gate where the output is the <a href="https://en.wikipedia.org/wiki/Negation" target="_blank">complement</a> of the input.</p>

<p>The code below makes an inverter by sandwiching an <span class="nowrap">O-tetromino</span> between horizontal L- and J-tetrominoes.</p>

<pre class="code">
<span class="filename">not.t</span>
<span class="line"><span class="normal">lu </span><span class="number">0</span></span>
<span class="line"><span class="normal">o </span><span class="number">0 4 1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-1..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>Note: While workspace coordinates are always &ge; 0 due to the floor and the discards pile, structure definitions may contain negative column indices because the coordinates are relative to where the structure is built.</p>

<p>The following animation shows what happens for both input values.</p>

<object id="animated-not.svg" data="animated-not.svg" type="image/svg+xml" class="diagram">Animated NOT</object>

<p>When the input is <span class="mono">0</span>, the <span class="nowrap">L-tetromino</span> lands low. That enables the <span class="nowrap">O-tetromino</span> to shift upon the <span class="nowrap">L-tetromino's</span> protuberance. The <span class="nowrap">J-tetromino</span>, in turn, lands high, producing an output of <span class="mono">1</span>.</p>

<p>When the input is <span class="mono">1</span>, the <span class="nowrap">L-tetromino</span> lands high. That causes it to act a barrier that obstructs the horizontal movement of the <span class="nowrap">O-tetromino</span>. Consequentially, the <span class="nowrap">J-tetromino</span> lands low, generating an output of <span class="mono">0</span>.</p>

<p>In both cases, the output is the opposite of the input.</p>

<p>A horizontally reflected version exists purely for aesthetics reasons. The image below shows <span class="mono">notLeft</span> (an alias for <span class="mono">not</span>) and its reflection, <span class="mono">notRight</span>.</p>

<object id="nots.svg" data="nots.svg" type="image/svg+xml" class="diagram">notLeft and notRight</object>

<h2 id="or">OR</h2>

<p>OR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_disjunction" target="_blank">disjunction</a> of its inputs. That is, the output is <span class="mono">0</span> only when both inputs are <span class="mono">0</span>.</p>

<p>The code below creates an OR gate by dropping a single <span class="nowrap">O-tetromino</span> onto abutting input nodes.</p>

<pre class="code">
<span class="filename">or.t</span>
<span class="line"><span class="normal">o </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 2</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object id="or.svg" data="or.svg" type="image/svg+xml" class="diagram">OR</object>

<p>The <span class="nowrap">O-tetromino</span> lands low unless one or both inputs is <span class="mono">1</span>.</p>

<h2 id="nor">NOR</h2>

<p>NOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_NOR" target="_blank">joint denial</a> of its inputs. That is, the output is <span class="mono">1</span>Â only when both inputs are <span class="mono">0</span>.</p>

<p>It is a <a href="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" target="_blank">universal gate</a>. NOR gates alone can be combined to form any other gate.</p>

<p>The code below realizes a NOR gate by feeding two inputs into an inverter.</p>

<pre class="code">
<span class="filename">nor.t</span>
<span class="line"><span class="normal">not </span><span class="number">0 0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>The following image presents the outputs for all possible inputs.</p>

<object id="nor.svg" data="nor.svg" type="image/svg+xml" class="diagram">NOR</object>

<p>The <span class="nowrap">L-tetromino</span> operates as an OR gate, resulting in output opposite of OR.</p>

<h2 id="nand">NAND</h2>

<p>NAND is a <span class="nowrap">two-input</span> gate that outputs the complement of the <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a> of its inputs. That is, the output is <span class="mono">0</span> only when both inputs are <span class="mono">1</span>.</p>

<p>It is a universal gate. NAND gates alone can be combined to form any other gate.</p>

<p>The code below realizes NAND as inverters feeding into an OR. It is based on one of <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>, <span class="math"><span class="overline">AB</span> = <span class="overline">A</span> + <span class="overline">B</span></span>.</p>

<pre class="code">
<span class="filename">nand.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 6</span></span>
</pre>

<p>The follow image reveals the output for all possible inputs.</p>

<object id="nand.svg" data="nand.svg" type="image/svg+xml" class="diagram">NAND</object>

<p>The horizontal <span class="nowrap">I-tetromino</span> functions as an OR gate.</p>

<h2 id="and">AND</h2>

<p>AND is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a> of its inputs. That is, the output is <span class="mono">1</span> only when both inputs are <span class="mono">1</span>.</p>

<p>The code below constructs AND from a NAND gate connected to an inverter.</p>

<pre class="code">
<span class="filename">and.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">0 5</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 10</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object id="and.svg" data="and.svg" type="image/svg+xml" class="diagram">AND</object>

<p>The <span class="nowrap">J-tetromino</span> of the upper inverter functions as an OR gate.</p>

<h2 id="xor">XOR</h2>

<p>XOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Exclusive_or" target="_blank">exclusive disjunction</a> of its inputs. That is, it outputs <span class="mono">1</span> only when the inputs are unequal.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">A &oplus; B<span></p>
      
<p><span class="math">= (A &ne; B)</p>      
      
<p><span class="math">= <span class="overline">A</span>B + A<span class="overline">B</span></p>      
     
<p><span class="math">= <span class="overline">A</span>A + <span class="overline">A</span>B + A<span class="overline">B</span> + B<span class="overline">B</span><span></p>
      
<p><span class="math">= <span class="overline">A</span>(A + B) + <span class="overline">B</span>(A + B)</p>  

<p><span class="math">= <span class="overline">A</span> <span class="overline">C</span> + <span class="overline">B</span> <span class="overline">C</span>, C = <span class="overline">A + B</span></p>  

<p><span class="math">= <span class="overline">A + C</span> + <span class="overline">B + C</span>, C = <span class="overline">A + B</span></span></p>

<p>That suggests the following construction of XOR from 3 NOR gates and an OR gate.</p>

<object id="xor-schematic.svg" data="xor-schematic.svg" type="image/svg+xml" class="diagram">XOR Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">xor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">3</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">2 5</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 11</span></span>
</pre>

<p><span class="mono">_norLeft</span> is a compact NOR gate composed of two <span class="nowrap">O-tetrominoes</span>. It is detailedÂ in <a href="#intermediate-gates">a later section</a>.</p>

<p>Here are the results for all input combinations:</p>

<object id="xor.svg" data="xor.svg" type="image/svg+xml" class="diagram">XOR</object>

<p>The L- and J-tetrominoes resting on the <span class="nowrap">O-tetrominoes</span> and the vertical <span class="nowrap">I-tetrominoes</span> act as wires. TheÂ bases of the inverters serve as OR gates, making them function asÂ NORs. And the horizontal <span class="nowrap">I-tetromino</span> at the top operates as an OR gate.</p>

<h2 id="xnor">XNOR</h2>

<p>XNOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_equality" target="_blank">equality</a> of its inputs. That is, the output is <span class="mono">1</span> only when the inputs are equal.</p>

<p>The code below constructs XNOR from an XOR gate connected to an inverter.</p>

<pre class="code">
<span class="filename">xnor.t</span>
<span class="line"><span class="normal">xor </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">0 11</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 16</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object id="xnor.svg" data="xnor.svg" type="image/svg+xml" class="diagram">XNOR</object>

<h2 id="intermediate-gates">Intermediate Gates</h2>

<p>The <a href="#inverter-not">inverter described above</a> consists of an O wedged between an L and a J. However, it is possible to implement an inverter with a single <span class="nowrap">O-tetromino</span>:</p>

<pre class="code">
<span class="filename">_notLeft.t</span>
<span class="line"><span class="normal">o </span><span class="number">-1 2 0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 1</span></span>
</pre>

<p>As shown in the animated constructions below, the input and output nodes overlap. When the input is <span class="mono">1</span>, the overlap establishes an output of <span class="mono">0</span> before the <span class="nowrap">O-tetromino</span> drops. Though, when the input is <span class="mono">0</span>, the output node is initially unassigned.</p>

<object id="animated-intermediate-not.svg" data="animated-intermediate-not.svg" type="image/svg+xml" class="diagram">Intermediate NOT</object>

<p><span class="mono">_notLeft</span>'s compact size translates to smaller circuits, which should be motivation to use it frequently. But in practice, it is used sparingly because, when the input is <span class="mono">1</span>, it fails to support the <span class="nowrap">O-tetromino</span>. If that <span class="nowrap">O-tetromino</span> leaks out of a circuit, it will plummet until it meets the surface of the pile, where it can interfere with other circuits. The resultant unpredictable behavior renders such circuits incompatible with an important optimization, described in <a href="#simulation">a later section</a>, which depends on consistent circuit operation.</p>

<p>To use <span class="mono">_notLeft</span> safely, the <span class="nowrap">O-tetromino</span> must be caught. This is practical only in the interior of circuits, where the surrounding components act as barriers. There, <span class="mono">_notLeft</span> and other leaky gates are relegated to processing intermediate values, hence the designation, &ldquo;intermediate gates&rdquo;. Their names start with an underscore to make them instantly distinguishable from ordinary gates.</p>

<p>Smaller circuits suggest faster processing. But the aforementioned optimization makes circuits built purely out of ordinary gates compute just as quickly despiteÂ their larger size. There is no justification for intermediate gates except that their compact nature effectuates aesthetically pleasing designs. That is the impetus behind the following variation of the intermediate inverter.</p>

<pre class="code">
<span class="filename">_notLeft2.t</span>
<span class="line"><span class="normal">o </span><span class="number">-1 2 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 1</span></span>
</pre>

<p><span class="mono">_notLeft2</span> nudges the <span class="nowrap">O-tetromino</span> right twice:</p>

<object id="animated-intermediate-not-2.svg" data="animated-intermediate-not-2.svg" type="image/svg+xml" class="diagram">Intermediate NOT 2</object>

<p>The construction assumes the fall speed is slow enough to slide the <span class="nowrap">O-tetromino</span> across the surface of the input node when the input value is <span class="mono">0</span>.</p>

<p><span class="mono">_notLeft2</span> is attached to the output of an ordinary OR gate to create an intermediate NOR gate:</p>

<pre class="code">
<span class="filename">_norLeft.t</span>
<span class="line"><span class="normal">or </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">_notLeft2 </span><span class="number">-1 2</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 3</span></span>
</pre>

<p>Its response to all possible inputs appears below.</p>

<object id="intermediate-nor.svg" data="intermediate-nor.svg" type="image/svg+xml" class="diagram">Intermediate NOR</object>

<p>On <span class="nowrap">line 2</span> of the code, if <span class="mono">_notLeft2</span> is replaced with <span class="mono">_notLeft</span>, the intermediate NOR gate works just as well. However, when both inputs are <span class="mono">0</span>, the vertical column of <span class="nowrap">O-tetrominoes</span> becomes lopsided, an aesthetically displeasing configuration.</p>

<p><span class="mono">_norLeft</span> is found in the interior of the ordinary XOR gate to reduce its size and to guarantee the <span class="nowrap">O-tetromino</span> is always caught.</p>

<p>The &ldquo;<span class="mono">Left</span>&rdquo; in the names of these intermediate gates refers the side of the inputs nudged by the <span class="nowrap">O-tetromino</span>. Horizontally-reflected versions exist called <span class="mono">_notRight</span>, <span class="mono">_notRight2</span>, and <span class="mono">_norRight</span>.</p>

<p>The intermediate NAND gate, <span class="mono">_nand</span>, uses intermediate inverters to feed input complements into an ordinary OR gate:</p>

<pre class="code">
<span class="filename">_nand.t</span>
<span class="line"><span class="normal">_notLeft </span><span class="number">-1 0</span></span>
<span class="line"><span class="normal">_notRight </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">or </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 3</span></span>
</pre>

<p>Intermediate NAND leaks up to two <span class="nowrap">O-tetrominoes</span>:</p>

<object id="intermediate-nand.svg" data="intermediate-nand.svg" type="image/svg+xml" class="diagram">Intermediate NAND</object>

<p>The intermediate AND gate, <span class="mono">_andLeft</span>, consists of an intermediate NAND in series with an intermediate inverter:</p>

<pre class="code">
<span class="filename">_andLeft.t</span>
<span class="line"><span class="normal">_nand </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">_notLeft2 </span><span class="number">-1 3</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 4</span></span>
</pre>

<p>Here is its responses to all inputs:</p>

<object id="intermediate-and.svg" data="intermediate-and.svg" type="image/svg+xml" class="diagram">Intermediate AND</object>

<p>Its horizontally-reflected version goes by the name <span class="mono">_andRight</span>.</p>

<p>While a single intermediate NOR appears in the ordinary XOR, the intermediate XOR, <span class="mono">_xor</span>, employs three of them:</p>

<pre class="code">
<span class="filename">_xor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">3</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">_norRight </span><span class="number">3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">or </span><span class="number">0 9</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 11</span></span>
</pre>

<p>Like the intermediate NAND and AND gates, intermediate XOR emits up to two <span class="nowrap">O-tetrominoes</span>:</p>

<object id="intermediate-xor.svg" data="intermediate-xor.svg" type="image/svg+xml" class="diagram">Intermediate XOR</object>

<p>Other intermediate gates are possible. But aside from the intermediate NOR gate and the intermediate inverter it is based on, the rest are not used. Their petiteness and visual appeal are not compelling enough to use them over ordinary gates, which operate safely in all circumstances.</p>

<h1 id="wires">Wires</h1>

<p>This section discusses <span class="term">wires</span>, theÂ structuresÂ thatÂ transfer bitsÂ from one part of a circuit to another.</p>

<h2 id="fan-out">Fan-out</h2>

<p><span class="term">Fan-out</span> is the number of connections radiating from an output node. As illustrated in the animation below, lines of S- and Z-tetrominoes enable unlimited fan-out.</p>

<object id="fan-out.svg" data="fan-out.svg" type="image/svg+xml" class="diagram">Fan-out</object>

<p>Rising staircases of horizontal I-tetrominoes can achieve the same.</p>

<h2 id="fan-in">Fan-in</h2>

<p>Wires that converge on a common node require a device to combine their signals, such as a multi-input OR gate. <span class="term">Fan-in</span> is the number of inputs of such a device. As demonstrated in the following animation, a line of Z- or S-tetrominoes can provide unlimited fan-in. </p>

<object id="fan-in.svg" data="fan-in.svg" type="image/svg+xml" class="diagram">Fan-in</object>

<p>Alternatively, a tree of gates can mergeÂ a boundless number of inputs.</p>

<h2 id="crossing">Crossing</h2>

<p>In a three-dimensional universe, wires can cross over each other without connecting. But on the two-dimensional playfield, a cross requires a planar device that mutually exchanges inputs. That device implements the <a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" target="_blank">XOR swap algorithm</a>. It stores the XOR of inputs <span class="math">A</span> and <span class="math">B</span> into a temporary variable, <span class="math">C</span>:</p>

<p><span class="math">C = A &oplus; B</span></p>

<p>Then it XORs the inputs withÂ that temporary variable, which swaps them:</p>

<p><span class="math">A &oplus; C = A &oplus; A &oplus; B = B</span></p>

<p><span class="math">B &oplus; C = B &oplus; A &oplus; B = A</span></p>

<p>Those steps suggests this circuit:</p>

<object id="swap-schematic.svg" data="swap-schematic.svg" type="image/svg+xml" class="diagram">Swap Schematic</object>

<p>Since two-dimensional XOR gates exist and the circuit does not contain any cross-overs, it achieves a planar swap.</p>

<p>In following the actualization, the lower XOR gate of the schematic is made from three NORs and a horizontal I-tetromino operating as an OR. The other pieces function as wires.</p>

<pre class="code">
<span class="filename">swap.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">ll </span><span class="number">-4</span></span>
<span class="line"><span class="normal">jr </span><span class="number">3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">5</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">_norRight </span><span class="number">3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">6 7</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">jd </span><span class="number">-6</span></span>
<span class="line"><span class="normal">ld </span><span class="number">5</span></span>
<span class="line"><span class="normal">xor </span><span class="number">-4 10</span></span>
<span class="line"><span class="normal">xor </span><span class="number">4 10</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i1 </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">i0 </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o1 </span><span class="number">-6..-3 21</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o0 </span><span class="number">2..5 21</span></span>
</pre>

<p>As demonstrated below, the outputs are the inputs, but positionally exchanged.</p>

<object id="swap.svg" data="swap.svg" type="image/svg+xml" class="diagram">Swap</object>

<p>The following animation shows a diagonal wire crossing over multiple vertical wires via repeated application of the swap circuit.</p>

<object id="cross-seven.svg" data="cross-seven.svg" type="image/svg+xml" class="diagram">Cross Seven</object>

<h2 id="multiplexing">Multiplexing</h2>

<p>A <span class="term">multiplexer</span> is a switch that channels one of the inputs to the output. A <span class="nowrap">2-to-1</span> multiplexer outputs <span class="math">AS + B<span class="overline">S</span></span>, where <span class="math">A</span> and <span class="math">B</span> are the inputs, and <span class="math">S</span> is the <span class="term">selector</span> that controls the switch.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">AS + B<span class="overline">S</span></span></p>

<p><span class="math">= AS + <span class="high-overline"><span class="overline">B</span> + S</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">AS</span>(<span class="overline">B</span> + S)</span></span></p>

<p>That suggests two NAND gates, an OR gate, and an inverter arranged as follows.</p>

<object id="mux-schematic.svg" data="mux-schematic.svg" type="image/svg+xml" class="diagram">Multiplexer Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">muxLeft.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-4</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-4 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-1 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">4 1</span></span>
<span class="line"><span class="normal">jr </span><span class="number">1</span></span>
<span class="line"><span class="normal">o </span><span class="number">2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">3</span></span>
<span class="line"><span class="normal">nand </span><span class="number">0 7</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">l </span><span class="number">-6..-3 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">s </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">r </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 13</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object id="mux.svg" data="mux.svg" type="image/svg+xml" class="diagram">Multiplexer</object>

<p>The selector (the center input) is <span class="mono">0</span> in the upper-row and <span class="mono">1</span> in the lower-row.</p>

<p>As suggested by its name, <span class="mono">muxLeft</span> outputs the left-input when the selector is <span class="mono">1</span>. A horizontally-reflected version, <span class="mono">muxRight</span>, outputs the right-input when the selector is <span class="mono">1</span>.</p>

<h1 id="functions">Functions</h1>

<p>This section describes the arithmetic and logic functions implemented for a general-purpose computer.</p>

<h2 id="functions-overview">Overview</h2>

<p>A function, <span class="math">f</span>, is a structure with a rectangular footprint whose bottom edge consists a row of input nodes that stores an input value, <span class="math">V</span>, and whose top edge consists of a row of output nodes that stores an output value, <span class="math">f(V)</span>:</p>

<object id="function-f.svg" data="function-f.svg" type="image/svg+xml" class="diagram">Function f</object>

<p>The composition of two functions, <span class="math">f(g(V))</span>, comprises <span class="math">f</span> on top of <span class="math">g</span> on top of <span class="math">V</span>, where <span class="math">g</span>â€™s output nodes serve as <span class="math">f</span>â€™s input nodes:</p>

<object id="function-f-of-g.svg" data="function-f-of-g.svg" type="image/svg+xml" class="diagram">Function f of g</object>

<p>Functions employ a standard interface: a row of nodes, evenly spaced, ten columns apart. That interval provides sufficient room for bits to cross or to combine. And a round, <span class="nowrap">base-10</span> number simplifies measurements during design.</p> 

<p>A functionâ€™s input and output values have the same <span class="nowrap">bit width</span> and their bits line up. That is, the <span class="math">i<span class="sup">th</span></span> input node shares a common column with the <span class="math">i<span class="sup">th</span></span> output node.</p>  

<p>The general-purpose computer contains 8-, 16-, and <span class="nowrap">24-bit</span> functions. Some of its <span class="nowrap">16-bit</span> functions interpret the input value, <span class="math">V</span>, as a <span class="nowrap">2-byte</span> array, <span class="nowrap"><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span></span>, where <span class="math">A</span> and <span class="math">B</span> are the high and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 652px">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top right green">B<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>Similarly, some of its <span class="nowrap">24-bit</span> functions interpret the input value, <span class="math">V</span>, as a <span class="nowrap">3-byte</span> array, <span class="nowrap"><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span></span>, where <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> are the high, middle, and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top green">B<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>One <span class="nowrap">24-bit</span> function interprets the input value, <span class="math">V</span>, as a <span class="nowrap">two-element</span> array, <span class="nowrap"><span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span></span>, where <span class="math">W</span> is a word composed of the high and middle bytes of <span class="math">V</span>, and <span class="math">C</span> is the low byte of <span class="math">V</span>:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top cyan">W<span class="sub">15</span></td><td class="top cyan">W<span class="sub">14</span></td><td class="top cyan">W<span class="cyan">13</span></td><td class="top cyan">W<span class="sub">12</span></td><td class="top cyan">W<span class="sub">11</span></td><td class="top cyan">W<span class="sub">10</span></td><td class="top cyan">W<span class="sub">9</span></td><td class="top cyan">W<span class="sub">8</span></td><td class="top cyan">W<span class="sub">7</span></td><td class="top cyan">W<span class="sub">6</span></td><td class="top cyan">W<span class="sub">5</span></td><td class="top cyan">W<span class="sub">4</span></td><td class="top cyan">W<span class="sub">3</span></td><td class="top cyan">W<span class="sub">2</span></td><td class="top cyan">W<span class="sub">1</span></td><td class="top cyan">W<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>A function that accepts an array will return an array of identical dimension.</p>

<h2 id="identity">Identity</h2>

<p>An <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a> echos the provided value:</p>

<p><span class="math">f(x) = x</span></p> 

<p>The image below depicts an <span class="nowrap">8-bit</span> identity function of an arbitrary height.</p>

<object id="identity.svg" data="identity.svg" type="image/svg+xml" class="diagram">Identity</object>

<p>As described in a <a href="#memory">later section</a>, memory circuits involve functions horizontally sandwiched between identity functions: </p>

<object id="identity-sandwich.svg" data="identity-sandwich.svg" type="image/svg+xml" class="diagram">Identity Sandwich</object>

<p>Those circuits introduce a constraint on the dimensions of a functionâ€™s rectangular footprint: its base cannot extend more than nine columns beyond its outermost nodes.</p>

<h2 id="constant">Constant</h2>

<p>A constant function outputs the same value regardless of its input:</p>

<p><span class="math">f(x) = k</span></p>

<p>A <span class="nowrap">1-bit</span> function that always returns <span class="mono">0</span> is realized by XORing the input with itself:</p>

<p><span class="math">f(A) = A &oplus; A = </span><span class="serif">0</span></p>

<p>The code below links both inputs of an XOR gate withÂ a horizontal I-tetromino.</p>

<pre class="code">
<span class="filename">false.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 12</span></span>
</pre>

<p>The tests in the following image affirm the circuit consistently outputs <span class="mono">0</span>.</p>

<object id="false.svg" data="false.svg" type="image/svg+xml" class="diagram">False</object>

<p>A <span class="nowrap">1-bit</span> function that always returns <span class="mono">1</span> is realized by XNORing the input with itself:</p>

<p><span class="math">f(A) = <span class="overline">A &oplus; A</span> = </span><span class="serif">1</span></p>

<p>A horizontal I-tetromino joins the inputs of an XNOR gate in the code below.</p>

<pre class="code">
<span class="filename">true.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xnor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 17</span></span>
</pre>

<p>The following image reveals the circuit invariably yields <span class="mono">1</span>.</p>

<object id="true.svg" data="true.svg" type="image/svg+xml" class="diagram">True</object>

<p>A constant byte function is an assemblage of eight <span class="nowrap">1-bit</span> constant functions. The image below depicts the constant byte function <span class="nowrap"><span class="math">f(x) = </span><span class="serif">0</span></span> for an arbitrary input value.</p>

<object id="clear.svg" data="clear.svg" type="image/svg+xml" class="diagram">Clear</object>

<p>And here is the requisite <span class="math">f(x) = </span><span class="serif">42</span> function:</p>

<object id="constant-42.svg" data="constant-42.svg" type="image/svg+xml" class="diagram">42</object>

<h2 id="logical-left-shift">Logical Left Shift</h2>

<p>Logical left shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the left. The rightmost bit is set to <span class="mono">0</span> and the leftmost bit is lost:</p>

<object id="logical-left-shift.svg" data="logical-left-shift.svg" type="image/svg+xml" class="diagram">Logical Left Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting a signed or unsigned value left by <span class="math">n</span> bits is equivalent to multiplying by <span class="serif">2</span><span class="math pow">n</span>: 

<p><span class="math">f(x) = </span><span class="serif">2</span><span class="math pow">n</span><span class="math">x</span></p>

<h2 id="logical-right-shift">Logical Right Shift</h2>

<p>Logical right shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the right. The leftmost bit is set to <span class="mono">0</span> and the right most bit is lost:</p>

<object id="logical-right-shift.svg" data="logical-right-shift.svg" type="image/svg+xml" class="diagram">Logical Right Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting an unsigned value right by <span class="math">n</span> bits is equivalent to dividing by <span class="serif">2</span><span class="math pow">n</span>, rounding toward <span class="serif">0</span>:</p>

<p><span class="math">f(x) = </span><span class="math">x</span><span class="serif"> / 2</span><span class="math pow">n</span></p>

<h2 id="logical-and">Logical AND</h2>

<p>The logical AND function operates on a <span class="nowrap">3-byte</span> array, where all three bytes are Booleans, values restricted to <span class="mono">0</span> and <span class="mono">1</span>. It ANDs the first and second bytes together, and it puts the result in the third byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">C = AB</span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are ANDed together:</p>

<object id="and-a-b-c-schematic.svg" data="and-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Logical AND Schematic</object>

<p>In the Tetris realization below, the AND gate is miniscule in comparison to the swap circuits required for <span class="math">A<span class="sub">0</span></span> to traverse the <span class="math">B</span> lines.</p>

<object id="and-a-b-c.svg" data="and-a-b-c.svg" type="image/svg+xml" class="diagram">Logical AND</object>

<h2 id="logical-and-not">Logical AND-NOT</h2>

<p>The logical AND-NOT function operates on a <span class="nowrap">2-byte</span> array, where both bytes are Booleans, values restricted to <span class="mono">0</span> and <span class="mono">1</span>. It replaces the first byte with the first byte ANDed with the inverse of the second byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">A,B,Q </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q = A<span class="overline">B</span></span></p>

<p><span class="math">B</span> passes through unchanged, while <span class="math">A</span> is lost.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are used to produce <span class="math">Q</span>:</p>

<object id="and-a-not-b-schematic.svg" data="and-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>The wire leading to the inverter&mdash;the horizontal line in the schematic above&mdash;appears diagonal in the Tetris realization because it consists of swap circuits stacked right-to-left, the arrangement required to propagate the signal across the <span class="math">B</span> lines:</p>

<object id="and-a-not-b.svg" data="and-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>There is a variation that operates on a 3-byte array, where all three bytes are Booleans. It sets the first byte to the second byte ANDed with the inverse of the third byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">C = A<span class="overline">B</span></span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p>As above, only the lowest bits of <span class="math">A</span> and <span class="math">B</span> are used to generate the result:</p>

<object id="and-c-a-not-b-schematic.svg" data="and-c-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>The Tetris version follows.</p>

<object id="and-c-a-not-b.svg" data="and-c-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT</object>

<h2 id="bitwise-and">Bitwise AND</h2>

<p>The bitwise AND function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise AND of both bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></span></p>

<p><span class="math">Q = AB</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an AND gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object id="bitwise-and-fb-schematic.svg" data="bitwise-and-fb-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>In the Tetris version below, the AND gates are arranged in a line in the top-left. The space-dominating parallelogram is composed of parallel chains of swap circuits that propagate the bits of <span class="math">B</span> from right-to-left. Each chain is equivalent to one of the horizontal wires in the schematic. Since the swap circuits must be stacked to form a chain, the signals advance diagonally-upward.</p>

<object id="bitwise-and-fb.svg" data="bitwise-and-fb.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<p>There is a variation that sets the second byte to the bitwise AND of both bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q </span><span class="math">]</span></span></p>

<p><span class="math">Q = AB</span> and <span class="math">A</span> passes through, unchanged.</p>

<p>Its circuit is the horizontal reflection of the one above:</p>

<object id="bitwise-and-af-schematic.svg" data="bitwise-and-af-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>The Tetris realization follows.</p>

<object id="bitwise-and-af.svg" data="bitwise-and-af.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<h2 id="bitwise-or">Bitwise OR</h2>

<p>The bitwise OR function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise OR of both bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></span></p>

<p><span class="math">Q = A + B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an OR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object id="bitwise-or-schematic.svg" data="bitwise-or-schematic.svg" type="image/svg+xml" class="diagram">Bitwise OR Schematic</object>

<p>In the Tetris version below, the line of yellow <span class="nowrap">O-tetrominoes</span> in the top-left are the OR gates. The explanation for the parallelogram is the same as the one described for bitwise AND.</p>

<object id="bitwise-or.svg" data="bitwise-or.svg" type="image/svg+xml" class="diagram">Bitwise OR</object>

<p>A horizontally reflected version was not implemented.</p>

<h2 id="bitwise-xor">Bitwise XOR</h2>

<p>The bitwise XOR function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise XOR of both bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></span></p>

<p><span class="math">Q = A &oplus; B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an XOR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object id="bitwise-xor-schematic.svg" data="bitwise-xor-schematic.svg" type="image/svg+xml" class="diagram">Bitwise XOR Schematic</object>

<p>In the Tetris version below, the XOR gates are arranged in a line in the top-left. The explanation for the parallelogram is the same as the one described for bitwise AND.</p>

<object id="bitwise-xor.svg" data="bitwise-xor.svg" type="image/svg+xml" class="diagram">Bitwise XOR</object>

<p>A horizontally reflected version was not implemented.</p>

<h2 id="byte-swap">Byte Swap</h2>

<p>The byte swap function exchanges the elements of a <span class="nowrap">2-byte</span> array:</p>

<p><span class="nowrap"><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, A </span><span class="serif">]</span></span></p>

<p>It is realized with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object id="swap-8-schematic.svg" data="swap-8-schematic.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap Schematic</object>

<p>The diamond pattern in the schematic appears in the Tetris version below due to extensive use of the swap circuit.</p>

<object id="swap-8.svg" data="swap-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap</object>

<h2 id="byte-match">Byte Match</h2>

<p>The byte match function operates on a <span class="nowrap">2-byte</span> array:</p>

<p><span class="nowrap"><span class="math">f(</span><span class="serif"> [</span><span class="math">A, X</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, M </span><span class="serif">]</span></span></p>

<p><span class="math">A</span> is compared against a bit pattern. If it matches, <span class="math">M</span> is <span class="mono">1</span>; otherwise, <span class="math">M</span> is <span class="mono">0</span>. In either case, <span class="math">A</span> passes through unchanged, while <span class="math">X</span> is discarded.</p>

<p>The bit pattern consists of zeros, ones, and <a href="https://en.wikipedia.org/wiki/Don%27t-care_term" target="_blank">donâ€™t-cares</a>. Meaning, each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, is either compared against a constant or it is ignored. For example, the following expression checks if all <span class="math">A<span class="sub">i</span></span> are <span class="mono">1</span>:</p> 

<p><span class="math">M = A<span class="sub">7 </span>A<span class="sub">6 </span>A<span class="sub">5 </span>A<span class="sub">4 </span>A<span class="sub">3 </span>A<span class="sub">2 </span>A<span class="sub">1 </span>A<span class="sub">0 </span> = <span class="high-overline"><span class="overline2">A<span class="sub">7</span></span> + <span class="overline2">A<span class="sub">6</span></span> + <span class="overline2">A<span class="sub">5</span></span> + <span class="overline2">A<span class="sub">4</span></span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>That suggests the following circuit.</p>

<object id="match-ff-right-schematic.svg" data="match-ff-right-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Right</object>

<p>Each <span class="math">A<span class="sub">i</span></span> column contains an inverter pair, which enables <span class="math">A</span> to traverse unmodified. For an arbitrary constant, <span class="math">K</span>, inverter pairs only exist in the columns where <span class="math">K<span class="sub">i</span></span> is <span class="mono">1</span>. For instance, the expression below checks if <span class="math">A</span> is <span class="mono">0</span>:</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span> + A<span class="sub">1</span> + A<span class="sub">0</span></span></span></p>

<p>It requires no inverter pairs, as illustrated by the Tetris realization:</p>

<object id="match-zero-right.svg" data="match-zero-right.svg" type="image/svg+xml" class="diagram">Match Zero Right</object>

<p>Horizontal <span class="nowrap">J-tetrominoes</span> operate as OR gates. Each feeds an input bit to both terminals of a swap circuit.</p>

<p>The following expression checks if <span class="math">A</span> is binary value <span class="mono">00101111</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> A<span class="sub">5</span> <span class="overline2">A<span class="sub">4</span></span> A<span class="sub">3</span> A<span class="sub">2</span> A<span class="sub">1</span> A<span class="sub">0</span> = <span class="high-overline">A<span class="sub">7</span> + A<span class="sub">6</span> + <span class="overline2">A<span class="sub">5</span></span> + A<span class="sub">4</span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>It is actualized by introducing inverter pairs corresponding to the <span class="mono">1</span> bits:</p>

<object id="match-smn-right.svg" data="match-smn-right.svg" type="image/svg+xml" class="diagram">Match SMN Right</object>

<p>Donâ€™t-care bits are omitted from the OR chain. For instance, the following expression tests if A is <span class="mono">000000**</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span></span></span></p>

<p>In the Tetris realization below, two of the horizontal <span class="nowrap">J-tetrominoes</span> are absent, enabling <span class="math">A<span class="sub">1</span></span> and <span class="math">A<span class="sub">0</span></span> to cross the OR chain without contributing to it.</p>

<object id="match-tax-right.svg" data="match-tax-right.svg" type="image/svg+xml" class="diagram">Match TAX Right</object>

<p>There is a variation of the byte match function whereÂ the parameters are swapped:</p>

<p><span class="nowrap"><span class="math">f(</span><span class="serif"> [</span><span class="math">X, A</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> M, A </span><span class="serif">]</span></span></p>

<p>Its circuit is nearly the horizontal-reflection of the one above:  </p>

<object id="match-ff-left-schematic.svg" data="match-ff-left-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Left</object>

<p>In the Tetris version below, the inverter pairs are omitted, resulting in a zero detector. </p>

<object id="match-zero-left.svg" data="match-zero-left.svg" type="image/svg+xml" class="diagram">Match Zero Left</object>

<h2 id="equals">Equals</h2>

<p>The equals function operates on a <span class="nowrap">3-byte</span> array:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="serif">]</span></span></p>

<p><span class="math">E</span> is <span class="mono">1</span> if <span class="math">A</span> equals <span class="math">B</span>; otherwise, <span class="math">E</span> is <span class="mono">0</span>. Either way, <span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p><span class="math">E</span> is defined by the following expression, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<p><span class="math">E = (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)</span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span></span></p>

<p>That suggests the following circuit.</p>

<object id="equals-a-b-e-schematic.svg" data="equals-a-b-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>In the Tetris version below, a constant bit function seeds the AND chain with <span class="mono">1</span> (see lower-right).</p>

<object id="equals-a-b-e.svg" data="equals-a-b-e.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Since the evaluation order is established by the sequence in which components are built, each inputÂ propagates upward as it advances from left-to-right. The diamond arrangement of swap circuits is a consequence of nearly-parallel, diagonally-upward lines that terminate on the vertical AND chain.</p>

<p>There is a variation of the equals function where the parameters are rearranged:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> E, A, B </span><span class="serif">]</span></span></p>

<p>Its circuit is roughly the horizontal-reflection of the one above:</p>

<object id="equals-e-a-b-schematic.svg" data="equals-e-a-b-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Here is the Tetris realization:</p>

<object id="equals-e-a-b.svg" data="equals-e-a-b.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>There is a another variation that uses all three input bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, V </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">V,E </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">E</span> is <span class="mono">1</span> iff <span class="math">A</span> equals <span class="math">B</span> and <span class="math">V</span> is <span class="mono">1</span>:</p>

<p><span class="math">E = (A = B)V</span> 

<p><span class="math">= (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)V<span class="sub">0</span></span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span> V<span class="sub">0</span></span></p>
  
<p>It provides a way to compare multiple bytes:</p>

<p><span class="math">V = (T = U)</span></p>

<p><span class="math">V&prime; = (R = S)V = (R = S)(T = U)</span></p>

<p><span class="math">V&Prime; = (P = Q)V&prime; = (P = Q)(R = S)(T = U)</span></p>

<p>And so on.</p>

<p>The variation can be realized by using the lowest bit of <span class="math">V</span> as the seed of the AND chain. Instead, in an effort to reuse wherever possible, an AND gate was added to the top of the existing circuit:</p>

<object id="equals-a-b-and-e-schematic.svg" data="equals-a-b-and-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The Tetris implementation follows.</p>

<object id="equals-a-b-and-e.svg" data="equals-a-b-and-e.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The horizontal-reflection of this variation was not implemented. </p>

<h2 id="byte-copy">Byte Copy</h2>

<p>The byte copy function operates on a <span class="nowrap">2-byte</span> array. It copies the first byte to the second byte:</p> 

<p><span class="nowrap"><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, A </span><span class="serif">]</span></span></p>

<p>This is accomplished with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object id="copy-a-b-schematic.svg" data="copy-a-b-schematic.svg" type="image/svg+xml" class="diagram">Copy A to B Schematic</object>

<p>The Tetris version appears below.</p>

<object id="copy-a-b.svg" data="copy-a-b.svg" type="image/svg+xml" class="diagram">Copy A to B</object>

<p>The space-dominating triangle consists of diagonally-upwardÂ chains of swap circuit. After they cross the center wire, horizontal lines of <span class="nowrap">Z-tetrominoes</span> carry the signals the rest of the way.</p>

<p>A variation of the function copies the second byte to the first byte:</p>

<p><span class="nowrap"><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, B </span><span class="serif">]</span></span></p>

<p>It is the horizontal-reflection of the previous circuit:</p>

<object id="copy-b-a-schematic.svg" data="copy-b-a-schematic.svg" type="image/svg+xml" class="diagram">Copy B to A Schematic</object>

<p>The Tetris version follows.</p>

<object id="copy-b-a.svg" data="copy-b-a.svg" type="image/svg+xml" class="diagram">Copy B to A</object>

<h2 id="conditional-byte-copy">Conditional Byte Copy</h2>

<p>The conditional byte copy function operates on a <span class="nowrap">3-byte</span> array. It either copies the first byte to the second byte, or it does nothing, per the value of the third byte.</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q, C </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>In its circuit, shown below, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of a <span class="nowrap">2-to-1</span> multiplexer that selects between <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> based on <span class="math">C<span class="sub">0</span></span>.</p>

<object id="copy-a-b-c-schematic.svg" data="copy-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Here is the Tetris version:</p>

<object id="copy-a-b-c.svg" data="copy-a-b-c.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Flipping the circuit horizontally creates a variation that either copies the third byte to the second byte, or does nothing, per the value of the first byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, Q, B </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">C</span> and <span class="math">B</span> pass through, unchanged.</p>

<p>The flipped circuit appears below.</p>

<object id="copy-c-b-a-schematic.svg" data="copy-c-b-a-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>The Tetris version follows.</p>

<object id="copy-c-b-a.svg" data="copy-c-b-a.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Repositioning the multiplexers from the <span class="math">A</span> lines to the <span class="math">B</span> lines reverses the roles of the second and third bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, Q </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>Here is the schematic:</p>

<object id="copy-c-a-b-schematic.svg" data="copy-c-a-b-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Below is the Tetris version.</p>

<object id="copy-c-a-b.svg" data="copy-c-a-b.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Finally, flipping that circuit horizontally yields a variation that either copies the second byte to the first byte, or does nothing, per the value of the third byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B, C </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">B</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>The flipped circuit follows.</p>

<object id="copy-b-a-c-schematic.svg" data="copy-b-a-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Here is the Tetris realization:</p>

<object id="copy-b-a-c.svg" data="copy-b-a-c.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<h2 id="decrement">Decrement</h2>

<p>The decrement function subtracts one from its argument:</p>

<p><span class="math">f(x) = x &minus; </span><span class="serif">1</span></p>

<p>Its circuit consists of chain of <a href="https://en.wikipedia.org/wiki/Subtractor#Half_subtractor" target="_blank">half subtractors</a>, devices capable of single-digit subtraction. Each half subtractor accepts a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">minuend</a>, <span class="math">X</span>, and a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">subtrahend</a>, <span class="math">Y</span>, and it returns their signed difference, a <span class="nowrap">2-bit</span> value composed of the sign bit, <span class="math">B</span>, and the ones bit, <span class="math">D</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">B</th><th class="math">D</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &minus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &minus; 1 = &minus;1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &minus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &minus; 1 = 0</span></td></tr>
</table>

<p>The table reveals <span class="math">B</span> and <span class="math">D</span> are:</p>

<p><span class="math">B = <span class="overline">X</span>Y</span></p>

<p><span class="math">D = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = B + X<span class="overline">Y</span></span></p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math"><span class="overline">X</span>Y = <span class="overline">X</span>X + <span class="overline">X</span>Y = <span class="overline">X</span>(X + Y) = <span class="high-overline">X + <span class="overline">X + Y</span></span> = <span class="overline">X + T</span>, T = <span class="overline">X + Y</span></span></p>

<p><span class="math">X<span class="overline">Y</span> = X<span class="overline">Y</span> + Y<span class="overline">Y</span> = <span class="overline">Y</span>(X + Y) = <span class="high-overline">Y + <span class="overline">X + Y</span></span> = <span class="overline">Y + T</span>, T = <span class="overline">X + Y</span></span></p>

<p>Cleaning up:</p>

<p><span class="math">T = <span class="overline">X + Y</span></span></p>

<p><span class="math">B = <span class="overline">X + T</span></span></p>

<p><span class="math">D = B + <span class="overline">Y + T</span></span></p>

<p>That implies the following circuit.</p>

<object id="half-subtractor-schematic.svg" data="half-subtractor-schematic.svg" type="image/svg+xml" class="diagram">Half Subtractor Schematic</object>

<p>In the code below, which is based on that schematic, a horizontal I-tetromino functions as the upperÂ OR.</p>

<pre class="code">
<span class="filename">halfSubtractor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-1</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-2</span></span>
<span class="line"><span class="normal">lr </span><span class="number">3</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">nor nor1 </span><span class="number">1 1</span></span>
<span class="line"><span class="normal">nor nor2 </span><span class="number">-1 6</span></span>
<span class="line"><span class="normal">nor nor3 </span><span class="number">3 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-4</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">b </span><span class="number">-5 14</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">d </span><span class="number">-2 14</span></span>
</pre>

<p>Here is its response to all input combinations:</p>

<object id="half-subtractor.svg" data="half-subtractor.svg" type="image/svg+xml" class="diagram">Half Subtractor</object>

<p>In the full circuit, half subtractors are chained in the following configuration, where each <span class="math">I<span class="sub">i</span></span> is an input digits, and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object id="decrementer-schematic.svg" data="decrementer-schematic.svg" type="image/svg+xml" class="diagram">Decrementer Schematic</object>

<p>The circuit is a binary odometer that counts down. When a digit rolls back&mdash;when it transitions from <span class="mono">0</span> to <span class="mono">1</span>&mdash;the digit to its left is decremented. The signal to decrement a digit is referred to as the <span class="term">borrow</span>. The initial <span class="term nowrap">borrow-in</span>Â is <span class="mono">1</span> (far right). Its effect ripples right-to-left. For each half subtractor, if the input digit is <span class="mono">0</span> and the <span class="nowrap">borrow-in</span> is <span class="mono">1</span>, then both the output digit and the <span class="term nowrap">borrow-out</span> are <span class="mono">1</span>. Otherwise, the <span class="nowrap">borrow-out</span> is <span class="mono">0</span> and all digits to its left remain the same.</p>

<p>The image below depicts a Tetris realization of an <span class="nowrap">8-bit</span> decrement function that calculated <span class="nowrap serif">42 &minus; 1</span>. The sequence in which components were built determined the evaluation order. It started with a <span class="nowrap">1-bit</span> constant function in the bottom-right, which supplied the initial <span class="nowrap">borrow-in</span>. From there, digits were evaluated right-to-left and bottom-up. The final <span class="nowrap">borrow-out</span> was discarded.</p>

<object id="decrementer-8.svg" data="decrementer-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Decrementer</object>

<p>The following image shows a Tetris realization of a <span class="nowrap">16-bit</span> decrement function that calculated <span class="nowrap serif">0 &minus; 1</span>. It rolled back to all ones, the <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two's complement</a> representation of &minus;1 or the maximum unsigned integer value.</p>

<object id="decrementer-16.svg" data="decrementer-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Decrementer</object>

<h2 id="increment">Increment</h2>

<p>The increment function adds one to its argument:</p>

<p><span class="math">f(x) = x + </span><span class="serif">1</span></p>

<p>Its circuit consists of chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder" target="_blank">half adders</a>, devices capable of single-digit addition. Each half adder accepts two <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span> and <span class="math">Y</span>, and it outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 = 2</span></td></tr>
</table>

<p>The table reveals <span class="math">C</span> and <span class="math">S</span> are:</p>

<p><span class="math">C = XY = <span class="high-overline"><span class="overline">X</span> + <span class="overline">Y</span></span></span></p>

<p><span class="math">S = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = <span class="overline">X</span>X + <span class="overline">X</span>Y + X<span class="overline">Y</span> + Y<span class="overline">Y</span> = (<span class="overline">X</span> + <span class="overline">Y</span>)(X + Y) = <span class="overline">C</span>(X + Y) = <span class="high-overline">C + <span class="overline">X + Y</span></span></span></p>

<p>That implies the following circuit.</p>

<object id="half-adder-schematic.svg" data="half-adder-schematic.svg" type="image/svg+xml" class="diagram">Half Adder Schematic</object>

<p>In the code below, which is based on that schematic, the <span class="mono">swap</span> (line 14) enables the output of the bottom NOR (line 13) to hop over the input of the <span class="math">Y</span> inverter (line 17). The <span class="math">X</span> inverter (line 16) feeds into the middle NOR (line 18), which, in turn, feeds into the top NOR (line 25).</p>

<pre class="code">
<span class="filename">halfAdder.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-6</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">jl </span><span class="number">2</span></span>
<span class="line"><span class="normal">jr </span><span class="number">2</span></span>
<span class="line"><span class="normal">nor </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">swap </span><span class="number">2 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-7 28</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-3 28</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-5 33</span></span>
<span class="line"><span class="normal">lr </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">3</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-1</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-3 38</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-8</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-3..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">1..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">c </span><span class="number">-8 44</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">s </span><span class="number">-3..0 44</span></span>
</pre>

<p>As revealed in the following image, which shows the responses to all input combinations, the Tetris realization of a half adder is significantly larger than a half subtractor due to the swap circuit.</p>

<object id="half-adder.svg" data="half-adder.svg" type="image/svg+xml" class="diagram">Half Adder</object>

<p>In the full circuit, half adders are chained in the configuration below, where each <span class="math">I<span class="sub">i</span></span> is an input digits, and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object id="incrementor-schematic.svg" data="incrementor-schematic.svg" type="image/svg+xml" class="diagram">Incrementor Schematic</object>

<p>The circuit is a binary odometer that counts up. When a digit rolls over&mdash;when it transitions from <span class="mono">1</span> to <span class="mono">0</span>&mdash;the digit to its left is incremented. The signal to increment a digit is referred to as the <span class="term">carry</span>. The initial <span class="term"><span class="nowrap">carry-in</span></span>Â is <span class="mono">0</span>Â (far right). Its effect ripples right-to-left. For each half adder, if both the input digit and the <span class="nowrap">carry-in</span> is <span class="mono">1</span>, then the output digit is <span class="mono">0</span> and the <span class="term nowrap">carry-out</span> is <span class="mono">1</span>. Otherwise, the <span class="nowrap">carry-out</span> is <span class="mono">0</span> and all digits to its left remain the same.</p>

<p>The image below depicts a Tetris realization of an <span class="nowrap">8-bit</span> increment function that calculated <span class="nowrap serif">42 + 1</span>. A <span class="nowrap">1-bit</span> constant function at the bottom-right supplied the initial <span class="nowrap">carry-in</span>. The final <span class="nowrap">carry-out</span> was discarded.</p>

<object id="incrementor-8.svg" data="incrementor-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Incrementor</object>

<p>The following image shows a Tetris realization of a <span class="nowrap">16-bit</span> increment function. The input is all ones, the two's complement representation of &minus;1 or the maximum unsigned integer value.Â The function rolled over to all zeros, in agreement withÂ <span class="nowrap serif">&minus;1 + 1.</span></p>

<object id="incrementor-16.svg" data="incrementor-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Incrementor</object>

<h2 id="conditional-increment">Conditional Increment</h2>

<p>The conditional increment function operates on a 2-element array, <span class="nowrap"><span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span></span>, where <span class="math">W</span> is a signed or unsigned <span class="nowrap">16-bit</span> integer, and <span class="math">C</span> is a Boolean, a byte restricted to <span class="mono">0</span> and <span class="mono">1</span>:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, C </span><span class="math">]</span></span>, where <span class="nowrap"><span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></span></p>

<p><span class="math">Q</span> is <span class="math">W </span><span class="serif">+ 1</span> if <span class="math">C</span> is <span class="serif">1</span>; otherwise, <span class="math">Q</span> is <span class="math">W</span>. Either way, <span class="math">C</span> passes through, unchanged.</p>

<p>As shown below, its circuit consists of a <span class="nowrap">16-bit</span> incrementer, where the <span class="nowrap">carry-in</span> is <span class="math">C<span class="sub">0</span></span> and the <span class="nowrap">carry-out</span> is discarded.</p>

<object id="conditional-increment-schematic.svg" data="conditional-increment-schematic.svg" type="image/svg+xml" class="diagram">Conditional Increment Schematic</object>

<p>Here is the Tetris version:</p>

<object id="conditional-increment.svg" data="conditional-increment.svg" type="image/svg+xml" class="diagram">Conditional Increment</object>

<h2 id="add">Add</h2>

<p>The add function operates on a 2-byte array. It sets the first byte to the sum of both bytes:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span></span>, where <span class="nowrap"><span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></span></p>

<p><span class="math">Q = A + B</span>, where the plus sign denotes arithmetic add.</p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>Its circuit consists of a chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder" target="_blank">full adders</a>, devices capable of single-digit addition. Each full adder accepts three <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span>, <span class="math">Y</span>, and <span class="math">Z</span>, and it outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="math">Z</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 0 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 1 = 3</span></td></tr>
</table>

<p>Per the table rows where <span class="math">S</span> is <span class="mono">1</span>:</p>

<p><span class="math">S = <span class="overline">X</span> <span class="overline">Y</span> Z + <span class="overline">X</span> Y <span class="overline">Z</span> + X <span class="overline">Y</span> <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math">= <span class="overline">X</span> (<span class="overline">Y</span> Z + Y <span class="overline">Z</span>) + X (<span class="overline">Y</span> <span class="overline">Z</span> + Y Z)</span></p>

<p><span class="math">= <span class="overline">X</span> (Y &oplus; Z) + X <span class="overline">(Y &oplus; Z)</span></span></p>

<p><span class="math">= X &oplus; Y &oplus; Z</span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math"> &oplus; Z</span></span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">(X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math">) &oplus; Z</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">(X &oplus; Y)</span> &oplus; Z</span></span></p>

<p>Per the table rows where <span class="math">C</span> is <span class="mono">1</span>:</p>

<p><span class="math">C = <span class="overline">X</span> Y Z + X <span class="overline">Y</span> Z + X Y <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math"> = Z (<span class="overline">X</span> Y + X <span class="overline">Y</span>) + X Y (<span class="overline">Z</span> + Z)</span></p>

<p><span class="math"> = Z (X <span class="overline">X</span> + <span class="overline">X</span> Y + X <span class="overline">Y</span> + Y <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) (<span class="overline">X</span> + <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) <span class="overline">(X Y)</span> + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y) + (Y X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y + X <span class="overline">X</span> <span class="overline">Y</span>) + (Y X Y + Y <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X (X Y + <span class="overline">X</span> <span class="overline">Y</span>) + Y (X Y + <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X <span class="overline">(X &oplus; Y)</span> + Y <span class="overline">(X &oplus; Y)</span></span></p>

<p><span class="math"> = Z (X + Y) + <span class="overline">(X &oplus; Y)</span> (X + Y)</span></p>

<p><span class="math"> = (X + Y) (Z + <span class="overline">X &oplus; Y</span>)</span></p>

<p>The expressions for <span class="math">S</span> and <span class="math">C</span> are combined:</p>

<p><span class="math">T = <span class="overline">X &oplus; Y</span></span></p>

<p><span class="math">S = <span class="overline">T &oplus; Z</span></span></p>

<p><span class="math">C = (X + Y) (Z + T) = <span class="high-overline"><span class="overline">X + Y</span> + <span class="overline">Z + T</span></span></span></p>

<p>The resultant expressions suggest the following circuit, where the XNORs (the gray rectangles) are composed from four NORs.</p>

<object id="full-adder-schematic.svg" data="full-adder-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic</object>

<p>The Tetris realization is based on a slight modification that forwards input <span class="math">X</span> through and out between <span class="math">C</span> and <span class="math">S</span>. It consists of nine NORs and three crosses, as shown below.</p>

<object id="full-adder-x-schematic.svg" data="full-adder-x-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic, Outputs X</object>

<p>Here are the results for <span class="math">X = </span><span class="mono">0</span> and all possible values of <span class="math">Y</span> and <span class="math">Z</span>:</p>

<object id="full-adder-x-0.svg" data="full-adder-x-0.svg" type="image/svg+xml" class="diagram">Full Adder, X = 0</object>

<p>Here are the results for <span class="math">X = </span><span class="mono">1</span> and all possible values of <span class="math">Y</span> and <span class="math">Z</span>:</p>

<object id="full-adder-x-1.svg" data="full-adder-x-1.svg" type="image/svg+xml" class="diagram">Full Adder, X = 1</object>

<p>The complete circuit consists of full adders chained in the arrangement below. Each full adder accepts a pair of addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, and it outputs their sum digit, <span class="math">Q<span class="sub">i</span></span>, along with one of the input digits, <span class="math">B<span class="sub">i</span></span>, unmodified.</p>

<object id="adder-schematic.svg" data="adder-schematic.svg" type="image/svg+xml" class="diagram">4-bit Adder Schematic</object>

<p>The circuit evaluates right-to-left. For each full adder, if the sum of the <span class="nowrap">carry-in</span>, <span class="math">Z</span>, and the addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, is not a single-digit number, then the high digit, <span class="math">C</span>, is carried out to the full adder on its left. The initial <span class="nowrap">carry-in</span> is <span class="mono">0</span> (far right) and the final <span class="nowrap">carry-out</span> is lost.</p>

<p>Crisscrossing wires are required to interlace the inputs and to disentangle the outputs:</p>

<object id="add-schematic.svg" data="add-schematic.svg" type="image/svg+xml" class="diagram">8-bit Adder Schematic</object>

<p>The Tetris realization retains the triangular patterns from all the cross overs:</p>

<object id="add.svg" data="add.svg" type="image/svg+xml" class="diagram">8-bit Adder</object>

<p>The full adders are stacked diagonally to enable the carries to ripple in the expected order.</p>

<h2 id="subtract">Subtract</h2>

<p>The subtract function operates on a 2-byte array. It sets the first byte to the difference of the first byte and the second byte:</p>

<p><span class="nowrap"><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span></span>, where <span class="nowrap"><span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></span></p>

<p><span class="math">Q = A &minus; B</span></p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>Since <span class="math">A</span>, <span class="math">B</span>, and <span class="math">Q</span> are twoâ€™s complement numbers, the subtraction can be transformed into a sum:</p>

<p><span class="math">A &minus; B = A + -B = A + </span><span class="serif">~</span><span class="math">B + </span><span class="serif">1</span>, where <span class="serif">~</span> means <a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT" target="_blank">bitwise inversion</a>.</p>

<p>Its circuit is a modification of the add circuit:</p>

<object id="subtract-schematic.svg" data="subtract-schematic.svg" type="image/svg+xml" class="diagram">8-bit Subtractor Schematic</object>

<p>The initial <span class="nowrap">carry-in</span> (far right) serves as the <span class="serif">+ 1</span> term of the sum.</p>  

<p><span class="math">B</span> is inverted twice to output it unchanged.</p> 

<p>The Tetris realization follows.</p>

<object id="subtract.svg" data="subtract.svg" type="image/svg+xml" class="diagram">8-bit Subtractor</object>

<h2 id="function-catalog">Function Catalog</h2>

<p>The table below provides the names and definitions of the functions created for the general-purpose computer. The missing byte match functions are covered separately.</p>

<p>Parameters <span class="mono">A</span> and <span class="mono">B</span> are bytes, <span class="mono">W</span> is a <span class="nowrap">16-bit</span> word, and <span class="mono">C</span>, <span class="mono">D</span>, and <span class="mono">E</span> are Booleans (bytes restricted to <span class="mono">0</span> and <span class="mono">1</span>).</p>

<table class="borderless">
  <tr><th class="borderless">Function</th><th class="borderless">Definition</th></tr>
  <tr><td class="pseudocode">CLEAR</td><td class="pseudocode">A<span class="serif"> &#8614; </span>0</td></tr>
  <tr><td class="pseudocode">DEC</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A &minus; 1</td></tr>
  <tr><td class="pseudocode">DEC_16</td><td class="pseudocode">W<span class="serif"> &#8614; </span>W &minus; 1</td></tr>
  <tr><td class="pseudocode">IDENTITY</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A</td></tr>
  <tr><td class="pseudocode">INC</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A + 1</td></tr>
  <tr><td class="pseudocode">INC_16</td><td class="pseudocode">W<span class="serif"> &#8614; </span>W + 1</td></tr>
  <tr><td class="pseudocode">LS2</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 2</td></tr>
  <tr><td class="pseudocode">LS3</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 3</td></tr>
  <tr><td class="pseudocode">LS4</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 4</td></tr>
  <tr><td class="pseudocode">RS1</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A >>> 1</td></tr>
  <tr><td class="pseudocode">RS5</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A >>> 5</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td></tr>
  
  <tr><td class="pseudocode">ADD_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A + B, B ]</td></tr>
  <tr><td class="pseudocode">AND_AB_AF</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A, A & B ]</td></tr>
  <tr><td class="pseudocode">AND_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A & B, B ]</td></tr>
  <tr><td class="pseudocode">AND_NOT_AB_FB</td><td class="pseudocode">[ D, E ]<span class="serif"> &#8614; </span>[ D, D <span class="keyword2">and not</span> E ]</td></tr>
  <tr><td class="pseudocode">COPY_A_B</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A, A ]</td></tr>
  <tr><td class="pseudocode">COPY_B_A</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ B, B ]</td></tr>
  <tr><td class="pseudocode">INC_16_C</td><td class="pseudocode">[ W, C ]<span class="serif"> &#8614; </span>[ C ? W + 1 : W, C ]</td></tr>
  <tr><td class="pseudocode">OR_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A | B, B ]</td></tr>
  <tr><td class="pseudocode">SUB_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A &minus; B, B ]</td></tr>
  <tr><td class="pseudocode">SWAP</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ B, A ]</td></tr>
  <tr><td class="pseudocode">XOR_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A ^ B, B ]</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td></tr>
  
  <tr><td class="pseudocode">AND_A_B_C</td><td class="pseudocode">[ D, E, C ]<span class="serif"> &#8614; </span>[ D, E, D <span class="keyword2">and</span> E ]</td></tr>
  <tr><td class="pseudocode">C_AND_A_NOT_B</td><td class="pseudocode">[ C, D, E ]<span class="serif"> &#8614; </span>[ D <span class="keyword2">and not</span> E, D, E ]</td></tr>
  <tr><td class="pseudocode">CMP_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, B, A = B ]</td></tr>  
  <tr><td class="pseudocode">CMP_AND_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, B, (A = B) <span class="keyword2">and</span> C ]</td></tr>
  <tr><td class="pseudocode">C_CMP</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ A = B, A, B ]</td></tr>
  <tr><td class="pseudocode">COPY_A_B_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, C ? A : B, C ]</td></tr>
  <tr><td class="pseudocode">COPY_B_A_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ C ? B : A, B, C ]</td></tr>  
  <tr><td class="pseudocode">C_COPY_B_A</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ C, C ? B : A, B ]</td></tr>
  <tr><td class="pseudocode">C_COPY_A_B</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ C, A, C ? A : B ]</td></tr>
</table>

<p>A byte match functions accept a byte, <span class="mono">A</span>, and a Boolean, <span class="mono">C</span>. It returns <span class="mono">A</span>, unchanged, along with a Boolean indicating if <span class="mono">A</span> matches a specific bit pattern. The function names declare the parameter orders:</p>

<table class="matchers">
  <tr><td style="text-align: right; padding-right: 15px;">Ends with <span class="mono">_C</span>:</td><td><span class="nowrap"><span class="mono">[ A, C ]<span class="serif"> &#8614; </span>[ A, isMatch(A) ]</span></span></td></tr>
  <tr><td style="text-align: left; padding-right: 15px;">Starts with <span class="mono">C_</span>:</td><td><span class="nowrap"><span class="mono">[ C, A ]<span class="serif"> &#8614; </span>[ isMatch(A), A ]</span></span></td></tr>
</table>

<p>The following table details the byte match functions. Those with bit patterns containing <a href="https://en.wikipedia.org/wiki/Don%27t-care_term" target="_blank">donâ€™t-care</a> are capable of matching multiple values, as shown in the right column.</p>

<table class="borderless">
  <tr><th class="borderless">Function</th><th class="borderless">Pattern</th><th class="borderless">Values</th></tr>
  <tr><td class="pseudocode">ADD_C</td><td class="pseudocode">00010000</td><td class="pseudocode">10</td></tr> 
  <tr><td class="pseudocode">AND_C</td><td class="pseudocode">00010001</td><td class="pseudocode">11</td></tr>
  <tr><td class="pseudocode">BEQ_C</td><td class="pseudocode">00100011</td><td class="pseudocode">23</td></tr> 
  <tr><td class="pseudocode">BMI_C</td><td class="pseudocode">00100101</td><td class="pseudocode">25</td></tr> 
  <tr><td class="pseudocode">BNE_C</td><td class="pseudocode">00100010</td><td class="pseudocode">22</td></tr>
  <tr><td class="pseudocode">BPL_C</td><td class="pseudocode">00100100</td><td class="pseudocode">24</td></tr>   
  <tr><td class="pseudocode">DEC_C</td><td class="pseudocode">00010010</td><td class="pseudocode">12</td></tr> 
  <tr><td class="pseudocode">INC_C</td><td class="pseudocode">00010011</td><td class="pseudocode">13</td></tr> 
  <tr><td class="pseudocode">JMP_C</td><td class="pseudocode">00100000</td><td class="pseudocode">20</td></tr> 
  <tr><td class="pseudocode">JSR_C</td><td class="pseudocode">00101000</td><td class="pseudocode">28</td></tr> 
  <tr><td class="pseudocode">LDB_C</td><td class="pseudocode">01000001</td><td class="pseudocode">41</td></tr>  
  <tr><td class="pseudocode">LS2_C</td><td class="pseudocode">00010100</td><td class="pseudocode">14</td></tr> 
  <tr><td class="pseudocode">LS3_C</td><td class="pseudocode">00010101</td><td class="pseudocode">15</td></tr> 
  <tr><td class="pseudocode">LS4_C</td><td class="pseudocode">00010110</td><td class="pseudocode">16</td></tr> 
  <tr><td class="pseudocode">OR_C</td><td class="pseudocode">00010111</td><td class="pseudocode">17</td></tr>  
  <tr><td class="pseudocode">RS1_C</td><td class="pseudocode">00011000</td><td class="pseudocode">18</td></tr> 
  <tr><td class="pseudocode">RS5_C</td><td class="pseudocode">00011001</td><td class="pseudocode">19</td></tr> 
  <tr><td class="pseudocode">RTS_C</td><td class="pseudocode">01110000</td><td class="pseudocode">70</td></tr> 
  <tr><td class="pseudocode">SEA_C</td><td class="pseudocode">01010000</td><td class="pseudocode">50</td></tr> 
  <tr><td class="pseudocode">SEB_C</td><td class="pseudocode">01010001</td><td class="pseudocode">51</td></tr>
  <tr><td class="pseudocode">SMN_C</td><td class="pseudocode">00101111</td><td class="pseudocode">2F</td></tr>
  <tr><td class="pseudocode">STA_C</td><td class="pseudocode">00110000</td><td class="pseudocode">30</td></tr> 
  <tr><td class="pseudocode">STB_C</td><td class="pseudocode">00110001</td><td class="pseudocode">31</td></tr> 
  <tr><td class="pseudocode">SUB_C</td><td class="pseudocode">00011010</td><td class="pseudocode">1A</td></tr> 
  <tr><td class="pseudocode">XOR_C</td><td class="pseudocode">00011011</td><td class="pseudocode">1B</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  

  <tr><td class="pseudocode">TAX_C</td><td class="pseudocode">000000**</td><td class="pseudocode">00, 01, 02, 03</td></tr>   
  <tr><td class="pseudocode">TBX_C</td><td class="pseudocode">000001**</td><td class="pseudocode">04, 05, 06, 07</td></tr> 
  <tr><td class="pseudocode">TMX_C</td><td class="pseudocode">000010**</td><td class="pseudocode">08, 09, 0A, 0B</td></tr>
  <tr><td class="pseudocode">TNX_C</td><td class="pseudocode">000011**</td><td class="pseudocode">0C, 0D, 0E, 0F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  
  
  <tr><td class="pseudocode">TXA_C</td><td class="pseudocode">0000**00</td><td class="pseudocode">00, 04, 08, 0C</td></tr>   
  <tr><td class="pseudocode">TXB_C</td><td class="pseudocode">0000**01</td><td class="pseudocode">01, 05, 09, 0D</td></tr> 
  <tr><td class="pseudocode">TXM_C</td><td class="pseudocode">0000**10</td><td class="pseudocode">02, 06, 0A, 0E</td></tr>
  <tr><td class="pseudocode">TXN_C</td><td class="pseudocode">0000**11</td><td class="pseudocode">03, 07, 0B, 0F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">LDX_C</td><td class="pseudocode">0100000*</td><td class="pseudocode">40, 41</td></tr>  
  <tr><td class="pseudocode">STX_C</td><td class="pseudocode">0011000*</td><td class="pseudocode">30, 31</td></tr>   
  <tr><td class="pseudocode">SEX_C</td><td class="pseudocode">0101000*</td><td class="pseudocode">50, 51</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">THREE_C</td><td class="pseudocode">0010****</td><td class="pseudocode">20..2F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">MINUS_C</td><td class="pseudocode">1*******</td><td class="pseudocode">80..FF</td></tr>
  <tr><td class="pseudocode">C_MINUS</td><td class="pseudocode">1*******</td><td class="pseudocode">80..FF</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  
  
  <tr><td class="pseudocode">ZERO_C</td><td class="pseudocode">00000000</td><td class="pseudocode">00</td></tr>
  <tr><td class="pseudocode">C_ZERO</td><td class="pseudocode">00000000</td><td class="pseudocode">00</td></tr>
</table>

<p>As their names suggest, the byte match functions primarily detect machine language <a href="https://en.wikipedia.org/wiki/Opcode" target="_blank">opcodes</a> or sets of opcodes. The most generic of them, <span class="mono">THREE_C</span>, matches the opcodes for all <span class="nowrap">3-byte</span> instructions.</p> 

<p><span class="mono">MINUS_C</span> and <span class="mono">C_MINUS</span> recognize negative numbers, those with <span class="nowrap">bit-7</span> set per <span class="nowrap">twoâ€™s complement</span>.</p>

<p><span class="mono">ZERO_C</span> and <span class="mono">C_ZERO</span> are <span class="nowrap">zero detectors</span>. </p>

<h1 id="memory">Memory</h1>

<p>This section discusses random-access memory (RAM), an information storage device that supports reads and writes in any order.</p>

<h2 id="memory-implementation">Implementation</h2>

<p>Memory consists of a rectangular pile with large, yet finite, dimensions. It stores an ordered list of bytes in a sequence of nodes in its <span class="nowrap">top-two</span> rows. The nodes are evenly-spaced, ten columns apart, starting from <span class="nowrap">column 0</span>.</p>

<p>To perform a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write" target="_blank">read-modify-write</a> operation, the agent builds a function on top of the bytes to be changed. The functionâ€™s output&mdash;a row of 8, 16, or 24 evenly-spaced nodes&mdash;is the initial segment of a new surface of a taller pile. The agent raises the remaining surface flush with the functionâ€™s output by constructing identity functions over all the remaining bytes. The new surface contains the same data as the original surface, except for the bytes targeted by the operation.</p> 

<p>To make this clear, the following visualization depicts the layers of a rectangular pile resulting from a read-modify-write operation. The bottom layer shows the initial memory state: five bytes, all zeros. The agent built an <span class="nowrap">8-bit</span> increment function, <span class="mono">INC</span>, above <span class="nowrap">byte <span class="mono">2</span></span>. <span class="mono">INC</span>'s output created the first segment of the top layer (the yellow cell). Then the agent built identify functions over the remaining bytes (the <span class="nowrap">up-arrows</span>). The outputs of those functions formed the rest of top layer. The final memory state consists of five bytes, all zeros, except for <span class="nowrap">byte <span class="mono">2</span></span>, which was incremented.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">1</td><td class="top mono bottom green">00</td><td class="top left bottom mono green">00</td><td class="top left bottom mono yellow">01</td><td class="top left bottom mono green">00</td><td class="top left right bottom mono green">00</td></tr>
<tr><td class="row-number"></td><td class="bottom blue">&#129093;</td><td class="left bottom blue">&#129093;</td><td class="left bottom mono blue">INC</td><td class="left bottom blue">&#129093;</td><td class="left right bottom blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono bottom green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left right bottom mono green">00</td></tr>

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table> 

<p>In the more elaborate example below, the agent assigned <span class="nowap">byte <span class="mono">0</span></span> the sum of bytes <span class="mono">1</span>, <span class="mono">2</span>, <span class="mono">3</span>, and <span class="mono">4</span>, via a sequence of read-modify-write operations.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top yellow">0A</td><td class="left bottom top mono yellow">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left right bottom top mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono yellow">0A</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono yellow">06</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">06</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom yellow">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table>

<p>Here is an explanation each operation:</p>

<ol>
  <li><span class="mono">COPY_B_A</span> copied byte <span class="mono">1</span> to byte <span class="mono">0</span>.</li>
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">1</span> and <span class="mono">2</span> into <span class="nowrap">byte <span class="mono">1</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">1</span> and <span class="mono">2</span>.</li> 
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">2</span> and <span class="mono">3</span> into <span class="nowrap">byte <span class="mono">2</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">2</span> and <span class="mono">3</span>.</li> 
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">3</span> and <span class="mono">4</span> into <span class="nowrap">byte <span class="mono">3</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">2</span> and <span class="mono">3</span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">1</span> and <span class="mono">2</span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">0</span> and <span class="mono">1</span>.</li> 
</ol>  

<p>The <span class="mono">SWAP</span> function provides a way to move values around in memory. Above, the agent used it bring values together for the add function. And it finished with three consecutive <span class="mono">SWAP</span>s to shuttle the computed sum from <span class="nowrap">byte <span class="mono">3</span></span> to <span class="nowrap">byte <span class="mono">0</span></span>.</p>

<p>Memory capacity is always finite, but the agent can expand it endlessly. To allocate a byte, the agent drops eight horizontal <span class="nowrap">I-tetrominoes</span> onto the playfield floor, evenly-spaced, ten columns apart, immediately to the right of the pile. That introduces eight new <span class="nowrap"><span class="mono">0</span>-nodes</span>:</p>

<object id="zeros.svg" data="zeros.svg" type="image/svg+xml" class="diagram">Zeros</object>

<p>Then the agent repeatedly builds identity functions above the new nodes until the output of one of them reaches the height of the rest of the pile.</p>

<p>The process is portrayed in the following example. It shows a newly allocated byte appended to the sum pile.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top green">0A</td><td class="left bottom top mono green">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left bottom top mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">06</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">06</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono green">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom green">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td><td class="left right mono yellow">00</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td><td class="column-number">5</td></tr>  
</table>

<p>The agent never deallocates memory. The pile's width either remains constant or it increases.</p>

<p>The agent loads the initial memory state byÂ dropping a sequence of horizontal <span class="nowrap">I-tetrominoes</span> (<span class="nowrap"><span class="mono">0</span>-nodes</span>) and <span class="nowrap">O-tetrominoes</span> (<span class="nowrap"><span class="mono">1</span>-nodes</span>) onto the playfield floor, evenly-spaced, ten columns apart, starting from <span class="nowrap">column 0</span>. For instance, here is a single byte, the value 42:</p>

<object id="forty-two.svg" data="forty-two.svg" type="image/svg+xml" class="diagram">42</object>

<p>Since the agent clears newly allocated bytes, all memory locations after the final byte of the initial state effectively contain zero.</p>

<h2 id="memory-code">Memory Code</h2>

<p><span class="nowrap"><span class="term">Memory Code</span> (MC)</span> is a language that provides a concise way to manipulate memory. It compiles to TS, and ultimately <span class="nowrap">to IL</span>.</p> 

<p>MC has of two instruction types. The first directs the agent to perform a read-modify-write operation. It consists of the modify functionâ€™s name, <span class="mono">f</span>, and the memory address where to apply it, <span class="mono">x</span>: 

<p class="definition">f x</p> 

<p>It commands the agent to:</p>

<ol>
  <li>Build <span class="mono">f</span> on the surface of the pile, starting at byte <span class="mono">x</span>, and covering either one, two, or three bytes per <span class="mono">f</span>'s byte width.</li> 
  <li>Repeatedly build identity functions on the surface of the pile, covering all remaining bytes.</li>
</ol>

<p>The following <span class="nowrap">MC program</span> demonstrate this instruction type. It performs the sum from the previous section.</p>

<pre class="code">
<span class="filename">sum.mc</span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">0</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">3</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">0</span></span>
</pre>

<p>The second instruction type directs the agent to execute a previously defined <span class="nowrap">MC program</span>, <span class="mono">p</span>, relative to a specified memory address, <span class="mono">x</span>: 

<p class="definition">p x</p>

<p>The <span class="nowrap">MC compiler</span> replaces the instruction with <span class="mono">p</span>'s contents, such that the memory address arguments of <span class="mono">p</span>'s instruction are incremented by <span class="mono">x</span>. The compiler recursively repeats that process until all what remains are instructions of the first type. To ensure the process finishes, the compiler does not permit <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank">circular dependencies</a>.</p>

<p>The code below references the last example to illustrate this instruction type.</p>

<pre class="code">
<span class="filename">sum5.mc</span>
<span class="line"><span class="normal">sum </span><span class="number">5</span></span>
</pre>

<p>The compiler expands the single instruction, offsetting the memory locations per the provided address:</p>

<pre class="code">
<span class="filename">sum5Expanded.mc</span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">5</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">6</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">7</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">8</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5</span></span>
</pre>

<p>The expanded version reveals <span class="mono">sum5</span> totals bytes <span class="mono">6</span>, <span class="mono">7</span>, <span class="mono">8</span>, and <span class="mono">9</span>, and it puts the result into <span class="nowrap">byte <span class="mono">5</span></span>. In other words, it executes <span class="mono">sum</span> relative to <span class="nowrap">byte <span class="mono">5</span></span>.</p>

<p>MC does not provide instructions for initializing memory. Rather, an <span class="nowrap">MC program</span> operates on existing memory, a rectangular pile originating from a <span class="nowrap">TS program</span> and potentially manipulated by other <span class="nowrap">MC programs</span>. That being the case, the compiler requires the existing pileâ€™s dimensions. The pileâ€™s height provides the original surface <span class="nowrap">row index</span>. Then, for each <span class="nowrap">MC instruction</span>, the compiler increments the surface <span class="nowrap">row index</span> by the height of the instructionâ€™s function, and it uses the functionâ€™s <span class="nowrap">byte width</span> along with the pileâ€™s width to figure out how many identity functions to build and where to build them.</p>

<p>The compiler knows the function <span class="nowrap">byte widths</span> because, at startup, it counts the number of <span class="mono keyword2">in</span> directives in each <span class="nowrap">TS program</span>. And it knows the function heights because it builds an instance of each function on a finite, private playfield, using zeros for input.</p>

<p>For the identity functions, the compiler outputs a sequence of <span class="nowrap">TS instructions</span> that direct the agent to build columns above the pileâ€™s surface nodes, primarily from vertical <span class="nowrap">I-tetrominoes</span>, where the heights of the columns equal the height of the <span class="nowrap">MC instructionâ€™s</span> function.</p>

<p>If the compiler encounters aÂ <span class="nowrap">MC instruction</span> that references a memory address beyond the pileâ€™s width, then itÂ expands the pile up to that address before it translates the instruction to TS. As explained in the last section, toÂ allocate and initialize bytes, the compilerÂ appends <span class="nowrap"><span class="mono">0</span>-nodes</span> in the form of horizontal <span class="nowrap">I-tetrominoes</span>, and itÂ pads the nodes in the same way that it synthesizes the identity functions.</p>

<p>The agent can execute the <span class="nowrap">TS program</span> generated by the <span class="nowrap">MC compiler</span> on any rectangular pile matching the dimensions provided at compilation time.</p>

<h2 id="infinite-array-abstraction">Infinite Array Abstraction</h2>

<p>Memory works like an infinitely long, one-dimensional, byte array, <span class="mono">a</span>, initialized as:</p>
  
<p><span class="nowrap"><span class="mono">a<span class="sub3">i&isin;[0,L-1]</span> &larr; </span><span class="mono">i<span class="sup2">th</span></span> byte of an <span class="nowrap"><span class="mono">L</span>-byte</span> initial memory state</p>

<p><span class="nowrap"><span class="mono">a<span class="sub3">i&isin;[L,&infin;)</span> &larr; 0</span></span></p>

<p>Each MC instruction, <span class="mono nowrap">f x</span>, where <span class="mono">f</span> is an <span class="nowrap"><span class="mono">n</span>-byte</span> function, modifies <span class="mono">n</span> consecutive bytes, starting at <span class="nowrap">index <span class="mono">x</span></span>:</p>

<p><span class="nowrap"><span class="mono">a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; f(a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span>)</span></span></p>

<p>The computing machines of the next section employ this abstraction to satisfy their data storage needs. The text describes the array as if it oriented horizontally, starting with <span class="nowrap">index 0</span> at the &ldquo;left&rdquo; end, and heading &ldquo;rightward&rdquo; toward infinity.</p>

<h1 id="abstract-machines">Abstract Machines</h1>

<p>This section explores several models of computation.</p>

<h2 id="function-emulator">Function Emulator</h2>

<p>For all <span class="nowrap"><span class="mono">n</span>-byte</span> functions <span class="mono">f</span>, there exists an <span class="nowrap">MC program</span>, <span class="mono">E</span>, that emulates <span class="mono">f</span>. This is because, regardless of how <span class="mono">f</span> is mathematically defined, it can be replaced with a lookup table, a finite&mdash;though potentially large&mdash;map from <span class="nowrap"><span class="mono">n</span>-byte</span> keys to <span class="nowrap"><span class="mono">n</span>-byte</span> values. As such, <span class="mono">E</span> simply needs to mimic the following pseudocode, when executed at index <span class="mono">x</span>.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  <span class="keyword2">if</span> a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span></span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span></span>
<span class="line">    <span class="keyword2">break</span></span>
</pre>

<p><span class="mono">a</span> is the infinite array abstraction from the previous section. <span class="mono">a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span> is the segment of the array the function operates on.</p>

<p>The code iterates over the <span class="nowrap">key-value</span> pairs of the map. For each pair, if the array segment equal the key, then it overwrites the segment with the value, and it breaks out of the loop to prevent the assigned value from matching the key of a successive entry. If it reaches the end of the loop without finding a match, it leaves the array unchanged.</p> 

<p>Unfortunately, MC does not support loops, nor conditional branches (<span class="mono">if</span> statements), nor unconditional branches (such as the <span class="mono">break</span> statement). But the loop can be <a href="https://en.wikipedia.org/wiki/Loop_unrolling" target="_blank">unrolled</a> (at the expense of lengthy code) and the branches can be simulated with the assistance of temporary variables appended to the end of the array segment:</p>  

<p><span class="nowrap mono">p &equiv; a<span class="sub3">x+n</span></span></p>

<p><span class="nowrap mono">q &equiv; a<span class="sub3">x+n+1</span></span></p>

<p><span class="nowrap mono">r &equiv; a<span class="sub3">x+n+2</span></span></p>

<p>The initial values of those elements do not matter. But they must be reserved since <span class="mono">E</span> overwrites them.</p>

<p>The code is transformed through the following steps. First, the <span class="mono">break</span> statement is replaced with <span class="mono">r</span> acting as a flag:</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  <span class="keyword2">if</span> (a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span>) <span class="keyword2">and not</span> r</span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span></span>
<span class="line">    r &larr; 1</span>
</pre>

<p>The loop no longer exits early, but <span class="mono">r</span> ensures the assignment happens at most once.</p>

<p>Next, the <span class="mono">if</span> statement is converted to a <a href="https://en.wikipedia.org/wiki/Ternary_operation" target="_blank">ternary operation</a>, where the condition is stored in <span class="mono">q</span>:</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; (a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span>) <span class="keyword2">and not</span> r</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>Each iteration overwrites the array segment with itself, except when a key matches for the first time.</p>

<p><span class="nowrap">Line 3</span> is expanded into <span class="nowrap">lines 3&ndash;6</span> below.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; a<span class="sub3">x+i</span> = k<span class="sub3">i</span></span>
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>When the inner loop on <span class="nowrap">line 4</span> is unrolled, every compare-with-constant, <span class="mono">p &larr; a<span class="sub3">x+i</span> = k<span class="sub3">i</span></span>, is replaced with a byte matcher:</p>

<p><span class="mono">MATCH_k<span class="sub3">i</span>_C &equiv; [ A, C ] &#8614; [ A, A = k<span class="sub3">i</span> ]</span></p>

<p><span class="mono">A</span> is the array element compared with <span class="mono">k<span class="sub3">i</span></span>. It passes through unchanged. <span class="mono">C</span> is the array element that stores the result of the comparison, which in this case is <span class="mono">p</span>.</p>

<p>To make this work, 256 implementations of that byte matcher need to be added to the function catalog, one for every possible value of <span class="mono">k<span class="sub3">i</span></span>. However, the byte matchers operate on a pair of adjacent elements. So, the following version of the code repeatedly swaps the value in <span class="mono">a<span class="sub3">x+i</span></span> rightward along the array, until it reaches <span class="mono">a<span class="sub3">x+n&minus;1</span></span>, the element immediately left of <span class="mono">p</span>. Once there, the code performs the comparison. Then it does the swaps in reverse order to restore the moved value back to its original location.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p><span class="nowrap">Line 11</span> is expanded into <span class="nowrap">lines 11&ndash;13</span> below.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; v<span class="sub3">i</span>
<span class="line">    a<span class="sub3">x+i</span> &larr; q ? p : a<span class="sub3">x+i</span></span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>When the inner loop on <span class="nowrap">line 11</span> is unrolled, every assign-to-constant, <span class="mono">p &larr; v<span class="sub3">i</span></span>, is replaced with a constant function:</p>

<p><span class="mono">CONST_v<span class="sub3">i</span> &equiv; A &#8614; v<span class="sub3">i</span></span></p>

<p><span class="mono">A</span> is the array element assigned <span class="mono">v<span class="sub3">i</span></span>, which in this case is <span class="mono">p</span>.</p>

<p>As with the byte matchers, 256 implementations need to be added to the function catalog, one for every possible value of <span class="mono">v<span class="sub3">i</span></span>.</p>

<p>Additionally, every conditional-assignment, <span class="mono">a<span class="sub3">x+i</span> &larr; q ? p : a<span class="sub3">x+i</span></span>, is replaced with a conditional byte copy function:</p>

<p><span class="mono">COPY_B_A_C &equiv; [ A, B, C ] &#8614; [ C ? B : A, B, C ]</span>.</p>

<p><span class="mono">A</span> is the destination element. When the condition is false, it is also the source element. <span class="mono">B</span> is the source element when the condition is true. And <span class="mono">C</span> is the condition element.</p>

<p><span class="mono">B</span> and <span class="mono">C</span> pass through, unchanged. They are <span class="mono">p</span> and <span class="mono">q</span>, respectively.</p>

<p><span class="mono">COPY_B_A_C</span> already exists in the function catalog. However, it operates on a triplet of consecutive elements. So, the following version duplicates the strategy used for the byte matchers. It moves the value in <span class="mono">a<span class="sub3">x+i</span></span> into <span class="mono">a<span class="sub3">x+n&minus;1</span></span> via repeated swaps. There, it performs the copy. Then it restores the moved value back to its original location.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; v<span class="sub3">i</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n&minus;1</span> &larr; q ? p : a<span class="sub3">x+n&minus;1</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>Next, the placeholders, <span class="mono">p</span>, <span class="mono">q</span>, and <span class="mono">r</span>, are filled in with their corresponding array elements, <span class="mono">a<span class="sub3">x+n</span></span>, <span class="mono">a<span class="sub3">x+n+1</span></span>, and <span class="mono">a<span class="sub3">x+n+2</span></span>, respectively:</p>

<pre class="pseudocode2">
<span class="line">a<span class="sub3">x+n+2</span> &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  a<span class="sub3">x+n+1</span> &larr; <span class="keyword2">not</span> a<span class="sub3">x+n+2</span></span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n</span> &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n+1</span> &larr; a<span class="sub3">x+n+1</span> <span class="keyword2">and</span> a<span class="sub3">x+n</span></span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    a<span class="sub3">x+n</span> &larr; v<span class="sub3">i</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n&minus;1</span> &larr; a<span class="sub3">x+n+1</span> ? a<span class="sub3">x+n</span> : a<span class="sub3">x+n&minus;1</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">  a<span class="sub3">x+n+2</span> &larr; a<span class="sub3">x+n+2</span> <span class="keyword2">or</span> a<span class="sub3">x+n+1</span></span>
</pre>

<p>Then all references to the array are replaced with MC instructions:</p>

<pre class="pseudocode2">
<span class="line">CLEAR n+2</span>
<span class="line"><span class="keyword2">for each</span> (k,v) <span class="keyword2">in</span> m</span>
<span class="line">  COPY_NOT_B_A n+1</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      SWAP j</span>    
<span class="line">    MATCH_k<span class="sub3">i</span>_C n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      SWAP j</span>
<span class="line">    AND_AB_AF n</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    CONST_v<span class="sub3">i</span> n
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      SWAP j</span>
<span class="line">    COPY_B_A_C n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">down to</span> i</span>
<span class="line">      SWAP j</span>
<span class="line">  OR_AB_AF n+1</span>
</pre>

<p>The code needs two variations of existing functions:</p>

<p><span class="mono">COPY_NOT_B_A &equiv; [ D, E ] &#8614; [ <span class="keyword2">not</span> E, E ]</span></p>

<p><span class="mono">OR_AB_AF &equiv; [ A, B ] &#8614; [ A, A | B ]</span></p>

<p>The final step is to unroll the loops. As that happens, the <span class="mono">(k,v)</span> pairs get encoded into sequences of <span class="mono">MATCH_k<span class="sub3">i</span>_C</span> and <span class="mono">CONST_v<span class="sub3">i</span></span> instructions. However, since <span class="mono">m</span> contains up to <span class="mono">256<span class="sup3">n</span></span> entries, the unroll may produce an extremely long program.</p>

<p>Clearly, this technique is not practical or efficient. Nonetheless, it demonstrates an <span class="nowrap">MC program</span> can emulate an arbitrary <span class="nowrap"><span class="mono">n</span>-byte</span> function, at least in principle.</p>

<h2 id="state-machine">State Machine</h2>

<p>This section discusses deterministic <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">finite-state machines</a>, abstract devices that change state based on a map from the currentÂ state and optionally a character of an input string to a successive state and optionally a character of an output string.</p>

<h3 id="sequencer">Sequencer</h3>

<p>The simplest <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">state machine</a> is a <a href="https://en.wikipedia.org/wiki/Finite-state_machine#Sequencers" target="_blank">sequencer</a>, a device that generates the next element of a sequence when prompted. A classic example is a traffic light, a sequencer prompted by a timer. Another example is a <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" target="_blank">linear-feedback shift register</a>, such as the one that serves as the <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" target="_blank">pseudorandom number generator</a> in a Tetris implementation described in a <a href="#example-program">subsequent section</a>. It is a sequencer prompted when a piece spawns.</p>

<p>The <a href="#infinite-array-abstraction">infinite array abstract</a> permits a straightforward implementation of a sequencer. The first <span class="nowrap"><span class="mono">N</span> bytes</span> of the array, <span class="mono nowrap">a<span class="sub3">0</span>&nldr;a<span class="sub3">N&minus;1</span></span>, serve as an <span class="nowrap"><span class="mono">N</span>-byte</span> register, where a subset or all those bytes store the most recently generated element of the sequence. A process initializes the register to a starting value. When the process wants the next element of the sequence, it runs an <span class="nowrap">MC program</span> equivalent to the single line of pseudocode below.</p>

<pre class="pseudocode2">
<span class="line">a<span class="sub3">0</span>&nldr;a<span class="sub3">N&minus;1</span> &larr; T<span class="sub3">s</span>(a<span class="sub3">0</span>&nldr;a<span class="sub3">N&minus;1</span>)</span>
</pre>

<p>The program passes the register value into a <span class="term">transition function</span>, <span class="mono">T<span class="sub3">s</span></span>, and it puts the result back into the register.</p>

<p>Since the register is limited to a finite number of values, the generated sequence eventually becomes cyclic.</p>

<h3 id="classifier">Classifier</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Finite-state_machine#Classifiers" target="_blank">classifier</a> is a device that categorizes an input string. If there are only two categories, then the device is referred to as an <span class="term"><a href="https://en.wikipedia.org/wiki/Finite-state_machine#Acceptors" target="_blank">acceptor</a></span>. For instance, a <a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank">regular expression</a> matcher determines if an input string is consistent with a specific pattern or not.</p>

<p>The following approach for implementing a classifier embeds an input string, <span class="mono">s</span>, consisting of <span class="mono">L</span> single-byte characters, into an <span class="nowrap">MC program</span>. As with the sequencer, the first <span class="nowrap"><span class="mono">N</span> bytes</span> of the array, <span class="mono nowrap">a<span class="sub3">0</span>&nldr;a<span class="sub3">N&minus;1</span></span>, serve as an <span class="nowrap"><span class="mono">N</span>-byte</span> register, and a process initializes it to a starting value. At runtime, the program iterates over the input string. During each pass, it assigns the element immediately right of the register, <span class="mono">a<span class="sub3">N</span></span>, to the <span class="mono">i<span class="sup2">th</span></span> character of the input string, <span class="mono">s<span class="sub3">i</span></span>, and it applies a transition function, <span class="mono">T<span class="sub3">c</span></span>, to the segment of the array containing both the register and the character:</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> L&minus;1</span>
<span class="line">  a<span class="sub3">N</span> &larr; s<span class="sub3">i</span></span>
<span class="line">  a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span> &larr; T<span class="sub3">c</span>(a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span>)</span>
</pre>

<p><span class="mono">T<span class="sub3">c</span></span> only modifies the register. It passes the character through, unchanged.</p>

<p>At completion, the process reads the computed category, which is stored in a subset or all bytes of the register.</p>

<p>Unfortunately, since the string is hard-coded, this approach requires a separate <span class="nowrap">MC program</span> per input. Alternatively, and preferably, a process loads the input string into the elements right of the register:</p> 

<p><span class="nowrap mono">a<span class="sub3">N+i</span> &larr; s<span class="sub3">i&isin;[0,L-1]</span></span></p>

<p>Once there, a reusable classifier program categorizes it.</p>

<p>There are two basic strategies for a reusable program. The first moves the characters to the register:</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> L&minus;1</span>
<span class="line">  <span class="keyword2">for</span> j &larr; i <span class="keyword2">down to</span> 1</span>
<span class="line">    [a<span class="sub3">N+j&minus;1</span>,a<span class="sub3">N+j</span>] &larr; [a<span class="sub3">N+j</span>,a<span class="sub3">N+j&minus;1</span>]</span>
<span class="line">  a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span> &larr; T<span class="sub3">c</span>(a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span>)</span>
</pre>  

<p>Lines 2&ndash;3 repeatedly swap the <span class="mono">i<span class="sup2">th</span></span> character of the string, from <span class="nowrap">index <span class="mono">N+i</span></span>, leftward along the array, until it reaches <span class="nowrap">index <span class="mono">N</span></span>, the element immediately right of the register. The program performs:</p>

<p><span class="nowrap mono">0 + 1 + &mldr; + L&minus;1 = L(L&minus;1)/2</span> swaps</p>

<p>In doing so, it reverses the input string, as shown in the animation below, which depicts a classifier with a <span class="nowrap">3-byte</span> register.</p>

<object id="classifier-data-to-reg.svg" data="classifier-data-to-reg.svg" type="image/svg+xml" class="diagram">Classifier Animation: Move Data to Register</object>

<p>To maintain the order, the following versionÂ swaps each character back to its original location after applying the transition function.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> L&minus;1</span>
<span class="line">  <span class="keyword2">for</span> j &larr; i <span class="keyword2">down to</span> 1</span>
<span class="line">    [a<span class="sub3">N+j&minus;1</span>,a<span class="sub3">N+j</span>] &larr; [a<span class="sub3">N+j</span>,a<span class="sub3">N+j&minus;1</span>]</span>
<span class="line">  a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span> &larr; T<span class="sub3">c</span>(a<span class="sub3">0</span>&nldr;a<span class="sub3">N</span>)</span>
<span class="line">  <span class="keyword2">for</span> j &larr; 1 <span class="keyword2">to</span> i</span>
<span class="line">    [a<span class="sub3">N+j&minus;1</span>,a<span class="sub3">N+j</span>] &larr; [a<span class="sub3">N+j</span>,a<span class="sub3">N+j&minus;1</span>]</span>
</pre> 

<p>It performs <span class="nowrap mono">L(L&minus;1)</span> swaps:</p>

<object id="classifier-data-to-reg-and-back.svg" data="classifier-data-to-reg-and-back.svg" type="image/svg+xml" class="diagram">Classifier Animation: Move Data to Register and Back</object>

<p>The second strategy moves the register to the characters:</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> L&minus;1</span>
<span class="line">  a<span class="sub3">i</span>&nldr;a<span class="sub3">N+i</span> &larr; T<span class="sub3">c</span>(a<span class="sub3">i</span>&nldr;a<span class="sub3">N+i</span>)</span>
<span class="line">  <span class="keyword2">for</span> j &larr; N&minus;1 <span class="keyword2">down to</span> 0</span>
<span class="line">    [a<span class="sub3">i+j+1</span>,a<span class="sub3">i+j</span>] &larr; [a<span class="sub3">i+j</span>,a<span class="sub3">i+j+1</span>]</span>
</pre>

<p><span class="nowrap">Line 2</span> applies the transition function at <span class="nowrap">index <span class="mono">i</span></span>, rather than <span class="nowrap">index <span class="mono">0</span></span>. <span class="nowrap">Lines 3&ndash;4</span> move the register right, from <span class="nowrap">index <span class="mono">i</span></span> to <span class="nowrap">index <span class="mono">i+1</span></span>, by repeatedly swapping the <span class="mono">i<span class="sup2">th</span></span> character of the string leftward, through the register.</p>

<p>It takes <span class="mono">LN</span> swaps. For strings significantly larger than the width of the register, the second strategy has order <span class="mono nowrap">&Oscr;(L)</span>, far more efficient than the first strategy, which has order <span class="mono nowrap">&Oscr;(L<span class="sup3">2</span>)</span>. The animation below demonstrates the improved performance.</p>

<object id="classifier-reg-to-data.svg" data="classifier-reg-to-data.svg" type="image/svg+xml" class="diagram">Classifier Animation: Register to Data</object>

<p>Regarding reusability, the program contains the number of cycles required to run the classifier to completion. In other words, while the string is no longer hard-coded, the string length is. However, if <span class="mono">T<span class="sub3">c</span></span> ignores zeros&mdash;all characters right of the input string&mdash;then the program is applicable to strings with length &le; <span class="mono">L</span>.</p>

<h3 id="transducer">Transducer</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Finite-state_transducer" target="_blank">transducer</a> is a device that translates an input string into an output string. One example is a <a href="https://en.wikipedia.org/wiki/Cipher" target="_blank">cipher</a>, a machine that performs encryption or decryption.</p>

<p>The following transducer implementation is identical to the classifier, except for the transition function, <span class="mono">T<span class="sub3">t</span></span>, which modifies both the register and the <span class="mono">i<span class="sup2">th</span></span> character of the string, as opposed to just the register.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> L&minus;1</span>
<span class="line">  a<span class="sub3">i</span>&nldr;a<span class="sub3">N+i</span> &larr; T<span class="sub3">t</span>(a<span class="sub3">i</span>&nldr;a<span class="sub3">N+i</span>)</span>
<span class="line">  <span class="keyword2">for</span> j &larr; N&minus;1 <span class="keyword2">down to</span> 0</span>
<span class="line">    [a<span class="sub3">i+j+1</span>,a<span class="sub3">i+j</span>] &larr; [a<span class="sub3">i+j</span>,a<span class="sub3">i+j+1</span>]</span>
</pre>

<p>As the program slides the register over the string, it transforms each input character into an output character:</p>

<object id="transducer.svg" data="transducer.svg" type="image/svg+xml" class="diagram">Transducer Animation</object>

<h2 id="turing-machine">Turing Machine</h2>

<p>This section discusses <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank">Turing machines</a>, abstract devices capable of running any algorithm.</p>

<h3 id="turing-machine-definition">Definition</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank">Turing machine</a> consists of a <a href="https://en.wikipedia.org/wiki/Tape_drive" target="_blank">tape drive</a> coupled to a state machine. Mounted onto the drive is an infinitely long <span class="term">tape</span> that stores an endless sequence of characters, <span class="mono">t</span>, all of which are initially zero:</p> 

<p><span class="nowrap mono">t<span class="sub3">i&isin;(&minus;&infin;, &infin;)</span> &larr; 0</span></p>

<p>A process writes an input string to the tape at <span class="nowrap">index <span class="mono">0</span></span>:</p>  

<p><span class="nowrap mono">t<span class="sub3">i&isin;[0,L&minus;1]</span> &larr; i<span class="sup2">th</span></span> character of an input string of length <span class="mono">L</span></p>

<p>Afterwards, the driveâ€™s read/write <span class="term">head</span>&mdash;which is limited to accessing a single character at any time&mdash;is repositioned over the first character of the input string, <span class="mono">t<span class="sub3">0</span></span>. On command, the head can step left from some <span class="mono">t<span class="sub3">i</span></span> to <span class="mono">t<span class="sub3">i&minus;1</span></span>, or right from some <span class="mono">t<span class="sub3">i</span></span> to <span class="mono">t<span class="sub3">i+1</span></span>.</p> 

<p>A process initializes the state machine to a starting state. At runtime, if the state machine transitions to a halt state, then the algorithm finished. At that point, the process may read output strings deposited on the tape by the algorithm.</p> 

<p>During each processing cycle, the machine reads the character under the head, <span class="mono">r</span>, it pairs the character with the current state, <span class="mono">s</span>, and it uses the pair to perform a lookup in a <span class="term">state-transition table</span> that contains a finite number of entries of the form:</p> 

<p><span class="nowrap mono">[ r, s ] &#8614; [ w, d, z ]</span></p>

<p>The looked-up value is a triplet representing instructions, which the machine carries out:</p>

<ol>
  <li>Write character <span class="mono">w</span>, overwriting <span class="mono">r</span>.</li>
  <li>Step the head in direction <span class="mono">d</span>, repositioning it over an immediate neighbor.</li> 
  <li>Transition to state <span class="mono">z</span>.</li>
</ol>

<h3 id="turing-machine-implementation">Implementation</h3>

<p>The following Turing machine implementation stores its data in an <a href="#infinite-array-abstraction">infinite array abstraction</a>. The first <span class="nowrap"><span class="mono">N</span> bytes</span> of the array, <span class="mono nowrap">a<span class="sub3">0</span>&nldr;a<span class="sub3">N&minus;1</span></span>, serve as an <span class="nowrap"><span class="mono">N</span>-byte</span> register, where a subset of those bytes store the state machineâ€™s current state. The remaining bytes, <span class="mono nowrap">a<span class="sub3">N</span>&nldr;a<span class="sub3">&infin;</span></span>, emulate the tape drive, where each data byte, <span class="mono">t<span class="sub3">i</span></span>, is paired with a <a href="https://en.wikipedia.org/wiki/Metadata" target="_blank">metadata</a> byte, <span class="mono">h<span class="sub3">i</span></span>:</p>

<p><span class="nowrap mono">h<span class="sub3">i</span> &equiv; 1</span> if the head is over <span class="mono">t<span class="sub3">i</span></span>; otherwise, <span class="mono">0</span>.</p>

<p>Initially, <span class="nowrap mono">h<span class="sub3">0</span> = 1</span> and <span class="nowrap mono">h<span class="sub3">i&ne;0</span> = 0</span>, because the head starts out over <span class="mono">t<span class="sub3">0</span></span>.</p>

<p>To step the head, adjacent elements of <span class="mono">h</span> are swapped:</p>

<table class="map"> 
  <tr><td class="key">step left:</td><td><span class="nowrap mono">[h<span class="sub3">i</span>,h<span class="sub3">i&minus;1</span>] &larr; [h<span class="sub3">i&minus;1</span>,h<span class="sub3">i</span>]</span></td></tr>
  <tr><td class="key">step right:</td><td><span class="nowrap mono">[h<span class="sub3">i</span>,h<span class="sub3">i+1</span>] &larr; [h<span class="sub3">i+1</span>,h<span class="sub3">i</span>]</span></td></tr>
</table>

<p>Since the array is bounded on the left, the tape is &ldquo;folded in half at the origin&rdquo; and the pairs are interlaced:</p>

<p><span class="nowrap mono">h<span class="sub3">0</span>, t<span class="sub3">0</span>, h<span class="sub3">&minus;1</span>, t<span class="sub3">&minus;1</span>, h<span class="sub3">1</span>, t<span class="sub3">1</span>, h<span class="sub3">&minus;2</span>, t<span class="sub3">&minus;2</span>, h<span class="sub3">2</span>, t<span class="sub3">2</span>, h<span class="sub3">&minus;3</span>, t<span class="sub3">&minus;3</span>, h<span class="sub3">3</span>, t<span class="sub3">3</span>, &mldr;</span></p>

<p>Every four bytes consists of a positive-indexed pair followed by a negative-indexed pair. Formally, for <span class="nowrap mono">i &ge; 0</span>:</p>

<p><span class="nowrap mono">a<span class="sub3">N+4i+0</span> &equiv; h<span class="sub3">i</span></span></p>

<p><span class="nowrap mono">a<span class="sub3">N+4i+1</span> &equiv; t<span class="sub3">i</span></span></p>

<p><span class="nowrap mono">a<span class="sub3">N+4i+2</span> &equiv; h<span class="sub3">&minus;(i+1)</span></span></p>

<p><span class="nowrap mono">a<span class="sub3">N+4i+3</span> &equiv; t<span class="sub3">&minus;(i+1)</span></span></p>

<p>At runtime, the machine slides the register to indices divisible by four. At those locations, <span class="mono">j</span>, it applies a transition function, <span class="mono">T<span class="sub3">m</span></span>, that operates on the register bytes, <span class="mono nowrap">a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N&minus;1</span></span>, and eight extra bytes immediately to the right of the register, <span class="mono nowrap">a<span class="sub3">j+N</span>&nldr;a<span class="sub3">j+N+7</span></span>:</p>

<p><span class="nowrap mono">a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span> &larr; T<span class="sub3">m</span>(a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span>)</span></p>

<p>The eight extra bytes correspond to the segment:</p>

<p><span class="nowrap mono">h<span class="sub3">j</span>, t<span class="sub3">j</span>, h<span class="sub3">&minus;(j+1)</span>, t<span class="sub3">&minus;(j+1)</span>, h<span class="sub3">j+1</span>, t<span class="sub3">j+1</span>, h<span class="sub3">&minus;(j+2)</span>, t<span class="sub3">&minus;(j+2)</span></span></p>

<p>Meaning, <span class="mono">T<span class="sub3">m</span></span> has access to two consecutive positive-index pairs and two consecutive negative-index pairs. If the head is not among them (if metadata bytes <span class="mono">h<span class="sub3">j</span></span>, <span class="mono">h<span class="sub3">&minus;(j+1)</span></span>, <span class="mono">h<span class="sub3">j+1</span></span>, and <span class="mono">h<span class="sub3">&minus;(j+2)</span></span> are all zero), then <span class="mono">T<span class="sub3">m</span></span> passes its input through, unchanged. Otherwise, it uses the register value in conjunction with the data byte beneath the head to perform a state-transition table lookup. If the looked-up instructions command <span class="mono">T<span class="sub3">m</span></span> to step the head to a metadata byte beyond the bounds of the eight extra bytes, then <span class="mono">T<span class="sub3">m</span></span> cannot comply. In that case, <span class="mono">T<span class="sub3">m</span></span> passes its input through, unchanged. Otherwise, it carries out the instructions. Specifically, it overwrites the data byte, it swaps two metadata bytes to step the head, and it modifies the register value to transition the state machine.</p>

<p>To enable <span class="mono">T<span class="sub3">m</span></span> to know if it is being applied to the &ldquo;fold&rdquo; of the tape, where it may need to step the head from <span class="mono">h<span class="sub3">0</span></span> to <span class="mono">h<span class="sub3">&minus;1</span></span> or vice versa, the first byte of the register, <span class="mono">a<span class="sub3">j</span></span>, is set to <span class="mono">1</span> if <span class="mono nowrap">j = 0</span>, and it is reset to <span class="mono">0</span>, otherwise.</p>

<p>The <span class="nowrap">MC program</span> that governs the machine applies <span class="mono">T<span class="sub3">m</span></span> to the minimal tape region guaranteed to contain the head. The head starts at <span class="mono">h<span class="sub3">0</span></span>, and during each cycle, it steps, at most, one element further away from that origin. This means, after <span class="nowrap"><span class="mono">y</span> cycles</span>, the minimal regionÂ expands to <span class="mono nowrap">h<span class="sub3">&minus;y</span>&nldr;h<span class="sub3">y</span></span>. As shown below, the program slides the register back-and-forth across the array, applying <span class="mono">T<span class="sub3">m</span></span> to every index divisible by four along the way, and venturing a greater distance out with each pass of the outer loop.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 4 <span class="keyword2">to</span> &infin; <span class="keyword2">step by</span> 4</span>
<span class="line">  <span class="keyword2">for</span> j &larr; 0 <span class="keyword2">to</span> i&minus;4 <span class="keyword2">step by</span> 4</span>
<span class="line">    a<span class="sub3">j</span> &larr; j = 0</span>
<span class="line">    a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span> &larr; T<span class="sub3">m</span>(a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span>)</span>
<span class="line">    slideRegister(j, 4)</span>
<span class="line">  <span class="keyword2">for</span> j &larr; i <span class="keyword2">down to</span> 4 <span class="keyword2">step by</span> 4</span>
<span class="line">    a<span class="sub3">j</span> &larr; j = 0</span>
<span class="line">    a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span> &larr; T<span class="sub3">m</span>(a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span>)</span>
<span class="line">    slideRegister(j, &minus;4)</span>
</pre>

<p><span class="nowrap">Lines 2&ndash;5</span> slide the register rightward across the widening region. And <span class="nowrap">lines 6&ndash;9</span> handle the return trip.</p>

<p>The following version expands <span class="mono">slideRegister</span> into nested loops that repeated swap array elements through the register. </p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for</span> i &larr; 4 <span class="keyword2">to</span> &infin; <span class="keyword2">step by</span> 4</span>
<span class="line">  <span class="keyword2">for</span> j &larr; 0 <span class="keyword2">to</span> i&minus;4 <span class="keyword2">step by</span> 4</span>
<span class="line">    a<span class="sub3">j</span> &larr; j = 0</span>
<span class="line">    a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span> &larr; T<span class="sub3">m</span>(a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span>)</span>
<span class="line">    <span class="keyword2">for</span> k &larr; 0 <span class="keyword2">to</span> 3</span>
<span class="line">      <span class="keyword2">for</span> p &larr; N&minus;1 <span class="keyword2">down to</span> 0</span>
<span class="line">        [a<span class="sub3">j+k+p</span>,a<span class="sub3">j+k+p+1</span>] &larr; [a<span class="sub3">j+k+p+1</span>,a<span class="sub3">j+k+p</span>]</span>
<span class="line">  <span class="keyword2">for</span> j &larr; i <span class="keyword2">down to</span> 4 <span class="keyword2">step by</span> 4</span>
<span class="line">    a<span class="sub3">j</span> &larr; j = 0</span>
<span class="line">    a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span> &larr; T<span class="sub3">m</span>(a<span class="sub3">j</span>&nldr;a<span class="sub3">j+N+7</span>)</span>
<span class="line">    <span class="keyword2">for</span> k &larr; 3 <span class="keyword2">down to</span> 0</span>
<span class="line">      <span class="keyword2">for</span> p &larr; 0 <span class="keyword2">to</span> N&minus;1</span>
<span class="line">        [a<span class="sub3">j+k+p</span>,a<span class="sub3">j+k+p+1</span>] &larr; [a<span class="sub3">j+k+p+1</span>,a<span class="sub3">j+k+p</span>]</span>
</pre>

<p>Through a chain of conversions from pseudocode to MC to TS to IL, that program ultimately represents an endless sequence of game inputs that can run any algorithm.</p>

<h3 id="turing-machine-discussion">Discussion</h3>

<p>If <span class="mono">T<span class="sub3">m</span></span> along with data on the tape emulates a <a href="https://en.wikipedia.org/wiki/Universal_Turing_machine" target="_blank">universal Turing machine</a>, thenÂ Tetris&mdash;withÂ an infinite playfield, controlled by an agent entering input based on the pseudocode above&mdash;isÂ a system capable of universal computation. However, since it depends on a finitely defined yet infiniteÂ sequence, the system is more accurately described as <a href="https://en.wikipedia.org/wiki/Turing_completeness#Formal_definitions" target="_blank">&ldquo;weakly universal&rdquo;</a>. Nonetheless, its universality implies <a href="https://en.wikipedia.org/wiki/Undecidable_problem" target="_blank">undecidable</a> problems. For instance, the problem of determining ifÂ the information encoded on the pile's surface evolves into a particular stateÂ is undecidable because it is equivalentÂ to asking if a given program <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank">halts</a>.</p>

<h1 id="general-purpose-computer">General-purpose Computer</h1>

<p>This section provides a deep dive into a general-purpose computer.</p>

<h2 id="computer-overview">Overview</h2>

<p>The following general-purpose computer is a <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" target="_blank">deterministic linear bounded automaton</a> that emulates an <span class="nowrap">8-bit</span> processor coupled with up to <span class="nowrap">64 KiB</span> of RAM. As with the abstract machines, it employs an <a href="#infinite-array-abstraction">infinite array abstraction</a> for storage. A process loads a <a href="https://en.wikipedia.org/wiki/Machine_code" target="_blank">machine code</a> program into the first <span class="nowrap"><span class="mono">L</span> bytes</span> of the array, it pads out the program with two zeros, and it reserves <span class="nowrap">21 bytes</span> for a state register:</p>

<object id="machine-code-padding-and-register.svg" data="machine-code-padding-and-register.svg" type="image/svg+xml" class="diagram">Machine Code, Padding, and Register</object>

<p>The machine code program is a sequence of bytes representing instructions and data. At execution time, the computer restricts the program to accessing its own bytes, as opposed to the entire array.Â This means, the loaded program is the initial state of the computerâ€™s RAM. Its length, <span class="mono">L</span>, establishes the RAM size and a fixed address space, <span class="nowrap mono">0&nldr;L&minus;1</span>, where <span class="nowrap"><span class="mono">L</span> &le; 65,536 bytes</span>, the maximum <span class="nowrap">RAM size</span>.</p>

<p>A segment of the state register contains the address of the next instruction to execute. To fetch the instruction, the computer slides the state register across RAM, applying a function, <span class="mono">fetchLoadStore</span>, to each byte along the way. When the state register reaches the instructionâ€™s address, <span class="mono">fetchLoadStore</span> copies the instruction to a segment of the state register.</p>

<p>Similarly, a segment of state register may contain the address of a byte to load or store. If present, when the state register reaches that address, <span class="mono">fetchLoadStore</span> copies a <span class="nowrap">RAM byte</span> to a state register byte, or <span class="nowrap">vice versa</span>.</p> 

<p>After the computer slides the state register across RAM, it applies a function, <span class="mono">decodeExecute</span>, to decode and execute the fetched instruction. It puts calculated results in segments of the state register.</p>

<p>The following pseudocode summarizes the computer. The inner loop on <span class="nowrap">line 2</span> slides the state register leftward and the inner loop on <span class="nowrap">line 7</span> slides the state register rightward.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">while true</span></span>
<span class="line">  <span class="keyword2">for</span> x &larr; L&minus;1 <span class="keyword2">down to</span> 1</span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+23</span> &larr; fetchLoadStore(a<span class="sub3">x</span>&nldr;a<span class="sub3">x+23</span>)</span>
<span class="line">    slideRegister(x+3, &minus;1)</span>
<span class="line">  a<span class="sub3">0</span>&nldr;a<span class="sub3">23</span> &larr; fetchLoadStore(a<span class="sub3">0</span>&nldr;a<span class="sub3">23</span>)</span>
<span class="line">  a<span class="sub3">3</span>&nldr;a<span class="sub3">23</span> &larr; decodeExecute(a<span class="sub3">3</span>&nldr;a<span class="sub3">23</span>)</span>
<span class="line">  <span class="keyword2">for</span> x &larr; 0 <span class="keyword2">to</span> L&minus;2</span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+23</span> &larr; fetchLoadStore(a<span class="sub3">x</span>&nldr;a<span class="sub3">x+23)</span>
<span class="line">    slideRegister(x+3, 1)</span>
<span class="line">  a<span class="sub3">L&minus;1</span>&nldr;a<span class="sub3">L+22</span> &larr; fetchLoadStore(a<span class="sub3">L&minus;1</span>&nldr;a<span class="sub3">L+22</span>)</span>
<span class="line">  a<span class="sub3">L+2</span>&nldr;a<span class="sub3">L+22</span> &larr; decodeExecute(a<span class="sub3">L+2</span>&nldr;a<span class="sub3">L+22</span>)</span>
</pre>

<p><span class="mono">fetchLoadStore</span> operates on the state register bytes, <span class="nowrap mono">a<span class="sub3">x+3</span>&nldr;a<span class="sub3">x+23</span></span>, and three extra bytes immediately left of the state register, <span class="nowrap mono">a<span class="sub3">x</span>&nldr;a<span class="sub3">x+2</span></span>. The state register slides left only as far as <span class="nowrap">address 3</span> to enable <span class="mono">fetchLoadStore</span> to simultaneously engage the state register and the leftmost machine code byte <span class="nowrap">(line 5)</span>. Likewise, the two padding bytes enable <span class="mono">fetchLoadStore</span> to simultaneously engage the state register and the rightmost machine code byte <span class="nowrap">(line 10)</span>.</p>

<p><span class="mono">decodeExecute</span> operates exclusively on the state register. It defers execution of load and store instructions to <span class="mono">fetchLoadStore</span> since it does not engage RAM.</p>

<h2 id="microcode">Microcode</h2>

<p>This section presents the <span class="nowrap">MC programs</span> that implement internal control sequences and machine code instructions. The programs represent a layer of abstraction analogous to <a href="https://en.wikipedia.org/wiki/Microcode" target="_blank">microcode</a> in traditional processor design.</p>

<p>As revealed in the image below, the state register consists of twenty-one <span class="nowrap">8-bit</span> registers. Most of them are internal registers, but a few are exposed to machine code instructions.</p>

<object id="register-all-bytes.svg" data="register-all-bytes.svg" type="image/svg+xml" class="diagram">All Byte Registers</object>

<p>The three bytes immediately left of the state register and the byte immediately right of the state register are called <span class="mono">I</span>, <span class="mono">J</span>, <span class="mono">K</span>, and <span class="mono">Q</span>, respectively, regardless of the state registerâ€™s location. The <span class="nowrap">MC programs</span> execute relative to <span class="nowrap">byte <span class="mono">I</span></span>.</p>

<p>Several <span class="nowrap">8-bit</span> registers jointly function as <span class="nowrap">16-bit</span> or <span class="nowrap">24-bit</span> registers:</p>

<object id="register-all.svg" data="register-all.svg" type="image/svg+xml" class="diagram">All Registers</object>

<p>The <span class="nowrap">16-bit</span> <span class="term">address register</span>, <span class="mono">a</span>, stores <span class="mono">I</span>â€™s address:</p>

<object id="register-a.svg" data="register-a.svg" type="image/svg+xml" class="diagram">Address Register</object>

<p>Since the state register starts out two bytes right of the machine code program, a process initializes <span class="mono">a</span> to <span class="mono">L&minus;1</span>.</p>

<p>The <span class="nowrap">MC program</span> that slides the state register left decrements <span class="mono">a</span> to keep it pointed at <span class="mono">I</span>:</p>

<pre class="code">
<span class="filename">SLIDE_STATE_REG_LEFT.mc</span>
<span class="line"><span class="normal">DEC_16 </span><span class="number">13               </span><span class="comment">; --a;</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">3                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">4                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">8                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">9                  </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">10                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">11                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">12                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">13                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">14                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">15                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">16                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">17                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">18                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">19                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">20                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">21                 </span><span class="comment">; swap K right</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">22                 </span><span class="comment">; swap K right</span></span>
</pre>

<p>Similarly, the <span class="nowrap">MC program</span> that slides the state register right increments <span class="mono">a</span>:</p>

<pre class="code">
<span class="filename">SLIDE_STATE_REG_RIGHT.mc</span>
<span class="line"><span class="normal">INC_16 </span><span class="number">13               </span><span class="comment">; ++a;</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">23                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">22                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">21                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">20                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">19                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">18                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">17                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">16                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">15                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">14                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">13                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">12                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">11                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">10                 </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">9                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">8                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">4                  </span><span class="comment">; swap Q left</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">3                  </span><span class="comment">; swap Q left</span></span>
</pre>

<p>The <span class="nowrap">16-bit</span> <span class="term">program counter</span>, <span class="mono">P</span>, stores the address of the instruction to be fetched. As the computer slides the state register across RAM, when <span class="mono">P</span> equals <span class="mono">a</span>, it copies <span class="mono">IJK</span> into the <span class="term">instruction register</span>, <span class="mono">ijk</span>:</p>

<object id="register-p.svg" data="register-p.svg" type="image/svg+xml" class="diagram">Program Counter</object>

<p>Machine code instructions vary in length from one to three bytes. The first byte is the opcode and the rest, if any, is an <span class="nowrap">8-bit</span> or a <span class="nowrap">16-bit</span> operand. At twenty-four bits wide, <span class="mono">ijk</span> can store any instruction. And at decode time, if the instruction does not take up the full width of <span class="mono">ijk</span>, the computer discards the remainder.</p>

<p>The implementation follows. To highlight the most pertinent code, the listings omit <span class="mono">SWAP</span>s from this point forward.</p>

<pre class="code">
<span class="filename">FETCH.mc</span>
<span class="line"><span class="normal">CMP_C </span><span class="number">9                 </span><span class="comment">; s1 = (P1 == a1);</span></span>
<span class="line"><span class="normal">CMP_AND_C </span><span class="number">10            </span><span class="comment">; s1 &= (P0 == a0);</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">2            </span><span class="comment">; if (s1) i = I;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">3            </span><span class="comment">; if (s1) j = J;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">4            </span><span class="comment">; if (s1) k = K;</span></span>
</pre>

<p>Since there is no <span class="nowrap">16-bit</span> comparator, the program separately compares the high bytes, <span class="mono">P1</span> and <span class="mono">a1</span>, and the low bytes, <span class="mono">P0</span> and <span class="mono">a0</span>. It puts the result in <span class="mono">s1</span>, one of two <span class="nowrap">8-bit</span> <span class="term">shuttle registers</span> that transport intermediate values between production sites and consumption sites. Because there is no <span class="nowrap">24-bit</span> copy function, the program individually and conditionally copies the bytes of <span class="mono">IJK</span> to <span class="mono">ijk</span> if <span class="mono">s1</span> is set.</p>

<p>After the computer slides the state register across RAM, it increments <span class="mono">P</span> by the fetched instruction length in preparation of the next fetch. The implementation uses match functions that check if the opcode in <span class="mono">i</span> fits the pattern of a <span class="nowrap">2- or 3-byte</span> instruction:</p>

<pre class="code">
<span class="filename">INCREMENT_P.mc</span>
<span class="line"><span class="normal">INC_16 </span><span class="number">8                </span><span class="comment">; ++P;</span></span>
<span class="line"><span class="normal">SEX_C </span><span class="number">12                </span><span class="comment">; s1 = (i is a 2-byte instruction);</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
<span class="line"><span class="normal">THREE_C </span><span class="number">12              </span><span class="comment">; s1 = (i is a 3-byte instruction);</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
</pre>

<p>After the computer increments <span class="mono">P</span>, it decodes and executes the fetched instruction. The process begins with the <span class="term">transfer instructions</span>, each of which copies an <span class="nowrap">8-bit</span> source register to an <span class="nowrap">8-bit</span> destination register, among those listed below.</p>

<table class="borderless high-rows">  
  <tr><th class="borderless">Register</th><th class="borderless">Name</th><th class="borderless">Description</th></tr>
  <tr><td class="mono">A</td><td class="pad-right2">Accumulator</td><td class="borderless">Input and lone output of all arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">B</td><td class="pad-right2"><span class="nowrap">Data Register</span></td><td class="borderless">Input of some arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">M</td><td class="pad-right2"><span class="nowrap">High Memory Register</span></td><td class="borderless"><span class="nowrap">High byte</span> of the <span class="nowrap">16-bit</span> <span class="term">Memory Register</span>, <span class="mono">MN</span>, which contains the <span class="nowrap">source address</span> of <span class="nowrap">load instructions</span> and the <span class="nowrap">destination address</span> of <span class="nowrap">store instructions</span>.</td></tr>
  <tr><td class="mono">N</td><td class="pad-right2"><span class="nowrap">Low Memory Register</span></td><td class="borderless"><span class="nowrap">Low byte</span> of <span class="mono">MN</span>.</td></tr>
</table>

<p>There are twelve ways to transfer data between those registers:</p>

<object id="register-copy-all.svg" data="register-copy-all.svg" type="image/svg+xml" class="diagram">Transfers</object>

<p>The following <span class="nowrap">MC program</span> decodes and executes the transfer instructions.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_TRANSFER.mc</span>
<span class="line"><span class="normal">TMX_C </span><span class="number">12                </span><span class="comment">; s1 = (i matches TM*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">13           </span><span class="comment">; if (s1) s0 = M;</span></span>
<span class="line"><span class="normal">TNX_C </span><span class="number">13                </span><span class="comment">; s1 = (i matches TN*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) s0 = N;</span></span>
<span class="line"><span class="normal">TAX_C </span><span class="number">17                </span><span class="comment">; s1 = (i matches TA*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">18           </span><span class="comment">; if (s1) s0 = A;</span></span>
<span class="line"><span class="normal">TBX_C </span><span class="number">18                </span><span class="comment">; s1 = (i matches TB*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">19           </span><span class="comment">; if (s1) s0 = B;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TXB_C </span><span class="number">18                </span><span class="comment">; s1 = (i matches T*B);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">19           </span><span class="comment">; if (s1) B = s0;</span></span>
<span class="line"><span class="normal">TXA_C </span><span class="number">17                </span><span class="comment">; s1 = (i matches T*A);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">18           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"><span class="normal">TXN_C </span><span class="number">13                </span><span class="comment">; s1 = (i matches T*N);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">14           </span><span class="comment">; if (s1) N = s0;</span></span>
<span class="line"><span class="normal">TXM_C </span><span class="number">12                </span><span class="comment">; s1 = (i matches T*M);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">13           </span><span class="comment">; if (s1) M = s0;</span></span>
</pre>

<p>If the opcode in <span class="mono">i</span> matches the pattern of a transfer instruction, then the program copies the source register to <span class="mono">s0</span> <span class="nowrap">(lines 1&ndash;8)</span>. Subsequently, the program copies <span class="mono">s0</span> to the destination register, again conditioned on <span class="mono">i</span> <span class="nowrap">(lines 10&ndash;17)</span>. Since transfer instructions are <span class="nowrap">1-byte</span> instructions, the program ignores <span class="mono">j</span> and <span class="mono">k</span>.</p>

<p>Next, the computer handles <span class="term">arithmetic and logic instructions</span>. Each computes an <span class="nowrap">8-bit</span> function of <span class="mono">A</span> or of <span class="mono">A</span> and <span class="mono">B</span>, and it puts the result in <span class="mono">A</span>. If the result is negative (if <span class="nowrap">bit-7</span> of <span class="mono">A</span> is <span class="mono">1</span>), the instruction sets the <span class="term">negative flag</span>, <span class="mono">n</span>, to <span class="mono">1</span>; otherwise, it resets <span class="mono">n</span> to <span class="mono">0</span>. If the result is zero, the instruction sets the <span class="term">zero flag</span>, <span class="mono">z</span>, to <span class="mono">1</span>; otherwise, it resets <span class="mono">z</span> to <span class="mono">0</span>.</p>

<p>The <span class="nowrap">MC program</span> below decodes and executes the twelve arithmetic and logic instructions, all of which are <span class="nowrap">1-byte</span> instructions. Each implementation follows the same pattern. First, the program compares <span class="mono">i</span> and an opcode, storing the result in <span class="mono">s1</span>. Then, the program sets <span class="mono">s0</span> to a function of <span class="mono">A</span> or of <span class="mono">A</span> and <span class="mono">B</span>. Finally, the program conditionally copies <span class="mono">s0</span> to <span class="mono">A</span> based on <span class="mono">s1</span>.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_ARITHMETIC_LOGIC.mc</span>
<span class="line"><span class="normal">CLEAR </span><span class="number">14                </span><span class="comment">; d = 0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ADD_C </span><span class="number">12                </span><span class="comment">; s1 = (i is ADD);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">16            </span><span class="comment">; s0 += B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">AND_C </span><span class="number">12                </span><span class="comment">; s1 = (i is AND);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">16            </span><span class="comment">; s0 &= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">DEC_C </span><span class="number">12                </span><span class="comment">; s1 = (i is DEC);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">DEC </span><span class="number">15                  </span><span class="comment">; --s0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">INC_C </span><span class="number">12                </span><span class="comment">; s1 = (i is INC);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">INC </span><span class="number">15                  </span><span class="comment">; ++s0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS2_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS2);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS2 </span><span class="number">15                  </span><span class="comment">; s0 <<= 2;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS3_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS3);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS3 </span><span class="number">15                  </span><span class="comment">; s0 <<= 3;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS4_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS4);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS4 </span><span class="number">15                  </span><span class="comment">; s0 <<= 4;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">OR_C </span><span class="number">12                 </span><span class="comment">; s1 = (i is OR);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">16             </span><span class="comment">; s0 |= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RS1_C </span><span class="number">12                </span><span class="comment">; s1 = (i is RS1);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">RS1 </span><span class="number">15                  </span><span class="comment">; s0 >>= 1;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RS5_C </span><span class="number">12                </span><span class="comment">; s1 = (i is RS5);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">RS5 </span><span class="number">15                  </span><span class="comment">; s0 >>= 5;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SUB_C </span><span class="number">12                </span><span class="comment">; s1 = (i is SUB);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">SUB_AB_FB </span><span class="number">16            </span><span class="comment">; s0 -= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">XOR_C </span><span class="number">12                </span><span class="comment">; s1 = (i is XOR);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">XOR_AB_FB </span><span class="number">16            </span><span class="comment">; s0 ^= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">CLEAR </span><span class="number">15                </span><span class="comment">; s0 = 0; // required by C_MINUS</span></span>
<span class="line"><span class="normal">C_MINUS </span><span class="number">15              </span><span class="comment">; s0 = (A < 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (d) n = s0;</span></span>
<span class="line"><span class="normal">C_ZERO </span><span class="number">15               </span><span class="comment">; s0 = (A == 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (d) z = s0;</span></span>
</pre>

<p>The program resets the <span class="term">destination flag</span>, <span class="mono">d</span>, to <span class="mono">0</span> (false) on line 1. If <span class="mono">i</span> contains any of the twelve arithmetic and logic instruction opcodes, then the program sets <span class="mono">d</span> to <span class="mono">1</span> (true). On <span class="nowrap">lines 77</span> and 79, the program updates <span class="mono">n</span> and <span class="mono">z</span>, respectively, subject to <span class="mono">d</span>.</p>

<p>Next, the computer handles the <span class="term">set instructions</span>. There are three of them and they vary in length. The first is a <span class="nowrap">2-byte</span> instruction that assigns <span class="mono">A</span> to an <span class="nowrap">8-bit</span> immediate, a constant operand in <span class="mono">j</span>. The second is the same except <span class="mono">B</span> is the target:</p>

<object id="register-copy-j-to-ab.svg" data="register-copy-j-to-ab.svg" type="image/svg+xml" class="diagram">Copy j to A or B</object>

<p>The third is a <span class="nowrap">3-byte</span> instruction that assigns <span class="mono">MN</span> to a <span class="nowrap">16-bit</span> immediate contained in <span class="mono">jk</span>: </p>

<object id="register-copy-jk-to-mn.svg" data="register-copy-jk-to-mn.svg" type="image/svg+xml" class="diagram">Copy jk to MN</object>

<p>The following <span class="nowrap">MC program</span> decodes and executes the set instructions.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_SET.mc</span>
<span class="line"><span class="normal">SEA_C </span><span class="number">12                </span><span class="comment">; s1 = (i is SEA);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) A = j;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEB_C </span><span class="number">11                </span><span class="comment">; s1 = (i is SEB);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) B = j;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN_C </span><span class="number">11                </span><span class="comment">; s1 = (i is SMN);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) M = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">11           </span><span class="comment">; if (s1) N = k;</span></span>
</pre>

<p>Next, the computer handles the <span class="term">branch instructions</span>. There are six of them. Each consists of an opcode in <span class="mono">i</span> followed by a <span class="nowrap">16-bit</span> target address in <span class="mono">jk</span>. The first unconditionally jumps to the target simply by copying <span class="mono">jk</span> to <span class="mono">P</span>:</p>

<object id="register-copy-jk-to-p.svg" data="register-copy-jk-to-p.svg" type="image/svg+xml" class="diagram">Copy jk to P</object>

<p>The next four conditionally jump to the target iff a specified flag, <span class="mono">n</span> or <span class="mono">z</span>, equals a given value, <span class="mono">0</span> or <span class="mono">1</span>:</p>

<object id="register-copy-jk-to-p-with-nz.svg" data="register-copy-jk-to-p-with-nz.svg" type="image/svg+xml" class="diagram">Copy jk to P with n and z</object>

<p>The last is the <span class="term">jump-to-subroutine instruction</span>. It copies <span class="mono">P</span> to the <span class="nowrap">16-bit</span> <span class="term">return register</span>, <span class="mono">R</span>:</p>

<object id="register-copy-p-to-r.svg" data="register-copy-p-to-r.svg" type="image/svg+xml" class="diagram">Copy P to R</object>
    
<p>Since the copy occurs after <span class="mono">P</span> is incremented, <span class="mono">R</span> points to theÂ instruction immediately following the jump-to-subroutine instruction. That is, <span class="mono">R</span> contains the return address, hence its name.</p>
    
<p>Following the copy, it jumps:</p>
    
<object id="register-copy-jk-to-p.svg" data="register-copy-jk-to-p.svg" type="image/svg+xml" class="diagram">Copy jk to P</object>
    
<p>Afterwards, a <span class="term">return-from-subroutine instruction</span> restores <span class="mono">P</span> from <span class="mono">R</span>:</p>

<object id="register-copy-r-to-p.svg" data="register-copy-r-to-p.svg" type="image/svg+xml" class="diagram">Copy R to P</object>

<p>This <a href="https://en.wikipedia.org/wiki/Link_register" target="_blank">link register</a> scheme enables subroutine calls one level deep (all subroutines are <a href="https://en.wikipedia.org/wiki/Leaf_subroutine" target="_blank">leaf subroutines</a>). The computer does not provide a <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stack</a>.</p>

<p>Here is the <span class="nowrap">MC program</span> for the branch instructions:</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_BRANCH.mc</span>
<span class="line"><span class="comment">; Jump:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP_C </span><span class="number">9                 </span><span class="comment">; s1 = (i is JMP);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">10           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Conditional branches:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BEQ_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BEQ);</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">9             </span><span class="comment">; s1 &= z;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BNE_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BNE);</span></span>
<span class="line"><span class="normal">AND_NOT_AB_FB </span><span class="number">9         </span><span class="comment">; s1 &= !z;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BMI_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BMI);</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">9             </span><span class="comment">; s1 &= n;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BPL_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BPL);</span></span>
<span class="line"><span class="normal">AND_NOT_AB_FB </span><span class="number">9         </span><span class="comment">; s1 &= !n;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Jump-to-subroutine:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JSR_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is JSR);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">13           </span><span class="comment">; if (s1) R0 = P0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">10           </span><span class="comment">; if (s1) R1 = P1;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Return-from-subroutine:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RTS_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is RTS);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">10           </span><span class="comment">; if (s1) P1 = R1;</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">13           </span><span class="comment">; if (s1) P0 = R0;</span></span>
</pre>

<p>Last, the computer handles the store and load instructions. A store instruction writes a source register, <span class="mono">A</span> or <span class="mono">B</span>, to memory at the address in <span class="mono">MN</span>. While decoding, if the instruction is not a store instruction, the computer resets the <span class="term">write flag</span>, <span class="mono">w</span>, to <span class="mono">0</span>. Otherwise, it sets <span class="mono">w</span> to <span class="mono">1</span>, and it copies the source register to the <span class="nowrap">8-bit</span> <span class="term">memory value register</span>, m:</p>

<object id="register-copy-ab-to-m.svg" data="register-copy-ab-to-m.svg" type="image/svg+xml" class="diagram">Copy A/B to m</object>

<p>The computer executes a store instruction as it slides the state register slides across RAM. For each address, if <span class="mono">w</span> is <span class="mono">1</span> and <span class="mono">a</span> equals <span class="mono">MN</span>, then the computer copies <span class="mono">m</span> to <span class="mono">I</span>:</p>

<object id="register-copy-m-to-i.svg" data="register-copy-m-to-i.svg" type="image/svg+xml" class="diagram">Copy m to I</object>

<p>A load instruction reads a byte from memory at the address in <span class="mono">MN</span>, and it puts the byte in a destination register, <span class="mono">A</span> or <span class="mono">B</span>. While decoding, if the instruction is not a load instruction, the computer resets the <span class="term">read flag</span>, <span class="mono">r</span>, to <span class="mono">0</span>. Otherwise, it sets <span class="mono">r</span> to <span class="mono">1</span>, and it assigns the aforementioned destination flag, <span class="mono">d</span>, to <span class="mono">0</span> for <span class="mono">A</span> or <span class="mono">1</span> for <span class="mono">B</span>.</p>

<p>The computer executes a load instruction as it slides the state register slides across RAM. For each address, if <span class="mono">r</span> is <span class="mono">1</span> and <span class="mono">a</span> equals <span class="mono">MN</span>, then the computer copies <span class="mono">I</span> to <span class="mono">m</span>:</p>

<object id="register-copy-i-to-m.svg" data="register-copy-i-to-m.svg" type="image/svg+xml" class="diagram">Copy I to m</object>

<p>After the computer slides the state register across RAM and before it decodes the fetched instruction, if <span class="mono">r</span> is <span class="mono">1</span>, then the computer copies the read byte in <span class="mono">m</span> to <span class="mono">A</span> or <span class="mono">B</span> based on the value in <span class="mono">d</span>, and it assigns <span class="mono">n</span> and <span class="mono">z</span> as if the read byte were the result of an arithmetic or logic instruction:</p>

<object id="register-copy-m-to-ab.svg" data="register-copy-m-to-ab.svg" type="image/svg+xml" class="diagram">Copy m to A/B</object>

<p>Note: <span class="mono">d</span>, <span class="mono">n</span>, <span class="mono">r</span>, <span class="mono">w</span>, and <span class="mono">z</span> each occupy a full byte of the state register despite being <span class="nowrap">1-bit</span> flags. And there is neither a <span class="term">carry flag</span> nor an <span class="term">overflow flag</span>.</p>

<p>The following <span class="nowrap">MC program</span> decodes load and store instructions. As explained, load assigns <span class="mono">d</span> and <span class="mono">r</span>, while store assigns <span class="mono">m</span> and <span class="mono">w</span>.</p>

<pre class="code">
<span class="filename">DECODE_LOAD_STORE.mc</span>
<span class="line"><span class="normal">STB_C </span><span class="number">11                </span><span class="comment">; s1 = (i is STB);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">12           </span><span class="comment">; if (s1) m = B;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">STA_C </span><span class="number">11                </span><span class="comment">; s1 = (i is STA);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">12           </span><span class="comment">; if (s1) m = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LDB_C </span><span class="number">12                </span><span class="comment">; d = (i is LDB);</span></span>
<span class="line"><span class="normal">LDX_C </span><span class="number">7                 </span><span class="comment">; r = (i matches LD*);</span></span>
<span class="line"><span class="normal">STX_C </span><span class="number">6                 </span><span class="comment">; w = (i matches ST*);</span></span>
</pre>

<p>Since load and store instructions are single-byte instructions, the program ignores <span class="mono">j</span> and <span class="mono">k</span>.</p>

<p>The <span class="nowrap">MC program</span> below executes load and store instructions. As the computer slides the state register across RAM, the program compares <span class="mono">MN</span> and <span class="mono">a</span>. When they match, the program copies <span class="mono">I</span> to <span class="mono">m</span> if <span class="mono">r</span> indicates read, or it copies <span class="mono">m</span> to <span class="mono">I</span> if <span class="mono">w</span> indicates write.</p>

<pre class="code">
<span class="filename">EXECUTE_LOAD_STORE.mc</span>
<span class="line"><span class="normal">CMP_C </span><span class="number">12                </span><span class="comment">; s0 = (M == a1);</span></span>
<span class="line"><span class="normal">CMP_AND_C </span><span class="number">14            </span><span class="comment">; s0 &= (N == a0);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">11             </span><span class="comment">; s1 = s0;</span></span>
<span class="line"><span class="normal">AND_AB_AF </span><span class="number">8             </span><span class="comment">; s1 &= r;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">5            </span><span class="comment">; if (s1) m = I;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">11             </span><span class="comment">; s1 = s0;</span></span>
<span class="line"><span class="normal">AND_AB_AF </span><span class="number">7             </span><span class="comment">; s1 &= w;</span></span>
<span class="line"><span class="normal">COPY_B_A_C </span><span class="number">5            </span><span class="comment">; if (s1) I = m;</span></span>
</pre>

<p>The following <span class="nowrap">MC program</span> completes the execution of load instructions. If <span class="mono">r</span> indicates read, then the program assigns <span class="mono">n</span> and <span class="mono">z</span> based on <span class="mono">m</span>, and the program copies <span class="mono">m</span> to <span class="mono">A</span> or <span class="mono">B</span> based on <span class="mono">d</span>.</p>

<pre class="code">
<span class="filename">ASSIGN_LOADED.mc</span>
<span class="line"><span class="normal">MINUS_C </span><span class="number">11              </span><span class="comment">; s0 = (m < 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">16           </span><span class="comment">; if (r) n = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ZERO_C </span><span class="number">16               </span><span class="comment">; s0 = (m == 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">17           </span><span class="comment">; if (r) z = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">C_AND_A_NOT_B </span><span class="number">16        </span><span class="comment">; s0 = r & !d;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">18           </span><span class="comment">; if (s0) A = m;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">AND_A_B_C </span><span class="number">15            </span><span class="comment">; s0 = r & d;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">19           </span><span class="comment">; if (s0) B = m;</span></span>
</pre>

<p>Putting it all together, the <span class="nowrap">MC program</span> below slidesÂ the state register leftward across RAM. Along the way (lines 1&ndash;24), it fetches an instruction, and it potentially loads or stores a byte. Afterward (lines 26&ndash;32), the program assigns <span class="mono">A</span> or <span class="mono">B</span> to the loaded byte (if there is one), it increments <span class="mono">P</span>, and it decodes and executes the transfer instructions, the arithmetic and logic instructions, the set instructions, and the branch instructions. Finally, it decodes the load and store instructions, deferring their execution to the rightward slide.</p>

<pre class="code">
<span class="filename">CYCLE_LEFT.mc</span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_LEFT </span><span class="number">L-1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_LEFT </span><span class="number">L-2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_LEFT </span><span class="number">L-3</span></span>
<span class="line"></span>
<span class="line"><span class="normal">...</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">2</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_LEFT </span><span class="number">2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">1</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_LEFT </span><span class="number">1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ASSIGN_LOADED </span><span class="number">0</span></span>
<span class="line"><span class="normal">INCREMENT_P </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_TRANSFER </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_ARITHMETIC_LOGIC </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_SET </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_BRANCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_LOAD_STORE </span><span class="number">0</span></span>
</pre>

<p>The rightward slide follows.</p>

<pre class="code">
<span class="filename">CYCLE_RIGHT.mc</span>
<span class="line"><span class="normal">FETCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">0</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_RIGHT </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">1</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_RIGHT </span><span class="number">1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">2</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_RIGHT </span><span class="number">2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">...</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_RIGHT </span><span class="number">L-3</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">SLIDE_STATE_REG_RIGHT </span><span class="number">L-2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ASSIGN_LOADED </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">INCREMENT_P </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_TRANSFER </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_ARITHMETIC_LOGIC </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_SET </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_BRANCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_LOAD_STORE </span><span class="number">L-1</span></span>
</pre>

<p>Unlike all the other <span class="nowrap">MC programs</span>, which were coded by hand, a process generated <span class="mono">CYCLE_LEFT</span> and <span class="mono">CYCLE_RIGHT</span> due to their dependency on the machine code program length. In the real code, the placeholders, <span class="mono">L-x</span>, are actual array index values.</p>

<p>The computer alternates between <span class="mono">CYCLE_LEFT</span> and <span class="mono">CYCLE_RIGHT</span> from startup to shutdown.</p>

<h2 id="assembly-language">Assembly Language</h2>

<p>This section details an <a href="https://en.wikipedia.org/wiki/Assembly_language" target="_blank">assembly language</a> for the general-purpose computer. The language is case-insensitive. However, in this text, <a href="https://en.wikipedia.org/wiki/Assembly_language#Opcode_mnemonics_and_extended_mnemonics" target="_blank">mnemonics</a> appear uppercase while everything else appears <a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank">camel case</a>.</p>

<h3 id="registers">Registers</h3>

<p>The following table lists the <a href="https://en.wikipedia.org/wiki/Processor_register#Types" target="_blank">user-accessible registers</a>, those available to assembly language instructions.</p>

<table class="borderless high-rows">  
  <tr><th class="borderless">Register</th><th class="borderless">Name</th><th class="borderless">Bits</th><th class="borderless">Description</th></tr>
  <tr><td class="mono">A</td><td>Accumulator</td><td class="centered">8</td><td class="borderless">Input and lone output of all arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">B</td><td><span class="nowrap">Data Register</span></td><td class="centered">8</td><td class="borderless">Input of some arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">MN</td><td><span class="nowrap">Memory Register</span></td><td class="centered">16</td><td class="borderless">Source address of load instructions and the destination address of store instructions. The <span class="nowrap">8-bit</span> <span class="mono">M</span> and <span class="mono">N</span> registers contain its high and low bytes, respectively. </td></tr>
  <tr><td class="mono">P</td><td><span class="nowrap">Program Counter</span></td><td class="centered">16</td><td class="borderless">Address of the instruction to execute next.</td></tr>
  <tr><td class="mono">R</td><td><span class="nowrap">Return Register</span></td><td class="centered">16</td><td class="borderless">Address of the instruction to return to at the end of a subroutine.</td></tr>
  <tr><td class="mono">n</td><td><span class="nowrap">Negative Flag</span></td><td class="centered">1</td><td class="borderless">Indicates an arithmetic, logic, or load instruction produced a negatively signed value.</td></tr>
  <tr><td class="mono">z</td><td><span class="nowrap">Zero Flag</span></td><td class="centered">1</td><td class="borderless">Indicates an arithmetic, logic, or load instruction produced zero.</td></tr>
</table>

<p>Note: There is no carry flag, nor an overflow flag.</p>

<h3 id="transfer-instructions">Transfer Instructions</h3>

<p>A transfer instruction copies an <span class="nowrap">8-bit</span> source register to an <span class="nowrap">8-bit</span> destination register. Its format is:</p>  

<p class="definition">T(source)(destination)</p>

<p>where <span class="mono">source</span>,<span class="mono">destination</span><span class="serif"> &isin; { </span><span class="mono">A</span>, <span class="mono">B</span>, <span class="mono">M</span>, <span class="mono">N</span><span class="serif"> }</span> and <span class="mono">source</span> &ne; <span class="mono">destination</span>.  

<p>Each transfer instruction corresponds to an opcode with bits <span class="mono">0000ssdd</span>, where <span class="mono">ss</span> and <span class="mono">dd</span> are one of the values below.</p>

<table class="borderless">
  <tr><th class="borderless">Value</th><th class="borderless">Register</th></tr>
  <tr><td class="mono">00</td><td class="mono">A</td></tr>
  <tr><td class="mono">01</td><td class="mono">B</td></tr>	
  <tr><td class="mono">10</td><td class="mono">M</td></tr>
  <tr><td class="mono">11</td><td class="mono">N</td></tr>
</table>

<p>The twelve transfer instructions follow.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">TAB</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">B</span></td><td class="pseudocode">B = A;</td><td class="mono">01</td></tr>
  <tr><td class="mono">TAM</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">M</span></td><td class="pseudocode">M = A;</td><td class="mono">02</td></tr>
  <tr><td class="mono">TAN</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">N</span></td><td class="pseudocode">N = A;</td><td class="mono">03</td></tr>
  <tr><td class="mono">TBA</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">A</span></td><td class="pseudocode">A = B;</td><td class="mono">04</td></tr>
  <tr><td class="mono">TBM</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">M</span></td><td class="pseudocode">M = B;</td><td class="mono">06</td></tr>
  <tr><td class="mono">TBN</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">N</span></td><td class="pseudocode">N = B;</td><td class="mono">07</td></tr>
  <tr><td class="mono">TMA</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">A</span></td><td class="pseudocode">A = M;</td><td class="mono">08</td></tr>
  <tr><td class="mono">TMB</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">B</span></td><td class="pseudocode">B = M;</td><td class="mono">09</td></tr>
  <tr><td class="mono">TMN</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">N</span></td><td class="pseudocode">N = M;</td><td class="mono">0B</td></tr>
  <tr><td class="mono">TNA</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">A</span></td><td class="pseudocode">A = N;</td><td class="mono">0C</td></tr>
  <tr><td class="mono">TNB</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">B</span></td><td class="pseudocode">B = N;</td><td class="mono">0D</td></tr>
  <tr><td class="mono">TNM</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">M</span></td><td class="pseudocode">M = N;</td><td class="mono">0E</td></tr>
</table>

<p>The transfer instructions do not affect the flags.</p>

<h3 id="arithmetic-and-logic-instructions">Arithmetic and Logic Instructions</h3>

<p>An arithmetic or logic instruction computes an <span class="nowrap">8-bit</span> function of <span class="mono">A</span> or of <span class="mono">A</span> and <span class="mono">B</span>, and it puts the result in <span class="mono">A</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">ADD</td><td class="borderless">Add (without carry)</td><td class="pseudocode">A += B;</td><td class="mono">10</td></tr>    
  <tr><td class="mono">AND</td><td class="borderless">Bitwise AND</td><td class="pseudocode">A &= B;</td><td class="mono">11</td></tr>
  <tr><td class="mono">DEC</td><td class="borderless">Decrement</td><td class="pseudocode">--A;</td><td class="mono">12</td></tr>
  <tr><td class="mono">INC</td><td class="borderless">Increment</td><td class="pseudocode">++A;</td><td class="mono">13</td></tr>
  <tr><td class="mono">LS2</td><td class="borderless">Logical Left Shift by 2</td><td class="pseudocode">A <<= 2;</td><td class="mono">14</td></tr>
  <tr><td class="mono">LS3</td><td class="borderless">Logical Left Shift by 3</td><td class="pseudocode">A <<= 3;</td><td class="mono">15</td></tr>
  <tr><td class="mono">LS4</td><td class="borderless">Logical Left Shift by 4</td><td class="pseudocode">A <<= 4;</td><td class="mono">16</td></tr>
  <tr><td class="mono">OR</td><td class="borderless">Bitwise OR</td><td class="pseudocode">A |= B;</td><td class="mono">17</td></tr>
  <tr><td class="mono">RS1</td><td class="borderless">Logical Right Shift by 1</td><td class="pseudocode">A >>>= 1;</td><td class="mono">18</td></tr>
  <tr><td class="mono">RS5</td><td class="borderless">Logical Right Shift by 5</td><td class="pseudocode">A >>>= 5;</td><td class="mono">19</td></tr>
  <tr><td class="mono">SUB</td><td class="borderless">Subtract (without borrow)</td><td class="pseudocode">A -= B;</td><td class="mono">1A</td></tr>
  <tr><td class="mono">XOR</td><td class="borderless">Bitwise XOR</td><td class="pseudocode">A ^= B;</td><td class="mono">1B</td></tr>
</table>

<p>The <span class="nowrap">carry-outs</span> of <span class="mono">ADD</span> and <span class="mono">INC</span>, the <span class="nowrap">borrow-outs</span> of <span class="mono">SUB</span> and <span class="mono">DEC</span>, and the <span class="span">shift-outs</span> of the shift instructions are lost. There is no <span class="nowrap">add-with-carry</span> instruction nor a <span class="nowrap">subtract-with-borrow</span> instruction. All shift instructions <span class="nowrap">shift-in</span> <span class="mono">0</span>.</p> 

<p>Every arithmetic and logic instruction assigns the zero flag, <span class="mono">z</span>, to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is zero, and to <span class="mono">0</span>, otherwise. Similarly, it assigns the negative flag, <span class="mono">n</span>, to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is negative (if <span class="nowrap">bit-7</span> is <span class="mono">1</span>), and to <span class="mono">0</span>, otherwise.</p>

<p>The instructions correspond to opcodes with bits <span class="mono">0001xxxx</span>. Of the sixteen possible opcodes, the computer implements the twelve listed above. They were selected to satisfy the requirements of a single program, one that runs Tetris. Potential additions include Bitwise <span class="mono">NOT</span> and shifts by other values.</p>

<h3 id="branch-instructions">Branch Instructions</h3>

<p>A branch instruction redirects execution to a specified location, either conditionally or unconditionally. With one exception, the branch instructions have the following format.</p>

<p class="definition">mnemonic label</p>

<p>A label is a placeholder for an address. In this case, it is the address of the code to run if the branch is taken.</p>

<p>A label declaration consists of a unique name followed by a colon, as shown below.</p>

<p class="definition">name:</p>

<p>The declaration appears immediately before target code or data, and the assembler resolves its address based on its position.</p>

<p>Here are all the branch instructions:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">JMP label</td><td class="borderless pad-left pad-right">Jump</td><td class="pseudocode">P = label;</td><td class="mono">20</td></tr>    
  <tr><td class="mono">BNE label</td><td class="borderless pad-left pad-right">Branch Not Equal</td><td class="pseudocode">if (z == 0) P = label;</td><td class="mono">22</td></tr>
  <tr><td class="mono">BEQ label</td><td class="borderless pad-left pad-right">Branch Equal</td><td class="pseudocode">if (z == 1) P = label;</td><td class="mono">23</td></tr>
  <tr><td class="mono">BPL label</td><td class="borderless pad-left pad-right">Branch Plus</td><td class="pseudocode">if (n == 0) P = label;</td><td class="mono">24</td></tr>
  <tr><td class="mono">BMI label</td><td class="borderless pad-left pad-right">Branch Minus</td><td class="pseudocode">if (n == 1) P = label;</td><td class="mono">25</td></tr>
  <tr><td class="mono">JSR label</td><td class="borderless pad-left pad-right">Jump Subroutine</td><td class="pseudocode">R = P; P = label;</td><td class="mono">28</td></tr>
  <tr><td class="mono">RTS</td><td class="borderless pad-left pad-right">Return Subroutine</td><td class="pseudocode">P = R;</td><td class="mono">70</td></tr>
</table>

<p><span class="mono">RTS</span> is a <span class="nowrap">1-byte</span> instruction. The rest are <span class="nowrap">3-byte</span> instructions consisting of an opcode followed by a <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">big-endian</a> address. The opcode comprises <span class="nowrap">bits <span class="mono">0010rstu</span></span>, where only one of <span class="mono">r</span>, <span class="mono">s</span>, and <span class="mono">t</span> are set, and <span class="mono">u</span> is a value compared to <span class="mono">s</span> or <span class="mono">t</span>:</p>

<table class="borderless">
<tr><th class="borderless">Set Bit</th><th class="borderless">Instructions</th><th class="borderless">Description</th></tr>
<tr><td class="mono">r</td><td class="mono">JSR</td><td>The computer copies the program counter, <span class="mono">P</span>, to the return register, <span class="mono">R</span>, and it branches.</td></tr>
<tr><td class="mono">s</td><td class="mono">BPL,BMI</td><td>The computer branches iff the negative flag, <span class="mono">n</span>, equals <span class="nowrap">bit <span class="mono">u</span></span>.</td></tr>
<tr><td class="mono">t</td><td class="mono">BNE,BEQ</td><td>The computer branches iff the zero flag, <span class="mono">z</span>, equals <span class="nowrap">bit <span class="mono">u</span></span>.</td></tr>
</table>

<p><span class="mono">JSR</span> supports only <a href="https://en.wikipedia.org/wiki/Leaf_subroutine" target="_blank">leaf subroutines</a> since the computer does not provide a native <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stack</a>.</p>

<p>A program can use the conditional branch instructions as <a href="https://en.wikipedia.org/wiki/Relational_operator" target="_blank">relational operators</a> by branching on the result of <span class="nowrap mono">A - B</span>. However, <span class="mono">BPL</span> and <span class="mono">BMI</span> treat the difference as a signed number. This leads to the following limitations.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Relation</th><th class="borderless">Limitations</th></tr>
  <tr><td class="mono">BNE</td><td class="pseudocode">A &ne; B</td><td class="pad-left">none</td></tr>
  <tr><td class="mono">BEQ</td><td class="pseudocode">A = B</td><td class="pad-left">none</td></tr>
  <tr><td class="mono">BPL</td><td class="pseudocode">A &ge; B</td><td class="pseudocode">A - B &#8714; [0, 127]</td></tr>
  <tr><td class="mono">BMI</td><td class="pseudocode">A &lt; B</td><td class="pseudocode">A - B &#8714; [-128, -1]</td></tr>
</table>

<p>While there is no <a href="https://en.wikipedia.org/wiki/Indirect_branch" target="_blank">indirect branch</a> instruction, a program can employ <a href="https://en.wikipedia.org/wiki/Self-modifying_code" target="_blank">self-modifying code</a> to alter a branch target at runtime.</p>

<p>By default, the computer initializes all registers to <span class="mono">0</span> at startup. However, a program can declare an entry point with a label named <span class="mono">main</span>. If present, the computer initializes <span class="mono">P</span> to its address.</p>

<h3 id="load-instructions">Load Instructions</h3>

<p>A load instruction reads the byte at the address in <span class="mono">MN</span> into either <span class="mono">A</span> or <span class="mono">B</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">LDA</td><td class="borderless">Load <span class="mono">A</span></td><td class="pseudocode">A = *MN;</td><td class="mono">40</td></tr>    
  <tr><td class="mono">LDB</td><td class="borderless">Load <span class="mono">B</span></td><td class="pseudocode">B = *MN;</td><td class="mono">41</td></tr>
</table>

<p>It assigns the zero flag, <span class="mono">z</span>, to <span class="mono">1</span> if the <span class="nowrap">read byte</span> is zero, and to <span class="mono">0</span>, otherwise. Similarly, it assigns the negative flag, <span class="mono">n</span>, to <span class="mono">1</span> if the <span class="nowrap">read byte</span> is negative (if <span class="nowrap">bit-7</span> is <span class="mono">1</span>), and to <span class="mono">0</span>, otherwise.</p>

<p>A load instruction maps to an opcode with bits <span class="mono">0100000d</span>, where <span class="mono">A</span> and <span class="mono">B</span> correspond to <span class="nowrap"><span class="mono">d</span> values</span> <span class="mono">0</span> and <span class="mono">1</span>, respectively.</p>

<h3 id="store-instructions">Store Instructions</h3>

<p>A store instruction writes either <span class="mono">A</span> or <span class="mono">B</span> to the address in <span class="mono">MN</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">STA</td><td class="borderless">Store <span class="mono">A</span></td><td class="pseudocode">*MN = A;</td><td class="mono">30</td></tr>    
  <tr><td class="mono">STB</td><td class="borderless">Store <span class="mono">B</span></td><td class="pseudocode">*MN = B;</td><td class="mono">31</td></tr>
</table>

<p>It does not affect the flags.</p>

<p>A store instruction maps to an opcode with bits <span class="mono">0011000s</span>, where <span class="mono">A</span> and <span class="mono">B</span> correspond to <span class="nowrap"><span class="mono">s</span> values</span> <span class="mono">0</span> and <span class="mono">1</span>, respectively.</p>

<h3 id="set-instructions">Set Instructions</h3>

<p>A set instruction assigns a register to an immediate (a constant):</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">SEA immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">A</span></td><td class="pseudocode">A = immediate;</td><td class="mono">50</td></tr>    
  <tr><td class="mono">SEB immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">B</span></td><td class="pseudocode">B = immediate;</td><td class="mono">51</td></tr>
  <tr><td class="mono">SMN immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">MN</span></td><td class="pseudocode">MN = immediate;</td><td class="mono">2F</td></tr>
</table>

<p><span class="mono">SEA</span> and <span class="mono">SEB</span>Â assign an <span class="nowrap">8-bit<span> immediate. And <span class="mono">SMN</span> assigns a <span class="nowrap">16-bit<span> immediate.</p>

<p>They assemble to an opcode followed by the immediate byte or big-endian bytes.</p>      
      
<p>The language accepts <a href="https://en.wikipedia.org/wiki/Integer_literal" target="_blank">integer literal</a> immediate values written in hexadecimal. As shown below, a <span class="nowrap">byte literal</span> contains two <span class="nowrap">hex digits</span> while a <span class="nowrap">16-bit word</span> literal contains four <span class="nowrap">hex digits</span>.</p>

<pre class="code">
<span class="line"><span class="normal">SEA</span> <span class="number">D3</span>                  <span class="comment">; A = 0xD3;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">7F</span>                  <span class="comment">; B = 0x7F;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="number">1234</span>                <span class="comment">; MN = 0x1234;</span></span>
</pre>

<p>The <span class="mono">define</span> directive equatesÂ a name withÂ an integer literal:</p>

<p class="definition">define name value</p>

<p>A program can use defined names as immediate values:</p>

<pre class="code">
<span class="line"><span class="keyword">define</span> <span class="identifier">X</span> <span class="number">D3</span>             <span class="comment">; #define X 0xD3</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">Y</span> <span class="number">7F</span>             <span class="comment">; #define Y 0x7F</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">Z</span> <span class="number">1234</span>           <span class="comment">; #define Z 0x1234</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">X</span>                   <span class="comment">; A = X;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">Y</span>                   <span class="comment">; B = Y;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">Z</span>                   <span class="comment">; MN = Z;</span></span>
</pre>

<p>A data region is aÂ sequence of one or more integer literals not preceded by an instruction mnemonic. To reference a data region, a program prefaces it with a label, and it successively uses the label as a <span class="nowrap">16-bit</span> immediate. The following example demonstrates this.</p>

<pre class="code">
<span class="line"><span class="label">v:</span> <span class="number">00</span>                   <span class="comment">; v = 0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">v</span>                   <span class="comment">; MN = &v;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
<span class="line"><span class="normal">INC</span>                     <span class="comment">; ++A;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
</pre>

<p>The label <span class="mono">v</span> is a placeholder for the address of a single-byte data region that is initialized to zero. When used as an immediate, <span class="mono">v</span> resembles a byte variable. <span class="nowrap">Lines 3&ndash;6</span> are equivalent to <span class="mono">++v;</span></p>

<p>The next example reserves and initializes an <span class="nowrap">8-element</span> byte array, <span class="mono">table</span>, and a byte variable, <span class="mono">index</span>.</p>

<pre class="code">
<span class="line"><span class="keyword">segment</span> <span class="number">0180</span></span>
<span class="line"></span>
<span class="line"><span class="label">table:</span>                  <span class="comment">; table[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 }; </span></span>
<span class="line"><span class="number">01</span> <span class="number">02</span> <span class="number">04</span> <span class="number">08</span></span>
<span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">40</span> <span class="number">80</span></span>
<span class="line"></span>
<span class="line"><span class="label">index:</span> <span class="number">03</span>               <span class="comment">; index = 0x03;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">index</span>               <span class="comment">; MN = &index;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">table</span>               <span class="comment">; MN = table;</span></span>
<span class="line"><span class="normal">TNB</span>                     <span class="comment">; B = N;</span></span>
<span class="line"><span class="normal">ADD</span>                     <span class="comment">; A += B;</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N = A;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
</pre>

<p><span class="nowrap">Lines 9&ndash;15</span> are equivalent to:</p>

<p><span class="mono">A = table[index];</span></p>

<p>Or:</p>

<p><span class="mono">A = *(table + index);</span></p> 

<p>However, without a carry flag, adding a <span class="nowrap">16-bit</span> value to an <span class="nowrap">8-bit</span> value is challenging. Instead, the code takes advantage of the <span class="mono">segment</span> directive, which has the following format.</p> 

<p class="definition">segment address</p>

<p>It instructs the assembler to store bytes generated from subsequent code at the specified address. In this case, the effect is:</p>

<p><span class="mono">table = 0x0180;</span></p>

<p>Since the table is fully contained within the same <span class="nowrap">256-byte</span> memory page, adding <span class="mono">table</span> and <span class="mono">index</span> does not produce a carry. The code offsets only the <span class="nowrap">low-byte</span> of the address.</p>

<p>To facilitate <a href="https://en.wikipedia.org/wiki/Self-modifying_code" target="_blank">self-modifying code</a>, a program can offset a label immediate by a positive or negative constant with the notation below.</p>

<p class="definition">label[+-]offset</p> 

<p>The offset is a fixed integer value written in decimal.</p>  

<p>The notation provides a way to modify the operand of an instruction, as seen in the following example.</p> 

<pre class="code">
<span class="line"><span class="normal">SEA</span> <span class="number">FF</span>                  <span class="comment">; A = 0xFF;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">target</span><span class="normal">+</span><span class="number">1</span>            <span class="comment">; MN = target + 1;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
<span class="line"></span>
<span class="line"><span class="label">target:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span>                  <span class="comment">; B = 0x00; // until replaced with 0xFF</span></span>
</pre>

<p>The label <span class="mono">target</span> is a placeholder for the address of <span class="mono">SEB</span>'s opcode byte. At runtime, lines 1&ndash;3 change <span class="mono">SEB</span>'s operand byte by offsetting <span class="mono">target</span> by one. Consequentially, when the <span class="mono">SEB</span> instruction executes, it assigns <span class="mono">B</span> to <span class="mono">FF</span> rather than <span class="mono">00</span>.</p> 

<p>In summary, the operand of <span class="mono">SMN</span> can be any of the following.</p>

<p class="definition">SMN hex | label | label+offset | label-offset</p>

<p>The same applies to the branch instructions. They can use any of the above as the target. But it is rarely worthwhile to jump to a <span class="nowrap">hex address</span> or to a label offset by a constant.</p>

<h2 id="example-program">Example Program</h2>

<p>The following program is designed to demonstrate the capabilities of the general-purpose computer. It is a bare-bones implementation of Tetris written in the assembly language detailed in the <a href="#assembly-language">previous section</a>.</p>

<p>The program begins by defining constants:</p>

<pre class="code">
<span class="line"><span class="keyword">define</span> <span class="identifier">FALL_SPEED</span> <span class="number">01</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_ATTRACT</span>     <span class="number">00</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_PLAY</span>        <span class="number">01</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_CLEAR_LINES</span> <span class="number">02</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">ACTION_DRAW</span> <span class="number">22</span> <span class="comment">; BNE</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">ACTION_TEST</span> <span class="number">23</span> <span class="comment">; BEQ</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">CELL_EMPTY</span> <span class="number">00</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">CELL_SOLID</span> <span class="number">FF</span> <span class="comment">; Any nonzero cell is solid</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">PLAYFIELD_WIDTH</span> <span class="number">0B</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_X</span> <span class="number">05</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_Y</span> <span class="number">02</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_ROTATION</span> <span class="number">00</span></span>
</pre>

<p><span class="mono">FALL_SPEED</span> is the number of frames between gravity drops. While generating a frame, the program decrements the <span class="nowrap">fall timer</span> by one if it is nonzero. Otherwise, the program resets the <span class="nowrap">fall timer</span> to <span class="mono">FALL_SPEED</span>, and it executes a gravity drop. Since the frame rate is approximately <span class="nowrap">5 frames/sec</span>, a <span class="mono">FALL_SPEED</span> of <span class="mono">01</span> translates to a gravity drop about every <span class="nowrap">400 milliseconds</span>, a rate similar to <span class="nowrap">level 5</span> in <span class="nowrap">NES Tetris</span>.</p>

<p>The program switches between the modes defined on lines 3&ndash;5. <span class="mono">MODE_ATTRACT</span>Â is a very basicÂ <span class="term"><a href="https://en.wikipedia.org/wiki/Glossary_of_video_game_terms#attract_mode" target="_blank">attract mode</a></span> that simply keeps the last <span class="term"><a href="https://tetris.wiki/Top_out" target="_blank">top out</a></span> displayed, or an empty playfield in the case of startup. It is unresponsive to controls except for the Start button, which causes the program to clear the playfield and to transition to <span class="mono">MODE_PLAY</span>. As its name suggests, <span class="mono">MODE_PLAY</span> is the mode where the player interacts with the falling pieces. When a piece locks into the pile, the program temporarily changes toÂ <span class="mono">MODE_CLEAR_LINES</span>, during which it scans for and removes lines.</p>

<p>The program declares a single subroutine called <span class="mono">drawOrTestTetromino</span> that performs the actions defined on <span class="nowrap">lines 7</span> and 8. <span class="mono">ACTION_DRAW</span> directs <span class="mono">drawOrTestTetromino</span> to paint four playfield cells corresponding to the blocks of a named tetromino, at a specified location and orientation, in a prescribed color. <span class="mono">ACTION_TEST</span> directs <span class="mono">drawOrTestTetromino</span> to verify that four playfield cells corresponding to the blocks of a named tetromino, at a specified location and orientation, are all empty. It enables the program to determine if a requested move is a valid move.</p>

<p>Since the computer does not provide a call stack, <span class="mono">drawOrTestTetromino</span> receives the tetromino type, coordinates, and orientation via global variables, and the action and the color via self-modifying code. Regarding the latter, the program overwrites instructions with the action constants&mdash;the opcodes for <span class="mono">BNE</span> and <span class="mono">BEQ</span>.</p>

<p>The remaining constants relate to the playfield. As revealed below, the playfieldÂ is aÂ matrix with <span class="nowrap">23 rows</span> and <span class="nowrap">11 columns</span> (<span class="mono">PLAYFIELD_WIDTH</span>). Each byte contains the state of an individual cell. <span class="mono">00</span> (<span class="mono">CELL_EMPTY</span>) means the cell is empty. Any other value represents the color of a solid cell.</p>

<pre class="code" style="counter-increment: step 18;">
<span class="line"><span class="keyword">segment</span> <span class="number">0000</span></span>
<span class="line"><span class="label">playfield:</span></span>
<span class="line"><span class="comment">;  0  1  2  3  4  5  6  7  8  9 10</span></span>
<span class="line">  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">FF</span>  <span class="comment">;  0</span></span>
<span class="line">  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">FF</span>  <span class="comment">;  1</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  2</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  3</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  4</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  5</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  6</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  7</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  8</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  9</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 10</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 11</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 12</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 13</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 14</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 15</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 16</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 17</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 18</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 19</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 20</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 21</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">00</span>  <span class="comment">; 22</span></span>
</pre>

<p>The green rectangular region is the visible playfield. It spans <span class="nowrap">rows 2&ndash;21</span> and <span class="nowrap">columns 0&ndash;9</span>. tetrominoes spawn in the middle of its ceiling, centered at <span class="nowrap">row 2</span> (<span class="mono">SPAWN_Y</span>) and <span class="nowrap">column 5</span> (<span class="mono">SPAWN_X</span>).</p>

<p><span class="nowrap">Rows 0&ndash;1</span> constitute the <span class="term"><a href="https://tetris.wiki/Playfield#Vanish_zone" target="_blank">vanish zone</a></span>, the area above the ceiling that falling tetrominoes can rotate and even lock into. The initial rotation index, <span class="mono">SPAWN_ROTATION</span>, ensures none of the blocks of newly spawned tetrominoes start out in the vanish zone.</p>

<p><span class="nowrap">Row 22</span> and <span class="nowrap">column 10</span> consist entirely of solid cells (<span class="mono">CELL_SOLID</span>), except for the element in the lower-right corner. <span class="nowrap">Row 22</span> acts as the floor. <span class="nowrap">Column 10</span> serves as both the left wall and the right wall since the matrix, like all data regions, is a one-dimensional array, and each of its row wraps into the next.</p>

<p>When a tetromino locks into the pile, the program scans four rows about the tetromino's centerÂ for lines. The scan ignores the visible playfield boundaries for performance and code simplicity.Â To prevent <span class="nowrap">row 22</span> from inadvertently registering as a line, its rightmost element is an empty cell, and the program scans for lines of eleven solid cells, rather than ten. The eleven-solids check works on the visible rows due the solid elements of <span class="nowrap">column 10</span>.</p>

<p>To clear a line, the program shifts all rows above the line downward. To achieve that, the program overwrites each row with a copy of theÂ preceding row. Since <span class="nowrap">row 0</span> has no preceding row, the program fills it with ten empty cells followed by a solid cell.</p> 

<p>At the start of a new game, the program resets the playfield to the state in the listing above.</p> 

<p>The segment directive on <span class="nowrap">line 19</span> is superfluous because no instructions or data appear before the playfield. But the directive makes it clear the playfield is located at the beginning of RAM. I.e., the label <span class="mono">playfield</span> resolves to address <span class="mono">0000</span>.</p>

<p>At <span class="nowrap">23 &times; 11 = 253 bytes</span>, the playfield fits in the first <span class="nowrap">256-byte</span> page of memory with <span class="nowrap">three bytes</span> to spare. That enables the program to address a cell at <span class="nowrap mono">(row,col)</span> with code equivalent to:</p> 

<pre class="pseudocode">
M = 0;               // page zero

N = 11 * row + col;  // offset within page zero
</pre>

<p>The computer is connected to an external peripheral device, a window that serves as a proxy for the playerâ€™s physical monitor and keyboard. It presents a graphical representation of the visible playfield:</p> 

<p>[ TODO PIC ]</p>

<p>The lower-three bits of each visible playfield byte determine the color of each cell per the following mapping.</p>

<table class="borderless">
<tr><th class="borderless">Value</th><th class="borderless">tetromino</th><th class="borderless">Color</th></tr>
<tr><td class="mono">000</td><td class="roboto centered">(empty)</td><td class="borderless">Black</td></tr>
<tr><td class="mono">001</td><td class="roboto centered">T</td><td class="borderless">Purple</td></tr>
<tr><td class="mono">010</td><td class="roboto centered">J</td><td class="borderless">Blue</td></tr>
<tr><td class="mono">011</td><td class="roboto centered">Z</td><td class="borderless">Red</td></tr>
<tr><td class="mono">100</td><td class="roboto centered">O</td><td class="borderless">Yellow</td></tr>
<tr><td class="mono">101</td><td class="roboto centered">S</td><td class="borderless">Green</td></tr>
<tr><td class="mono">110</td><td class="roboto centered">L</td><td class="borderless">Orange</td></tr>
<tr><td class="mono">111</td><td class="roboto centered">I</td><td class="borderless">Cyan</td></tr>
</table>

<p>The computer and the window communicate via <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O" target="_blank">memory-mapped I/O</a>. After the program updates the visible playfield in RAM, it writes <span class="mono">01</span> to <span class="mono">00FD</span>, the <span class="mono">drawFrame</span> flag in the listing below.

<pre class="code" style="counter-increment: step 45;">
<span class="line"><span class="keyword">segment</span> <span class="number">00FD</span></span>
<span class="line"><span class="label">drawFrame:</span>           <span class="number">00</span> <span class="comment">; 00 = generating frame; otherwise, finished generating frame</span></span>
<span class="line"><span class="label">leftButton:</span>          <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">rightButton:</span>         <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
</pre>

<p>The window polls that location. When it reads a nonzero value, it copies the visible playfield from RAM to an array that backs the displayed image. Then, for each keyboard key that controls the game, the window writes the key's status&mdash;either <span class="mono">00</span> for released or <span class="mono">01</span> for pressed&mdash;to a key-specific address. Finally, it resets <span class="mono">drawFrame</span> to <span class="mono">00</span>. </p>

<p>The window writes the statuses of the left and right <span class="nowrap">arrow keys</span> in <span class="mono">leftButton</span> and <span class="mono">rightButton</span>, respectively, the <span class="nowrap">last-two bytes</span> of memory <span class="nowrap">page zero</span>. The remaining keyboard key addresses appear later in the code because the <span class="mono">tetrominoes</span> table is aligned with the start of <span class="nowrap">page one</span>:</p>

<pre class="code" style="counter-increment: step 50;">
<span class="line"><span class="keyword">segment</span> <span class="number">0100</span></span>
<span class="line"><span class="label">tetrominoes:</span></span>
<span class="line"><span class="comment">;  0  1  2  3</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">; 0 0 td {  -1,   0,   1,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 0 1 tl { -11,  -1,   0,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">F5</span> <span class="comment">; 0 2 tu {  -1,   0,   1, -11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">; 0 3 tr { -11,   0,   1,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">; 1 0 jd {  -1,   0,   1,  12 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 1 1 jl { -11,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">F4</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 1 2 ju { -12,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">F6</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 1 3 jr { -11, -10,   0,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">; 2 0 zh {  -1,   0,  11,  12 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">; 2 1 zv { -10,   0,   1,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">; 2 2 zh {  -1,   0,  11,  12 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">; 2 3 zv { -10,   0,   1,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 3 0 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 3 1 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 3 2 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 3 3 o  {  -1,   0,  10,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 4 0 sh {   0,   1,  10,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">; 4 1 sv { -11,   0,   1,  12 }</span></span>
<span class="line">  <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 4 2 sh {   0,   1,  10,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">; 4 3 sv { -11,   0,   1,  12 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="comment">; 5 0 ld {  -1,   0,   1,  10 }</span></span>
<span class="line">  <span class="number">F4</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 5 1 ll { -12, -11,   0,  11 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 5 2 lu { -10,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">; 5 3 lr { -11,   0,  11,  12 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FE</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 6 0 ih {  -2,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">EA</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 6 1 iv { -22, -11,   0,  11 }</span></span>
<span class="line">  <span class="number">FE</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 6 2 ih {  -2,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">EA</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 6 3 iv { -22, -11,   0,  11 }</span></span>
</pre>

<p>Each row of the <span class="mono">tetrominoes</span> table contains the coordinates of four blocks of a rotated tetromino encoded as signed offsets relative to the tetrominoâ€™s center. Since the playfield is a <span class="nowrap">one-dimensional</span> data region representing a <span class="nowrap">two-dimensional</span> matrix of width eleven, the signed offset of a block at <span class="nowrap mono">(x,y)</span> is <span class="nowrap mono">11 * y + x</span>.</p> 

<p>The program addresses each table element with code equivalent to:</p>

<pre class="pseudocode">
M = 1;  // page one

N = 16 * tetrominoType + 4 * tetrominoRotation + blockIndex;  // offset within page one
</pre>

<p>The orientation of the falling tetromino, <span class="mono">tetrominoRotation</span>, is in the range <span class="nowrap mono">[0,3]</span> regardless of the tetromino type, <span class="mono">tetrominoType</span>, because the orientations of the Z-, S-, and <span class="nowrap">I-tetrominoes</span> appear twice, and the orientation of the <span class="nowrap">O-tetromino</span> appears four times:</p>

<object id="tetrominoes-table.svg" data="tetrominoes-table.svg" type="image/svg+xml" class="diagram">Tetrominoes Table</object>

<p>Above, the leftmost column comprises the <span class="term">spawn orientations</span>, the way the pieces initially appear. And the steps of clockwise rotation span left-to-right across each row. This is the same <a href="https://tetris.wiki/Nintendo_Rotation_System" target="_blank">way pieces rotate</a> in <span class="nowrap">NES Tetris</span>.</p>

<p>The window writes the remaining keyboard key statuses to bytes immediately following the <span class="mono">tetrominoes</span> table.</p>

<pre class="code" style="counter-increment: step 88;">
<span class="line"><span class="keyword">segment</span> <span class="number">0170</span></span>
<span class="line"><span class="label">startButton:</span>         <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">ccwRotateButton:</span>     <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed </span></span>
<span class="line"><span class="label">cwRotateButton:</span>      <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">downButton:</span>          <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
</pre>

<p><span class="mono">ccw</span> and <span class="mono">cw</span> are abbreviations for &ldquo;counterclockwise&rdquo; and &ldquo;clockwise&rdquo;, respectively.</p>

<p>Here is the full key mapping:</p>

<table class="borderless">
<tr><th class="borderless">Status Variable</th><th class="borderless">Key</th></tr>
<tr><td class="mono2">startButton</td><td class="borderless centered">Enter</td></tr>
<tr><td class="mono2">leftButton</td><td class="borderless centered">&larr;</td></tr>
<tr><td class="mono2">rightButton</td><td class="borderless centered">&rarr;</td></tr>
<tr><td class="mono2">downButton</td><td class="borderless centered">&darr;</td></tr>
<tr><td class="mono2">ccwRotateButton</td><td class="borderless centered">Z</td></tr>
<tr><td class="mono2">cwRotateButton</td><td class="borderless centered">X</td></tr>
</table>

<p>Next, the program declares the game state variables:</p>

<pre class="code" style="counter-increment: step 94;">
<span class="line"><span class="label">tetrominoType:</span>       <span class="number">00</span> <span class="comment">; 00--06 (T, J, Z, O, S, L, I)</span></span>
<span class="line"><span class="label">tetrominoRotation:</span>   <span class="number">00</span> <span class="comment">; 00--03</span></span>
<span class="line"><span class="label">tetrominoX:</span>          <span class="number">00</span> <span class="comment">; 00--09</span></span>
<span class="line"><span class="label">tetrominoY:</span>          <span class="number">00</span> <span class="comment">; 02--15</span></span>
<span class="line"></span>
<span class="line"><span class="label">lastRotation:</span>        <span class="number">00</span> <span class="comment">; 00--03</span></span>
<span class="line"><span class="label">lastX:</span>               <span class="number">00</span> <span class="comment">; 00--09</span></span>
<span class="line"></span>
<span class="line"><span class="label">frameCounter:</span>        <span class="number">00</span> <span class="comment">; 00--FF (wraps around)</span></span>
<span class="line"></span>
<span class="line"><span class="label">seedHigh:</span>            <span class="number">89</span> <span class="comment">; randomizer</span></span>
<span class="line"><span class="label">seedLow:</span>             <span class="number">88</span></span>
<span class="line"><span class="label">nextBit:</span>             <span class="number">00</span></span>
<span class="line"></span>
<span class="line"><span class="label">i:</span>                   <span class="number">00</span> <span class="comment">; loops index</span></span>
<span class="line"><span class="label">origin:</span>              <span class="number">00</span> <span class="comment">; playfield index corresponding to tetromino center</span></span>
<span class="line"><span class="label">tetrominoesIndex:</span>    <span class="number">00</span> <span class="comment">; tetrominoes table index corresponding to a tetromino block</span></span>
<span class="line"></span>
<span class="line"><span class="label">fallTimer:</span>           <span class="number">00</span> <span class="comment">; 00 = drop tetromino</span></span>
<span class="line"><span class="label">mode:</span>                <span class="number">00</span> <span class="comment">; 00 = attract, 01 = play, 02 = clear lines</span></span>
<span class="line"><span class="label">minY:</span>                <span class="number">00</span> <span class="comment">; minimal locked tetromino Y (00--16)</span></span>
</pre>

<p>The variables on <span class="nowrap">lines 95&ndash;98</span> describe the falling tetromino. Prior to servicing a move request, the program backs up the tetromino's orientation and <span class="nowrap">x-coordinate</span> in the variables on <span class="nowrap">lines 100&ndash;101</span>.Â If the program discovers the request is invalid, then it restores the original values from the backups.</p>

<p>When a tetromino spawns, the program updates the <span class="nowrap">16-bit value</span> spread across <span class="mono">seedHigh</span> and <span class="mono">seedLow</span> by it passing through a randomization function. The <span class="mono">frameCounter</span>&mdash;a variable the program increments at the start of each frame&mdash;influences the randomization function. It provides a source of entropy based on the timing of the player's actions. The program stores the function's <span class="nowrap">single-bit</span> output in <span class="mono">nextBit</span>.</p>

<p>The code comments describe the rest of the variables, though <span class="mono">minY</span> deserves extra explanation. <span class="mono">minY</span> stores the row index of the highest tetromino on the pile. The program uses it to improved the performance of clearing lines. Specifically, the program does not shift the empty rows above the highest tetromino because empty space looks the same shifted or not.</p>

<p>That completes the data region. The rest of the program consists of instructions, beginning with its entry point:</p>

<pre class="code" style="counter-increment: step 116;">
<span class="line"><span class="label">main:</span> <span class="comment">; ------------------------------------------------------------------------------------------------------</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawFrame</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">01</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; render frame</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">frameCounter</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++frameCounter;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_PLAY</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (mode == MODE_PLAY) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">playing</span>             <span class="comment">;   goto playing;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_CLEAR_LINES</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (mode == MODE_CLEAR_LINES) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">clearLines</span>          <span class="comment">;   goto clearLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">startButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (startButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">main</span><span class="comment">;               ;   goto main;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The program signals the window to display the current playfield state by writing <span class="mono">01</span> to <span class="mono">drawFrame</span>. It does not wait for the window to write <span class="mono">00</span> back to <span class="mono">drawFrame</span> because the window runs at blistering speed compared to the program.</p>

<p>The program increments the <span class="mono">frameCounter</span> by one.</p>

<p>In play mode and clear lines mode, the program jumps to respective handlers. Otherwise, the program is in attract mode, where it monitors the Start button's status. If the button is released, the program loops back to the entry point. Else it continues to:</p>

<pre class="code" style="counter-increment: step 142;">
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span>                <span class="comment">; // Start button pressed</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">16</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; minY = 22;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="number">F1</span>                  <span class="comment">; A = 0xF1; // 22 * PLAYFIELD_WIDTH - 1, index of last element of row 21</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="label">clearLoop:</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; playfield[A] = CELL_EMPTY;</span></span>
<span class="line"><span class="normal">DEC</span>                     <span class="comment">; if (--A != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">clearLoop</span>           <span class="comment">;   goto clearLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; playfield[0] = CELL_EMPTY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="number">00F1</span>                <span class="comment">; MN = 0x00F1; // 22 * PLAYFIELD_WIDTH - 1, address of last element of row 21 </span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_SOLID</span></span>
<span class="line"><span class="label">edgeLoop:</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; *MN = CELL_SOLID;</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; MN -= PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">FF</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (*MN != -1) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">edgeLoop</span>            <span class="comment">;   goto edgeLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The program resets <span class="mono">minY</span> to the floor index, it clears <span class="nowrap">rows 0&ndash;21</span>, and it resolidifies <span class="nowrap">column 10</span>. Then the program spawns the first tetromino of the game:</p>

<pre class="code" style="counter-increment: step 169;">
<span class="line"><span class="label">spawn:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_PLAY</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_PLAY;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_ROTATION</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoRotation = SPAWN_ROTATION;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_X</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoX = SPAWN_X;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoY</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_Y</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoY = SPAWN_Y;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">FALL_SPEED</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = FALL_SPEED;</span></span>
</pre>

<p>The program finally changes to play mode. It happens here, rather than earlier, because this spawn code also executes at the end of clear lines mode to resume play mode.</p>

<p>The program positions and orients the tetromino at the spawn point, and it resets the <span class="mono">fallTimer</span> to the maximum value to prevent the tetromino from gravity dropping immediately after spawning.</p>

<p>Next, the program randomly chooses the tetromino type:</p> 

<pre class="code" style="counter-increment: step 186;">
<span class="line"><span class="label">randomlyChoose:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">02</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedLow</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">STA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">XOR</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">bit9Clear</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">80</span></span>
<span class="line"><span class="label">bit9Clear:</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; nextBit = ((seedHigh & 0x02) ^ (seedLow & 0x02)) << 6;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">01</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">bit8Clear</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">80</span></span>
<span class="line"><span class="label">bit8Clear:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedLow</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">RS1</span></span>
<span class="line"><span class="normal">OR</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; seedLow = (seedHigh << 7) | (seedLow >>> 1);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">RS1</span></span>
<span class="line"><span class="normal">OR</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; seedHigh = nextBit | (seedHigh >>> 1);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">frameCounter</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">XOR</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">1F</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">RS5</span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; B = ((seedHigh ^ frameCounter) & 0x1F) * 7 / 32;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (B == tetrominoType) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">randomlyChoose</span>      <span class="comment">;   goto randomlyChoose;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; tetrominoType = B;</span></span>
</pre>

<p>The program employs the same <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Fibonacci_LFSRs" target="_blank">Fibonacci linear-feedback shift register</a> (LFSR) at the core of the pseudorandom number generator in <a href="https://meatfighter.com/nintendotetrisai/#Picking_tetrominoes" target="_blank">NES Tetris</a>. As shown below, the program generates the next random bit, <span class="mono">nextBit</span>, by XORing <span class="nowrap">bit-1s</span> of <span class="mono">seedHigh</span> and <span class="mono">seedLow</span>.</p>

<object id="lfsr-schematic.svg" data="lfsr-schematic.svg" type="image/svg+xml" class="diagram">LFSR</object>

<p><span class="mono">seedHigh</span> and <span class="mono">seedLow</span> collectively operate as a <span class="nowrap">16-bit</span> register. The program logical right shifts it, discarding the lowest bit, and <span class="nowrap">shifting-in</span> <span class="mono">nextBit</span>.</p>

<p>The program initializes <span class="mono">seedHigh</span> and <span class="mono">seedLow</span> to <span class="mono">89</span> and <span class="mono">88</span>, respectively, the same arbitrary quantities used in <span class="nowrap">NES Tetris</span>.</p>

<p>The LFSR generates a sequence of 32,767 unique values before cycling, one less-than half the numbers that fit in a <span class="nowrap">16-bit</span> register. To prevent that deterministic sequence from producing a constant tetromino order, the program bases its selection on <span class="mono">seedHigh</span> XORed with the <span class="mono">frameCounter</span>. Since the program increments the <span class="mono">frameCounter</span> at the beginning of every frame, even during attract mode, the XOR makes the tetromino order dependent on when the player hits the Start button. The number of frames between spawns also affects the order. And the playerâ€™s inputs influence that number.</p>

<p>The program reduces the XORed value to the range <span class="nowrap">[ 0, 6 ]</span> because there are seven tetrominoes. Since the computer does not provide a <a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank">modulo</a> instruction, the program performs the reduction with the following formula, where <span class="mono">v</span> is the <span class="nowrap">lower-five</span> bits of the XORed value.</p>

<p><span class="mono">7 * v / 32</span></p>

<p>Since <span class="nowrap"><span class="mono">v</span><span class="serif"> &isin; </span>[ 0, 31 ]</span>, the formula multiplies 7 by a fraction less-than 1.0, producing a value in the correct range when floored.</p>

<p>The program employs a transformed version of the formula:</p>

<pre class="pseudocode">
= (8 * v - v) / 32

= ((v << 3) - v) / 32

= ((v << 3) - v) >>> 5
</pre>

<p>If the randomly chosen tetromino is the same as the last one, the programÂ picks again. That simple strategy does not prevent alternating duplicate pieces. Nor does it inhibit droughts.</p>

<p>Next, the program verifies the tetromino spawned into empty space by invoking <span class="mono">drawOrTestTetromino</span>:</p>

<pre class="code" style="counter-increment: step 242;">
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_TEST</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_TEST;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetromino</span> <span class="comment">; if (drawOrTestTetromino()) { // verify tetromino spawned into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">keepPosition</span>        <span class="comment">;   goto playing;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span>               <span class="comment"> ; // Bad tetromino position. It's game over.</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_ATTRACT</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_ATTRACT;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">endFall</span>             <span class="comment">; goto endFall; // draws the tetromino that failed to spawn</span></span>
</pre>

<p>Based on the action constant stored to <span class="mono">drawOrTest</span>, <span class="mono">drawOrTestTetromino</span> either paints or examine the four playfield cells corresponding to the blocks of the falling tetromino. But unlike the inputs that describe the falling tetromino&mdash;<span class="mono">tetrominoType</span>, <span class="mono">tetrominoRotation</span>, <span class="mono">tetrominoX</span>, and <span class="mono">tetrominoY</span>&mdash;<span class="mono">drawOrTest</span> is not a global variable. It is a label that resolves to the address an instruction inside of <span class="mono">drawOrTestTetromino</span>. When the program &ldquo;assigns&rdquo; <span class="mono">drawOrTest</span>, it modifies its own code. </p>

<p><span class="mono">ACTION_TEST</span> causes <span class="mono">drawOrTestTetromino</span> to set the zero flag iff all four examined cells are empty. If they are, the program jumps to the play handler below. Otherwise, a top out occurred. In that case, the program switches to attract mode, and it jumps to <span class="mono">endFall</span>. There, the program draws the tetromino at the invalid location, overlaid on solid blocks, to provide a visual indication of spawn failure. Then the program loops back to the beginning, where it waits for player to press the Start button once again.</p>

<pre class="code" style="counter-increment: step 256;">
<span class="line"><span class="label">playing:</span>                <span class="comment">; // Play handler</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_DRAW</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_DRAW;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawCell</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(drawCell+1) = CELL_EMPTY;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetromino</span> <span class="comment">; drawOrTestTetromino(); // erase tetromino</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastRotation</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; lastRotation = tetrominoRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastX</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; lastX = tetrominoX;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">leftButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (leftButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testRightButton</span>     <span class="comment">;   goto testRightButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span>          <span class="comment">; // Left button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --tetrominoX;</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">testCcwRotateButton</span> <span class="comment">; goto testCcwRotateButton;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testRightButton:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">rightButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (rightButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testCcwRotateButton</span> <span class="comment">;   goto testCcwRotateButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span>          <span class="comment">; // Right button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++tetrominoX;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testCcwRotateButton:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">03</span>                  <span class="comment">; B = 3;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">ccwRotateButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (ccwRotateButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testCwRotateButton</span>  <span class="comment">;   goto testCwRotateButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span>   <span class="comment">; // CCW button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoRotation = (tetrominoRotation - 1) & 3;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">validatePosition</span>    <span class="comment">; goto validatePosition;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testCwRotateButton:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">cwRotateButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (cwRotateButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">validatePosition</span>    <span class="comment">;   goto validatePosition;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span>   <span class="comment">; // CW button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoRotation = (tetrominoRotation + 1) & 3;</span></span>
<span class="line"></span>
<span class="line"><span class="label">validatePosition:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_TEST</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_TEST;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetromino</span> <span class="comment">; if (drawOrTestTetromino()) { // verify tetromino shifted/rotated into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">keepPosition</span>        <span class="comment">;   goto keepPosition;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastRotation</span>        <span class="comment">; // Bad tetromino position. Undo shift or rotation.</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoRotation = lastRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastX</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoX = lastX;</span></span>
</pre>

<p>The play handler calls <span class="mono">drawOrTestTetromino</span> to paint the falling tetromino with empty cells, erasing it from the playfield. In another example of self-modifying code, the handler stores the paint value, <span class="mono">CELL_EMPTY</span>, to <span class="mono">drawCell+1</span>, the address of an instruction operand in <span class="mono">drawOrTestTetromino</span>.</p>

<p>The handler backs up the orientation and the <span class="nowrap">x-coordinate</span> of the falling tetromino.</p>

<p>If the Left button is pressed, the handler decrements the <span class="nowrap">x-coordinate</span> by one. Otherwise, if the Right button is pressed, the handler increments the <span class="nowrap">x-coordinate</span> by one.</p>

<p>If the Counterclockwise Rotation button is pressed, the handler decrements the orientation by one, such that zero wraps to three. Otherwise, if the Clockwise Rotation button is pressed, the handler increments the orientation by one, such that three wraps to zero.</p>

<p>The handler verifies the manipulated tetromino is fully within empty space by calling <span class="mono">drawOrTestTetromino</span>. If it is not, the handler restores the original orientation and <span class="nowrap">x-coordinate</span> from the backups.</p>

<p>Next, the handler deals with drops:</p>

<pre class="code" style="counter-increment: step 340;">
<span class="line"><span class="label">keepPosition:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">downButton</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span>           <span class="comment">; if (downButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">updateFallTimer</span>     <span class="comment">;   goto updateFallTimer;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="number">00</span>                  <span class="comment">; // Down button pressed</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = 0;                  </span></span>
<span class="line"></span>
<span class="line"><span class="label">updateFallTimer:</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (fallTimer != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">decFallTimer</span>        <span class="comment">;   goto decFallTimer;</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">FALL_SPEED</span>          <span class="comment">; } </span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = FALL_SPEED;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoY</span>          <span class="comment">; // Drop tetromino</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++tetrominoY;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetromino</span> <span class="comment">; if (drawOrTestTetromino()) { // verify tetromino dropped into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">endFall</span>             <span class="comment">;   goto endFall;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoY</span>          <span class="comment">; // Bad tetromino position. Undo drop and lock tetromino in place.</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --tetrominoY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">BMI</span> <span class="identifier">keepMinY</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; minY = min(minY, tetrominoY);</span></span>
<span class="line"></span>
<span class="line"><span class="label">keepMinY:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_CLEAR_LINES</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_CLEAR_LINES;</span></span>
<span class="line"></span>
<span class="line"><span class="label">decFallTimer:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --fallTimer;</span></span>
<span class="line"></span>
<span class="line"><span class="label">endFall:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_DRAW</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_DRAW;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawCell</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(drawCell+1) = tetrominoType + 1;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetromino</span> <span class="comment">; drawOrTestTetromino(); // draw tetromino</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">main</span>                <span class="comment">; goto main;</span></span>
</pre>

<p>If the Down button is pressed, the handler assigns <span class="mono">fallTimer</span> zero.</p>  

<p>If <span class="mono">fallTimer</span> is zero, the handler resets <span class="mono">fallTimer</span> to <span class="mono">FALL_SPEED</span>, and it increments the tetromino's <span class="nowrap">y-coordinate</span> by one. If the dropped tetromino is not fully within empty space per a check by <span class="mono">drawOrTestTetromino</span>, the handler decrements the tetromino's <span class="nowrap">y-coordinate</span> by one, restoring its position to where it now locks into the pile. Afterwards, the handler updates <span class="mono">minY</span> based off the new pile height, and it switches to clear lines mode.</p> 

<p>Then the handler flows into the code that normally runs when <span class="mono">fallTimer</span> is nonzero. It decrements <span class="mono">fallTimer</span> by one, and it calls <span class="mono">drawOrTestTetromino</span> to draw the tetromino, which may now be at a different location and orientation from where it was erased at the start of the play handler. The paint value is <span class="mono nowrap">tetrominoType + 1</span> because zero represents an empty cell.</p>  

<p>Finally, the handler jumps back to the beginning of the program. If the tetromino locked into the pile, the program will jump from there to the clear lines handler below. It scans for and vanishes lines, without displaying a clearing animation.</p> 

<pre class="code" style="counter-increment: step 401;">
<span class="line"><span class="label">clearLines:</span>             <span class="comment">; // Clear lines handler</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">03</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; i = 3; // loop 4 times, from i = 3 down to 0.</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin = PLAYFIELD_WIDTH * (tetrominoY + 1); // row below tetromino center</span></span>
<span class="line"></span>
<span class="line"><span class="label">clearLinesLoop:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">16</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">notLine0</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="label">notLine0:</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minN</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(minN+1) = PLAYFIELD_WIDTH * max(1, minY - 2) - 1; // minimum index to copy from</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; MN = playfield + origin;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEB</span> <span class="number">0A</span>                  <span class="comment">; B = PLAYFIELD_WIDTH - 1;</span></span>
<span class="line"><span class="label">scanLine:</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (*MN == CELL_EMPTY) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">continueClearLines</span>  <span class="comment">;   goto continueClearLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">TBA</span></span>
<span class="line"><span class="normal">DEC</span>                     <span class="comment">; if (--B < 0) { </span></span>
<span class="line"><span class="normal">BMI</span> <span class="identifier">copyLines</span>           <span class="comment">;   goto copyLines; // Found a line         </span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; ++N;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">scanLine</span>            <span class="comment">; goto scanLine;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TBA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; if (--B >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">scanLine</span>            <span class="comment">;   goto scanLine;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>As <a href="#tetrominoes-table.svg">visualized above</a>, the <span class="mono">tetrominoes</span> table centers pieces in 5&times;5 matrices, none of which contain solid cells in its bottom row. This means, the handler only needs to check rows in the range <span class="nowrap"><span class="serif">[ </span><span class="mono">tetrominoY&minus;2</span>, <span class="mono">tetrominoY+1</span><span class="serif"> ]</span></span> for lines. To do so, it loops backwards over that range, using <span class="mono">i</span> as the loop index.</p>

<p><span class="mono">origin</span> is a pointer to the row to be checked. The handler initializes it to the index of row <span class="mono">tetrominoY+1</span>'s first element. At the end of each iteration, if handler did not find a line, it moves <span class="mono">origin</span> to the next row by decrementing it by <span class="mono">PLAYFIELD_WIDTH</span>. However, if the handler found a line, it shifts all the rows above the line downward. In that case, the handler does not decrement <span class="mono">origin</span> because the row that shifted into the cleared line is the next row to be checked.</p> 

<p>As previously mentioned, the handler does not shift the empty rows above the pile because empty space looks the same shifted or not. The first row above the pile guaranteed to be completed empty is either <span class="nowrap">row <span class="mono">minY&minus;3</span></span> or <span class="mono">0</span>, whichever is larger. In yet another example of self-modifying code, the handler assigns the byte at <span class="mono">minN+1</span> to the index of the last element of that row.</p>

<p>In the inner loop on <span class="nowrap">lines 434&ndash;459</span>, the handler examines a row, including <span class="nowrap">column 10</span>. If the handler detects an empty cell, it breaks out of the loop, and it decrements <span class="mono">origin</span> as described above. If it does not detect any empty cells, then the handler discovered a line, and it runs the following code to clear the line.</p>

<pre class="code" style="counter-increment: step 460;">
<span class="line"><span class="label">copyLines:</span>              <span class="comment">; // Clear line by copying down the lines above it</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N -= PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">TAM</span>                     <span class="comment">; M = *MN;</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N += PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">TMA</span>                     <span class="comment">; A = M;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span></span>
<span class="line"><span class="normal">TBM</span>                     <span class="comment">; M = 0;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="label">minN:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span>                  <span class="comment">; *** self-modifying code [minN+1] ***</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (--N != *(minN+1)) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">copyLines</span>           <span class="comment">;   goto copyLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">09</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N = 9;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="label">clearTopLine:</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; *MN = CELL_EMPTY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; if (--N >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">clearTopLine</span>        <span class="comment">;   goto clearTopLine;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++minY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">continueClear</span>       <span class="comment">; goto continueClear;</span></span>
<span class="line"></span>
<span class="line"><span class="label">continueClearLines:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin -= PLAYFIELD_WIDTH;</span></span>
<span class="line"></span>
<span class="line"><span class="label">continueClear:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; if (--i >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">clearLinesLoop</span>      <span class="comment">;   goto clearLinesLoop;</span></span>
<span class="line">                        <span class="comment">; } else {</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">spawn</span>               <span class="comment">;   goto spawn;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>At the start of this snippet, <span class="mono">N</span> contains the index of the last element of the line to be cleared.</p>

<p>In the inner loop on <span class="nowrap">lines 461&ndash;483</span>, the handler copies the nonempty rows above the line down by one row. The loop is equivalent to the following pseudocode.</p>

<pre class="pseudocode2">
<span class="line">M = 0;</span>
<span class="line">do {</span>
<span class="line">  *MN = *(MN - PLAYFIELD_WIDTH);</span>
<span class="line">} while (--N != *(minN+1));</span>
</pre>

<p>In the inner loop on <span class="nowrap">lines 484&ndash;494</span>, the handler fills <span class="nowrap">row 0</span> with empty cells, except for <span class="nowrap">column 10</span>. The loop is necessary for the rare case that a tetromino locks into the vanish zone.</p>

<p>The handler increments <span class="mono">minY</span> by one because clearing a line reduces the height of the pile by that amount.</p> 

<p>At the end of the outer loop, the handler decrements <span class="mono">i</span> by one, and if it did not find a line, it decrements <span class="mono">origin</span> by <span class="mono">PLAYFIELD_WIDTH</span>.</p>

<p>The only remaining code is the definition of the <span class="mono">drawOrTestTetromino</span> subroutine:</p>

<pre class="code" style="counter-increment: step 518;">
<span class="line"><span class="label">drawOrTestTetromino:</span> <span class="comment">; ---------------------------------------------------------------------------------------</span></span>
<span class="line"><span class="comment">; drawOrTest        - 22 = draw, 23 = test</span></span>
<span class="line"><span class="comment">; drawCell+1        - cell to draw</span></span>
<span class="line"><span class="comment">;</span></span>
<span class="line"><span class="comment">; tetrominoType     - type</span></span>
<span class="line"><span class="comment">; tetrominoRotation - rotation</span></span>
<span class="line"><span class="comment">; tetrominoX        - x</span></span>
<span class="line"><span class="comment">; tetrominoY        - y</span></span>
<span class="line"><span class="comment">;</span></span>
<span class="line"><span class="comment">; z: 0 = some solid, 1 = all empty</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">03</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; i = 3; // Loop 4 times, once for each tetromino block</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoX</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin = PLAYFIELD_WIDTH * tetrominoY + tetrominoX;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS4</span></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoRotation</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS2</span></span>
<span class="line"><span class="normal">ADD</span>                     <span class="comment">; A = 16 * tetrominoType + 4 * tetrominoRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoesIndex</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetrominoesIndex = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDB</span>                     <span class="comment">; B = origin;</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawLoop:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoes</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawOrTest:</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">drawCell</span>            <span class="comment">; *** self-modifying code [BNE = draw, BEQ = test] ***</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (playfield[tetrominoes[tetrominoesIndex] + origin] != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">endDrawLoop</span>         <span class="comment">;   goto endDrawLoop;</span></span>
<span class="line">                        <span class="comment">; } else {</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">incDrawLoop</span>         <span class="comment">;   goto incDrawLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawCell:</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">00</span>                  <span class="comment">; *** self-modifying code [ 00 = empty; otherwise solid ] ***</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; playfield[tetrominoes[tetrominoesIndex] + origin] = *(drawCell+1);</span></span>
<span class="line"></span>
<span class="line"><span class="label">incDrawLoop:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (i == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">endDrawLoop</span>         <span class="comment">;   goto endDrawLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --i;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetrominoesIndex</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; A = ++tetrominoesIndex;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">drawLoop</span>            <span class="comment">; goto drawLoop;</span></span>
<span class="line"></span>
<span class="line"><span class="label">endDrawLoop:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RTS</span>                     <span class="comment">; return; // -------------------------------------------------------------------------</span></span>
</pre>

<p>The program prepares three variables on <span class="nowrap">lines 530&ndash;559</span>. It assigns <span class="mono">origin</span> to the playfield index corresponding to the center of the falling tetromino. It assigns <span class="mono">tetrominoesIndex</span> to the index of the first element of the <span class="mono">tetrominoes</span> table row associated with the type and orientation of the falling tetromino. And it assigns <span class="mono">i</span> to three to make the loop on <span class="nowrap">lines 561&ndash;598</span> iterate over the four tetromino blocks.</p> 

<p>When the program stores <span class="mono">ACTION_DRAW</span> or <span class="mono">ACTION_TEST</span> to <span class="mono">drawOrTest</span>, it changes the instruction on <span class="nowrap">line 571</span> to <span class="mono">BNE</span> or <span class="mono">BEQ</span>, respectively. When the program arrives at that line, the zero flag is reset due to the <span class="mono">ADD</span> instruction on <span class="nowrap">line 566</span>. That <span class="mono">ADD</span> cannot set the zero flag because the player cannot to move the falling tetromino into the upper-right corner of the vanish zone. Consequentially, <span class="mono">ACTION_TEST</span> directs the program to <span class="nowrap">lines 573&ndash;577</span>, and <span class="mono">ACTION_DRAW</span> directs the program to <span class="nowrap">lines 580&ndash;581</span>.</p> 

<p>In both pathways, the program accesses the playfield byte at <span class="nowrap mono">tetrominoes[tetrominoesIndex] + origin</span>, the center of the falling tetromino offset by the relative location of one of its blocks. In the <span class="mono">ACTION_TEST</span> pathway, the program reads from that location. If a read byte is a solid cell (nonzero), the program returns from the subroutine with the zero flag reset. Otherwise, if all read bytes are empty cells (all zeros), the program returns from the subroutine with the zero flag set, thanks to <span class="nowrap">line 585</span>. In the <span class="mono">ACTION_DRAW</span> pathway, the program writes the value at <span class="mono">drawCell+1</span> to that location.</p>

<p>The subroutine employs self-modifying code twice because the alternative&mdash;moving values in and out of memory&mdash;imposes complexity and a performance cost.</p>

<p>At the end of the loop, the program decrements <span class="mono">i</span> by one, and it increments <span class="mono">tetrominoesIndex</span> by one.</p>

<h2 id="simulator">Simulator</h2>

<p>The assembler for the general-purpose computer converts an assembly language program into a binary file. It consists of a <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">lexer</a> and a <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)" target="_blank">code generator</a>. As the lexer translates the program into a sequence of tokens, it builds a table that maps constants to values and labels to addresses. The table enables the code generator to substitute symbolic operands with their numerical equivalents as it transforms the tokens into machine code bytes. The code generator appends two final bytes to the binary file containing the programâ€™s <span class="nowrap">entry point</span> address.</p>

<p>A separate process generates <span class="mono">CYCLE_LEFT</span> and <span class="mono">CYCLE_RIGHT</span> <span class="nowrap">MC programs</span> based on the binary fileâ€™s size.</p>

<p>The simulator for the general-purpose computer loads the binary file (the starting memory state), the generated and hand coded <span class="nowrap">MC programs</span> (the microcode), and the <span class="nowrap">TS programs</span> (the logic circuits). It writes the machine code bytes onto the floor of an empty playfield, followed by two padding zeros, and the <span class="nowrap">21-byte</span> state register. It initializes the state register to all zeros, except for <span class="mono">a</span> and <span class="mono">P</span>, to which it assigns the maximum address and the <span class="nowrap">entry point</span> address, respectively.</p>

<p>For the example program, the assembler produces a binary file containing <span class="nowrap">1,021 bytes</span>. The simulator loads the file, and it allocates a playfield with:</p>

<p><span class="nowrap">(1,021 bytes &minus; 2 bytes + 2 bytes + 21 bytes) &times; 8 bits/byte &times; 10 columns/bit = 83,360 columns.</span></p>

<p>The simulator pops open a window to display the programâ€™s graphics and to listen for keyboard events. Then it enters an infinite loop, where it perpetually alternates between actualizations of <span class="mono">CYCLE_LEFT</span> and <span class="mono">CYCLE_RIGHT</span>. At the end of each cycle, the simulator examines the surface of the pile in the columns corresponding to memory address <span class="mono">00FD</span>, the location of the <span class="mono">drawFrame</span> flag. When the flag indicates a frame is ready for display, the simulator copies the visible playfield from the pile to the window, and it copies the key statuses from the window to the pile.</p>

<p>Instead of executing every <span class="nowrap">IL instruction</span>, the simulator employs a <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">memoized</a> algorithm that computes the long-term evolution of the pile. On startup, the algorithm builds the structures described by the <span class="nowrap">TS programs</span> on a private playfield with all possible inputs, and it records the outputs into a set of lookup tables. The tables allow the algorithm to emulate the effects of building structures without actually building them. For example, here are the swap circuit for all possible inputs:</p>

<object id="swap.svg-2" data="swap.svg" type="image/svg+xml" class="diagram">swap</object>

<p>Rather than manipulating all those pieces, the algorithm inspects the input cells, it performs a table lookup, and it assigns the output cells, omitting everything in between:</p>

<object id="swap-memoized.svg" data="swap-memoized.svg" type="image/svg+xml" class="diagram">swap memoized</object>

<p>Despite their seeming levitation, the output cells support structures built on top of them as if the swap circuit was really there.</p>

<p>To efficiently compute the lookup tables, the algorithm orders the <span class="nowrap">TS programs</span> into a dependency tree. It starts from those that have no dependencies, and it works outward through the tree. That order enables the algorithm to response to a dependency with a lookup in a table it just computed. And it uses the looked up value to skip the build via the technique above. To finish even faster, the algorithm parallelizes the process.</p>

<p>The algorithm does not compute lookup tables for <a href="#intermediate-gates">intermediate gates</a> because the side effects of leaking tetrominoes cannot be determined in advance. However, the algorithm does compute lookup tables for circuits that employ intermediate gates because those circuits internally catch the leaked tetrominoes.</p>

<p>Rather than accommodating an ever-taller rectangular pile, the algorithm only keeps track of the pile's surface. For each <span class="nowrap">MC instruction</span>, the algorithm reads input from the surface, it performs a table lookup, and it stores output back to surface, overwriting what it just read. The effect is same as if the algorithm grew the pile, and it truncated everything below the surface.</p>

<p>The algorithm implements the surface as a one-dimensional byte array, <span class="mono">s</span>, where each byte contains the data normally spaced across eighty columns of the <span class="nowrap">top-two</span> rows of the pile. For each <span class="nowrap">MC instruction</span>, <span class="mono nowrap">f x</span>, where <span class="mono">f</span> is the name of an <span class="nowrap"><span class="mono">n</span>-byte</span> function, the algorithm applies <span class="mono">f</span>'s lookup table, <span class="mono">LUT<span class="sub3">f</span></span>, to <span class="nowrap"><span class="mono">n</span> consecutive</span> bytes of the surface, starting at <span class="nowrap">index <span class="mono">x</span></span>:</p>

<p><span class="nowrap mono">s<span class="sub2">x</span>&nldr;s<span class="sub2">x+n&minus;1</span> &larr; LUT<span class="sub3">f</span>(s<span class="sub2">x</span>&nldr;s<span class="sub2">x+n&minus;1</span>)</span></p>

<p>That read-lookup-write operation is performant, but an <span class="nowrap"><span class="mono">n</span>-byte</span> function requires a lookup table of size <span class="nowrap"><span class="mono">(2<span class="sup3">8</span>)<span class="sup3">n</span></span> bytes</span>; i.e., <span class="nowrap">1-,</span> <span class="nowrap">2-,</span> and <span class="nowrap">3-byte</span> functions require <span class="nowrap">256 B</span>, <span class="nowrap">64 KiB</span>, and <span class="nowrap">16 MiB</span> tables, respectively. However, as the algorithm computes a table for a <span class="nowrap">3-byte</span> function, it monitors the output for a byte constrained to <span class="mono">0</span> and <span class="mono">1</span>. If it finds such a byte, it assumes the corresponding input parameter is a Boolean, effectively reducing a <span class="nowrap">24-bit</span> function to a <span class="nowrap">17-bit</span> function. In the general case, that is a risky assumption. But in this particular situation, the first or third parameter of every <span class="nowrap">3-byte</span> function is a Boolean, enabling the algorithm to safely cache them in <span class="nowrap">128 KiB</span> tables.</p>

<p>The simulatorâ€™s speed&mdash;the number of machines cycles it simulates per unit time&mdash;is proportional to the total operations the machine carries out per cycle, or more specifically, to the lengthsÂ of <span class="mono">CYCLE_LEFT</span> and <span class="mono">CYCLE_RIGHT</span>. Since a process generates those <span class="nowrap">MC programs</span> based on the machine code size, the program will run faster if it can be made smaller.</p>

<p>The programâ€™s playfield data region consumes nearly a quarter of the program's size at <span class="nowrap">253 bytes</span>. If the program adopts boundary checks, it eliminates the need for solid <span class="nowrap">row 22</span> and solid <span class="nowrap">column 10</span> (the floor and walls, respectively), as well as <span class="nowrap">rows 0&ndash;1</span> (the vanish zone). That brings the size down to <span class="nowrap">200 bytes</span>. If the program packs each playfield cell into a nibble rather than a full byte, then it halves the region size. If the program reduces the palette to two colors, then each cell fits in a single bit, and the region drops to a mere <span class="nowrap">25 bytes</span>, less than a tenth of its current size. </p>

<p>However, due to the computer's minimal instruction set, the additional code required to support an alternate playfield representation may increase the program size to the point that it negates the benefit of a smaller data region. Worse, such a change could decrease the frame rate because it requires extra code in the <span class="mono">drawOrTestTetromino</span> loop. At five subroutine calls per frame and four blocks per tetromino, the program amplifies the computational cost of anything in the loop twenty-fold.</p>

<p>On the other hand, if the program employed a smaller playfield data region, it would likely speed up line clears. As revealed in the video below, there is a noticeable delay when clearing lines due to the amount of data copied. But if the program packed multiple cells into each byte, then it would copy cells in parallel, significantly hastening the process.</p>

<p>[ TODO VIDEO OF LINE CLEARS ]</p>

<p>At <span class="nowrap">112 bytes</span>, the <span class="mono">tetrominoes</span> table is another possible target for program size reduction. Nearly a third of its rows are duplicates. Deleting them would save 36 bytes. However, the indirection table required to compensate for the missing rows demands <span class="nowrap">28 bytes</span>. And indirection increases access time.</p>

<p>The program prioritizes simplicity over space. This text leaves the optimal balance between data, instruction path lengths, and program size that maximizes the frame rate to future researchers.</p>

<h1 id="applications">Applications</h1>

<p>This section covers the applications developed for this project.</p>

<h2 id="repository">Overview</h2>

<p>The appsÂ are written in <a href="https://www.java.com/" target="_blank">Java</a>. The <a href="https://en.wikipedia.org/wiki/Swing_(Java)" target="_blank">Swing</a> user interfaces were created withÂ <a href="https://netbeans.apache.org/kb/docs/java/quickstart-gui.html" target="_blank">NetBeans IDE GUI Builder</a>.</p>

<p>The files reside in:</p>

<p><a href="https://github.com/meatfighter/tetromino-computer" target="_blank">https://github.com/meatfighter/tetromino-computer</a></p>

<p>Here is a summary of the repository's contents:</p>

<table class="borderless">
<tr><th class="borderless">Directory</th><th class="borderless">Description</th></tr>
<tr><td class="separator"> </td><td class="separator"> </td></tr>
<tr><td class="mono2">code</td><td class="borderless">Non-Java sources and binaries</td></tr>
<tr><td class="mono2">code/asm</td><td class="borderless">Assembly language programs</td></tr>
<tr><td class="mono2">code/bin</td><td class="borderless">Machine code binaries</td></tr>
<tr><td class="mono2">code/luts</td><td class="borderless">Lookup tables</td></tr>
<tr><td class="mono2">code/mc</td><td class="borderless">Memory code programs</td></tr>
<tr><td class="mono2">code/ts</td><td class="borderless">TetrisScript programs</td></tr>
<tr><td class="mono2">code/ts/examples</td><td class="borderless">Samples for this text</td></tr>
<tr><td class="mono2">code/ts/functions</td><td class="borderless">Arithmetic and logic functions</td></tr>
<tr><td class="mono2">code/ts/gates</td><td class="borderless">Logic gates</td></tr>
<tr><td class="mono2">code/ts/gates/intermediate</td><td class="borderless">Intermediate gates</td></tr>
<tr><td class="mono2">code/ts/gates/ordinary</td><td class="borderless">Ordinary gates</td></tr>
<tr><td class="mono2">code/ts/logic</td><td class="borderless">Combinational logic</td></tr>
<tr><td class="separator"> </td><td class="separator"> </td></tr>

<tr><td class="mono2">src</td><td class="borderless">Java source</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/asm</td><td class="borderless">Assembler</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/gpc</td><td class="borderless">General-purpose computer</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/sim</td><td class="borderless">Tetrominoes and playfield simulator</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/mc</td><td class="borderless">Memory code parser, and cycle programs generator</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/ts</td><td class="borderless">TetrisScript parser and tester, and lookup tables generator</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/tse</td><td class="borderless">TetrisScript Editor</td></tr>
<tr><td class="mono2">src/main/java/tetrominocomputer/util</td><td class="borderless">Utilities</td></tr>
<tr><td class="separator"> </td><td class="separator"> </td></tr>

<tr><td class="mono2">target</td><td class="borderless">Executables</td></tr>
<tr><td class="separator"> </td><td class="separator"> </td></tr>

<tr><td class="mono2">web</td><td class="borderless">This text</td></tr>
</table>

<p><a href="https://maven.apache.org/" target="_blank">Maven</a> follows the supplied <span class="mono">pom.xml</span> to build and package <span class="mono">src</span> into a single jar: <span class="mono">target/tetromino-computer.jar</span></p>

<p>To run an individual app, <a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository" target="_blank">clone the repo</a>, and execute the jar in the local repo's root:</p>

<p><span class="command">java <span class="nowrap">-cp target/tetromino-computer.jar</span> <span class="nowrap">[ app class name ]</span> <span class="nowrap">[[ args ]]</span></span></p>

<p>The subsequent sections detail the app class names and their expected arguments.</p>

<p>The code wasÂ developed and tested on aÂ <span class="nowrap">Dell XPS 8930</span> desktop featuring an <span class="nowrap">i7-8700K CPU</span>, <span class="nowrap">64 GiB</span> of RAM, and <span class="nowrap">Windows 10 Pro</span>&mdash;a 5-years-old machine atÂ the time of this writing.</p>

<p>TODO JAVA VERSION</p>

<h2 id="tetrominoscript-editor">TetrominoScript Editor</h2>

<p><span class="nowrap">TetrominoScript Editor (TSE)</span> is a tool for visually designing digital components and combinational logic circuits. It automatically generates a <span class="nowrap">TS program</span> as the user drags and drops tetrominoes and previously defined components into place. If the user edits the <span class="nowrap">TS program</span>, TSE provides immediate feedback of the changes.</p>

<p>TSE is also a testing tool. It reveals how the circuit responds to user entered inputs. Plus, it accepts a snippet of <span class="nowrap">JavaScript (JS)</span> that specifies the expected outputs. Upon request, it compares the JS values against the actual outputs for all possible inputs.</p>

<p>As shown below, TSE is a single-window application segmented into regions. The largest region is the playfield, the grid where the user assembles circuits. On the left, from top-to-bottom, are the <span class="nowrap">TS program</span>, the <span class="nowrap">JS snippet</span>, and the output messages region.</p>

<p><img id="tse-swap.png" class="centered" src="tse-swap.png" /></p>

<p>The toolbar provides test and insert controls:</p>

<ul>
  <li>Input field - Holds an entered binary value.</li>
  <li>Run button - Executes the <span class="nowrap">TS program</span> with the entered value. <span class="menu">Run > Run</span> and <span class="keys">F6</span> do the same.</li>
  <li>Components combo box - Lists all previously defined components.</li>
  <li>Add button - Selects a listed component. Clicking on a grid cell will insert it.</li>
  <li>Tetrominoes buttons - Selects a tetromino in one of the nineteen possible orientations. Clicking on a grid cell will insert it.</li>
</ul>

<p><img id="tse-toolbar.png" class="centered" src="tse-toolbar.png" /></p>

<p>The status bar provides grid controls:</p>

<ul>
  <li>Center button - Moves the origin to bottom-center by bottoming the vertical scrollbar and centering the horizontal scrollbar.</li>
  <li>Rendering depth spinner - Sets the displayed detail level.</li>
  <li>Width and height spinners - Sets the grid dimensions.</li>
  <li>Zoom spinner - Sets the grid cell size. Turning the <span class="keys">scroll wheel</span> does the same.</li>
  <li>Cursor coordinates - Indicates the cell at which the mouse cursor points.</li>
</ul>

<p><img id="tse-status-bar.png" class="centered" src="tse-status-bar.png" /></p>

<p>To demonstrate the features of TSE, the following steps explain how to construct a <span class="nowrap">NAND gate</span>.</p>  

<p>Select <span class="menu">File > New...</span> or press <span class="keys">Ctrl+N</span>:</p>

<p><img id="tse-file-new.png" class="centered" src="tse-file-new.png" /></p>

<p>In the New file chooser, navigate to <span class="mono">code/ts/examples</span>, enter <span class="mono">nandExample.t</span>, and hit <span class="menu">Save</span>:</p>

<p><img id="tse-new-file-chooser.png" class="centered" src="tse-new-file-chooser.png" /></p>

<p>The window regions reset and the named component appears in the title bar:</p>

<p><img id="tse-new-result.png" class="centered" src="tse-new-result.png" /></p>

<p>Turn the <span class="keys">scroll wheel</span> to adjust the grid cell size to 32:</p>

<p><img id="tse-zoom-32.png" class="centered" src="tse-zoom-32.png" /></p>

<p>Type <span class="mono nowrap">&ldquo;in a&rdquo;</span> into the <span class="nowrap">TS program</span> region:</p>

<p><img id="tse-in-a.png" class="centered" src="tse-in-a.png" /></p>

<p>Click on grid cell <span class="mono nowrap">&minus;2:0</span>:</p>

<p><img id="tse-cell-minus-two-zero.png" class="centered" src="tse-cell-minus-two-zero.png" /></p>

<p>That transfers the cell coordinates to the <span class="nowrap">TS program</span>:</p>

<p><img id="tse-in-a-coordinates.png" class="centered" src="tse-in-a-coordinates.png" /></p>

<p>Press Enter. Type <span class="mono nowrap">&ldquo;in b&rdquo;</span> and click on cell <span class="mono nowrap">1:0</span>:</p>

<p><img id="tse-in-b.png" class="centered" src="tse-in-b.png" /></p>

<p>Click on the input field and type <span class="mono nowrap">&ldquo;01&rdquo;</span>:</p>

<p><img id="tse-input-01.png" class="centered" src="tse-input-01.png" /></p>

<p>Press the <span class="keys">Run</span> button.</p>

<p>Input nodes <span class="mono">a</span> and <span class="mono">b</span> appear in the playfield with the specified values:</p>

<p><img id="tse-nodes.png" class="centered" src="tse-nodes.png" /></p>

<p>In the <span class="nowrap">TS program</span> region, make sure the cursor is positioned at the end of <span class="nowrap">line 2</span> or on the start of <span class="nowrap">line 3</span>. Then click on the component combo box and type <span class="mono">&ldquo;notLeft&rdquo;</span>:</p>

<p><img id="tse-notleft-select.png" class="centered" src="tse-notleft-select.png" /></p>

<p>Press the <span class="keys">Add</span> button and move the mouse cursor into the playfield:</p>

<p><img id="tse-notleft-drag.png" class="centered" src="tse-notleft-drag.png" /></p>

<h2 id="tetrominoscript-editor">TetrominoScript Tester</h2>

<p>...</p>

<h2 id="lookup-table-generator">Lookup Table Generator</h2>

<p><span class="command">java <span class="nowrap">-cp target/tetromino-computer.jar</span> tetrominocomputer.ts.LutsGenerator <span class="nowrap">-t [ TS programs dir ]</span> <span class="nowrap">-l [ lookup tables dir ]</span></span></p>

<p><span class="command">java <span class="nowrap">-cp target/tetromino-computer.jar</span> tetrominocomputer.ts.LutsGenerator <span class="nowrap">-t code/ts</span> <span class="nowrap">-l code/luts</span></span></p>

<h2 id="assembler">Assembler</h2>

<p>The Assembler translates a program written in the general-purpose computerâ€™s assembly languageÂ into a machine code binary. To run it from the command-line, enter the following.</p>

<p><span class="command">java <span class="nowrap">-cp target/tetromino-computer.jar</span> tetrominocomputer.asm.Assembler <span class="nowrap">[ asm source filename ]</span> <span class="nowrap">-o [ binary output filename ]</span></span></p>

<p>The arguments are optional. They default to:</p>

<p><span class="command">java <span class="nowrap">-cp target/tetromino-computer.jar</span> tetrominocomputer.asm.Assembler code/asm/example.asm <span class="nowrap">-o code/bin/example.bin</span></span></p>

<h2 id="cycle-programs-generator">Cycle Programs Generator</h2>

<p>The Cycle Programs Generator produces the general-purpose computer's left and right cycle MC programs based on the size of the machine code binary. To run it from the command-line, enter the following.</p>

<p><span class="command">java -cp target/tetromino-computer.jar tetrominocomputer.mc.CycleProgramsGenerator <span class="nowrap">-b [ binary filename ]</span> <span class="nowrap">-l [ cycle left filename]</span> <span class="nowrap">-r [ cycle right filename ]</span></span></p>

<p>The arguments are optional. They default to:</p>

<p><span class="command">java -cp target/tetromino-computer.jar tetrominocomputer.mc.CycleProgramsGenerator <span class="nowrap">-b code/bin/example.bin</span> <span class="nowrap">-l code/mc/CYCLE_LEFT.mc</span> <span class="nowrap">-r code/mc/CYCLE_RIGHT.mc</span></span></p>

<h2 id="cycle-programs-generator">General-purpose Computer</h2>

<p> ... </p>

</body>

</html>
