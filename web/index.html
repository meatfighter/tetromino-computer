<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">

<head>
<title>Tetris is Turing-complete</title>
<link rel="stylesheet" href="style.css?v=2022-04-21" type="text/css"/>
<link rel="icon" href="favicon.svg" type="image/svg+xml"/>
<link rel="icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="shortcut icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="mask-icon" href="mask-icon.svg" color="#000000"/>
<link rel="apple-touch-icon" href="apple-touch-icon.png"/>
<link rel="manifest" href="manifest.json"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Bentham&family=Open+Sans&family=Source+Code+Pro&family=Source+Serif+Pro&display=swap" rel="stylesheet"/>
<meta name="theme-color" content="#FFFFFF"/>
<meta name="date" content="2022-04-21"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

<body>

<p class="title">Tetris is Turing-complete</p>  
<p>This article presents a method for embedding a programmable, general-purpose, digital computer into Tetris. The capabilities and performance of an implementation of such a computer are demonstrated by running Tetris on Tetris.</p>

<h1 id="preliminaries">Preliminaries</h1>

<p>The <span class="term">playfield</span> is the grid of square cells where Tetris is played. The standard playfield has 20 visible rows and 10 columns, but the dimensions are arbitrary.</p>

<object data="standard-playfield.svg" type="image/svg+xml" class="diagram">Standard Playfield</object>

<p>Each playfield cell is in one of two states: empty or solid.</p>

<p><span class="term">Tetriminos</span>&mdash;the falling pieces&mdash;consist four solid cells painted any color. The seven Tetriminos have single-character, shape-based names.</p>

<object data="seven-tetriminos.svg" type="image/svg+xml" class="diagram">Seven Tetriminos</object>

<p>A <span class="term">rotation</span> system describes how Tetriminos rotate in relation to the surrounding cells and the playfield boundaries. The method employees the right-handed <a href="https://tetris.wiki/Nintendo_Rotation_System" target="_blank">Nintendo Rotation System</a> (NRS) due to its simplicity, but <a href="https://tetris.wiki/Category:Rotation_systems" target="_blank">various rotation systems</a> exist and any of them could be adapted.</p>

<p>NRS centers each Tetrimino in a 5&times;5 matrix and rotates them 90&deg; about that center. Of the 24 possible orientations, it uses only 19.</p>

<object data="orientation-table.svg" type="image/svg+xml" class="diagram">Orientation Table</object>

<p>The left-most column comprises the spawn orientations (the way the pieces initially appear). The steps of clockwise rotation span left-to-right.</p>

<p>The mnemonics above each orientation consist of the piece type concatenated with the first letter of &ldquo;down&rdquo;, &ldquo;left&rdquo;, &ldquo;up&rdquo;, &ldquo;right&rdquo;, &ldquo;horizontal&rdquo;, &ldquo;vertical&rdquo;, or nothing for O.</p>

<p>A <span class="term">move</span> is a 90&deg; rotation or a 1-cell translation of the piece in play. The following terms apply to translation.</p>

<ul>
    <li>A <span class="term">shift</span> is a horizontal translation.</li>
    <li>A <span class="term">drop</span> is a downward translation.
        <ul>
            <li>A <span class="term">soft drop</span> is a player-controlled, 1-cell drop.</li>
            <li>A <span class="term">hard drop</span> is a meta-move that forces the piece as far down as it can go and <span class="term">locks</span> it into place. It is operationally-equivalent to repeated soft drops.</li>
            <li>A <span class="term">gravity drop</span> is an automatic, 1-cell drop triggered by the <span class="term">fall timer</span>.</li>
        </ul>
    </li>
</ul>

<p>A move is preceded by a <span class="term">request to move</span>. Per NRS, the request is granted iff all four cells of the transformed Tetrimino are empty and are within the bounds of the playfield. If the fall timer’s request for a gravity drop is denied, the piece locks and the next piece spawns.</p>

<p>Spawning involves a <span class="term">randomizer</span>, the mechanism that determines the sequence of pieces presented to the player. Any randomizer guaranteed to eventually produce all seven Tetriminos from any point in the sequence will work with the method.</p>

<h1 id="method-overview">Method Overview</h1>

<p>On an infinite playfield&mdash;bounded only by the floor&mdash;an input data set is encoded into the cells of the <span class="nowrap">bottom-2</span> rows. Tetriminos are dropped onto those cells, forming a structure logically-equivalent to a Boolean circuit. From the <span class="nowrap">top-2</span> rows of that structure, an output data set is decoded.</p>

<object data="boolean-circuit.svg" type="image/svg+xml" class="diagram">Boolean Circuit</object>

<p>The output rows serve as input rows of a structure built above it and the process can be repeated indefinitely. The effect is a state machine where the data rows are states and the structures are transition functions.</p>

<object data="state-machine.svg" type="image/svg+xml" class="diagram">State Machine</object>

<p>A construction exists where the data capacity of a state always exceeds its predecessor. It is a means of building an abstract computing device with unbounded storage, a.k.a. a Turing machine.</p>

<h1 id="blindfolded-player">The Blindfolded Player</h1>

<p>Tetris requires a player. But if the player can see the playfield, then constructing a Turing machine is trivial. A sighted player can read input data, perform calculations via any mechanism, and drop pieces to write output data. In other words, it can make Tetris function like RAM.</p>

<p>To inhibit the player from contributing to calculations, it must play blindfolded. Input data, intermediate states, and output data must be inaccessible to the player. With that constraint, if the system composed of the player and the game processes information in the manor of a computer, then Tetris must be functioning as both RAM and a CPU.</p>

<h1 id="infinite-playfield">Infinite Playfield</h1>

<p>On an infinite playfield, completing a line requires infinite pieces and infinite time, neither of which the player can provide. Instead, the player deliberately grows the pile, building unbounded yet finite structures. And because lines are never cleared, the game always remains on the starting level (at the slowest drop speed).</p>

<p>Tetriminos spawn in column 0 at infinite height. Due to the nature of infinity, as a spawned piece falls, it never gets any closer to the floor regardless of the drop speed. In finite (though potentially vast) time, the player can shift the piece into any column. And once in position, it can hard drop to lock the piece into the surface of the pile.</p>

<p>The player can also perform a <span class="term">semihard drop</span>. It works like a hard drop, but instead of stopping when the piece can fall no further, it stops at a specified height. It is the only way to translate a piece from infinity to a finite distance above the floor.</p>

<h1 id="spawn-signal">Spawn Signal</h1>

<p>Since the player cannot see, the game signals when a spawn occurs. It reveals the randomly selected piece to the player, who responds with a timed sequence of requests to move it. If the playfield were empty, the game would satisfy every request and the player would know exactly where the piece is at any time. But the playfield is not empty. Existing pieces can interrupt a shift, as illustrated in the animation below; it shows where the blindfolded player expects a piece to be (left) and where it actually ends up (right).</p>

<object data="shift-interruption.svg" type="image/svg+xml" class="diagram">Shift Interruption</object>

<p>The same applies to gravity and soft drops:</p>

<object data="drop-interruption.svg" type="image/svg+xml" class="diagram">Drop Interruption</object>

<p>Since the spawn signal occurs after a piece locks, it could be abused to extract data out of the playfield, violating the concept of the blindfolded player. This is achieved by semihard dropping a piece into a column and observing how long it takes to lock, which is proportional to the height of the column. The entire surface of the pile could be probed.</p>

<p>To render such abuse ineffective, the method employees a version of Tetris that will not lock a piece until the player hard drops. The piece in play may rest indefinitely on a solid surface pending that explicit request to commit it to the pile.</p>

<h1 id="type-filtering">Type Filtering</h1>

<p>Building a structure logically-equivalent to a Boolean circuit requires placement of a specific sequence of Tetriminos. But the player cannot summon the pieces it needs into existence. Instead, it filters the provided pieces. When the randomizer spawns a piece that the player does not want, the player hard drops it onto an unbounded pile of discards in column &minus;2.</p>

<object data="discards-pile.svg" type="image/svg+xml" class="diagram">Discards Pile</object>

<p>Structures are made from the remaining pieces in columns &ge; 0. That infinite region&mdash;bounded on the bottom by the floor and on the left by the discards pile&mdash;serves as the workspace for building circuits.</p>

<h1 id="boolean-circuit-nodes">Boolean Circuit Nodes</h1>

<p>Nodes consist of pairs of vertically-adjacent cells. They can be in the following states.</p>

<object data="boolean-circuit-nodes.svg" type="image/svg+xml" class="diagram">Boolean Circuit Nodes</object>

<ul>
    <li><span class="mono">0</span> (false) &mdash; lower cell is solid, upper cell is empty.</li> 
    <li><span class="mono">1</span> (true) &mdash; upper cell is solid, lower cell is empty or solid.</li>  
    <li><span class="mono">?</span> (unassigned) &mdash; both cells are empty.</li>  
</ul>

<p>Nodes are composed of one or more pairs, all in the same state. Typically, a node is a contiguous, horizontal line of pairs, but not necessarily. The pairs of a node can be separated in space, even vertically separated. The image below shows one possible encoding of <span class="mono">01010</span>.</p>

<object data="encoding-01010.svg" type="image/svg+xml" class="diagram">01010</object>

<p>The right-most bit is stored in a noncontiguous node.</p>

<h1 id="tetrisscript">TetrisScript</h1>

<p>The player builds structures by executing <span class="term">TetrisScript</span>, a language that specifies where to put the pieces. It only has 3 instructions. The first consists of a mnemonic and a column index:</p>

<p class="definition">mnemonic x</p>

<p>It means:</p>

<ol>
    <li>Discard Tetriminos until the randomizer spawns the one specified by the mnemonic type.</li> 
    <li>Rotate the piece into the mnemonic orientation.</li>   
    <li>Shift the piece to column <span class="mono">x</span>.</li>   
    <li>Hard drop the piece to lock it into the pile.</li> 
</ol>

<p>The code below demonstrates this instruction type.</p>

<pre class="code">
<span class="filename">example1.t</span>
<span class="line"><span class="normal">td </span><span class="number">1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">5</span></span>
<span class="line"><span class="normal">zh </span><span class="number">9</span></span>
<span class="line"><span class="normal">o </span><span class="number">13</span></span>
<span class="line"><span class="normal">sh </span><span class="number">16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">20</span></span>
<span class="line"><span class="normal">ih </span><span class="number">25</span></span>
</pre>

<p>If the player carries out those instructions, the following structure results.</p>

<object data="example1.svg" type="image/svg+xml" class="diagram">example1</object>

<p>The second instruction type consists of a mnemonic, a column index, a row index, and a second column index:</p>

<p class="definition">mnemonic x1 y x2</p>

<p>It means:</p>

<ol>
    <li>Discard Tetriminos until the randomizer spawns the one specified by the mnemonic type.</li> 
    <li>Rotate the piece into the mnemonic orientation.</li>   
    <li>Shift the piece to column <span class="mono">x1</span>.</li>
    <li>Semihard drop the piece to row <span class="mono">y</span>.</li>
    <li>Shift the piece to column <span class="mono">x2</span>.</li>
    <li>Hard drop the piece to lock it into the pile.</li> 
</ol>

<p>If a gravity drop were to happen after step 4, but before step 5 finishes, it would corrupt the structure. To prevent that possibility, the player maintains a timer synchronized with the fall timer. The player uses it to semihard drop immediately after a gravity drop, maximizing the time to perform the shift to column <span class="mono">x2</span>. The horizontal distance between <span class="mono">x1</span> and <span class="mono">x2</span> is always tiny, guaranteeing the shift can occur in the period between gravity drops.</p>

<p>The following code demonstrates the second instruction type.</p>

<pre class="code">
<span class="filename">example2.t</span>
<span class="line"><span class="normal">td </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">jd </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">zh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">o </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ld </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1 15 2</span></span>
</pre>

<p>Those are the instructions for the structure below.</p>

<object data="example2.svg" type="image/svg+xml" class="diagram">example2</object>

<p>The third instruction type provides a way to compose complex structures from simpler ones. It consists of a structure name and a pair of coordinates:</p>

<p class="definition">structure x y</p>

<p>It means: build the specified structure at location <span class="mono">(x,y)</span>.</p>

<p>The following code demonstrates this instruction type by referencing the prior examples.</p>

<pre class="code">
<span class="filename">example3.t</span>
<span class="line"><span class="normal">example1 </span><span class="number">3 0</span></span>
<span class="line"><span class="normal">example2 </span><span class="number">14 2</span></span>
</pre>

<p>Column and row indices within the structures are offset by the provided coordinates, which makes the code above equivalent to:</p>

<pre class="code">
<span class="filename">example3Expanded.t</span>
<span class="line"><span class="comment"># example1 3 0</span></span>
<span class="line"><span class="normal">td </span><span class="number">4</span></span>
<span class="line"><span class="normal">jd </span><span class="number">8</span></span>
<span class="line"><span class="normal">zh </span><span class="number">12</span></span>
<span class="line"><span class="normal">o </span><span class="number">16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">19</span></span>
<span class="line"><span class="normal">ld </span><span class="number">23</span></span>
<span class="line"><span class="normal">ih </span><span class="number">28</span></span>
<span class="line"></span>
<span class="line"><span class="comment"># example2 14 2</span></span>
<span class="line"><span class="normal">td </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">jd </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">zh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">o </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ih </span><span class="number">15 17 16</span></span>
</pre>

<p>Lines 1 and 10 are comments.</p>

<p>Circular references are not allowed. The code must be fully expandable to mnemonic instructions.</p>

<p>Executing that code produces:</p>

<object data="example3.svg" type="image/svg+xml" class="diagram">example3</object>

<p>To make testing circuits easier, TetrisScript provides syntax for labeling nodes:</p>

<p class="definition">in/out name x y ...</p>

<p>The node type&mdash;<span class="mono">in</span> or <span class="mono">out</span>&mdash;is followed by the node name. The successive coordinates specify the node location. They refer to the lower-cell of the vertically-adjacent pairs. Spans can be indicated with range notation (<span class="mono">begin..end</span>). Multiple coordinate pairs/ranges can be provided for disjoint nodes.</p>

<p>The example below declares 5 input nodes.</p>

<pre class="code">
<span class="filename">nodes.t</span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">2..4 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">c </span><span class="number">6 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">d </span><span class="number">7 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">e </span><span class="number">9..10 0 12..13 0</span></span>
</pre>

<p>Node <span class="mono">a</span> is a single pair. Node <span class="mono">b</span> is a horizontal line consisting of 3 pairs. Nodes <span class="mono">c</span> and <span class="mono">d</span> are adjoining, single pairs. Node <span class="mono">e</span> is disjoint. They are illustrated below, where nodes <span class="mono">a</span>, <span class="mono">b</span>, <span class="mono">c</span>, <span class="mono">d</span>, and <span class="mono">e</span> are set to <span class="mono">0</span>, <span class="mono">1</span>, <span class="mono">0</span>, <span class="mono">1</span>, and <span class="mono">0</span>, respectively.</p>

<object data="nodes.svg" type="image/svg+xml" class="diagram">Nodes</object>

<h1 id="logic-gates">Logic Gates</h1>

<p>This section explains how to construct logic gates, structures that produce a single binary output from one or more binary inputs.</p>

<h2 id="buffer">Buffer</h2>

<p>A buffer is a single-input, binary <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a>. The output value is the input value, unchanged.</p>

<p>The code below realizes a buffer by dropping a vertically-oriented I-Tetrimino onto an input node.</p>

<pre class="code">
<span class="filename">buffer.t</span>
<span class="line"><span class="normal">iv </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 4</span></span>
</pre>

<p>The result for both input values is shown below.</p>

<object data="animated-buffer.svg" type="image/svg+xml" class="diagram">Animated Buffer</object>

<p>The cells of the output node mirror the cells of the input node. Any Tetrimino or any stack of Tetriminos can be used to copy data in this way.</p>

<h2 id="inverter-not">Inverter (NOT)</h2>

<p>An inverter is a single-input gate where the output is the <a href="https://en.wikipedia.org/wiki/Negation" target="_blank">complement</a> of the input.</p>

<p>The code below makes an inverter by sandwiching an O-Tetrimino between horizontal L-and-J-Tetriminos.</p>

<pre class="code">
<span class="filename">not.t</span>
<span class="line"><span class="normal">lu </span><span class="number">0</span></span>
<span class="line"><span class="normal">o </span><span class="number">0 4 1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-1..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>Note: Although workspace coordinates are always &ge; 0 due to the floor and the discards pile, structure definitions can use negative column values because the coordinates are relative to where the structure is built.</p>

<p>The follow animation shows what happens for both input values.</p>

<object data="animated-not.svg" type="image/svg+xml" class="diagram">Animated NOT</object>

<p>When the input is <span class="mono">0</span>, the L-Tetrimino lands low, which enables the O-Tetrimino to shift upon its protuberance. In turn, the J-Tetrimino lands high.</p>

<p>When the input is <span class="mono">1</span>, the L-Tetrimino lands high and acts a barrier that obstructs the horizontal movement of the O-Tetrimino. The result is a configuration where the J-Tetrimino lands low.</p>

<p>In both cases, the output is the opposite of the input.</p>

<p>A horizontally reflected version exists purely for aesthetics reasons. The image below shows <span class="mono">notLeft</span> (an alias for <span class="mono">not</span>) and its reflection, <span class="mono">notRight</span>.</p>

<object data="nots.svg" type="image/svg+xml" class="diagram">notLeft and notRight</object>

<h2 id="or">OR</h2>

<p>OR is a 2-input gate that performs <a href="https://en.wikipedia.org/wiki/Logical_disjunction" target="_blank">disjunction</a>. The output is <span class="mono">0</span> only when both inputs are <span class="mono">0</span>.</p>

<p>The code below creates an OR gate by dropping a single O-Tetrimino onto abutting input nodes.</p>

<pre class="code">
<span class="filename">or.t</span>
<span class="line"><span class="normal">o </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 2</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object data="or.svg" type="image/svg+xml" class="diagram">OR</object>

<p>The O-Tetrimino lands low unless one or both inputs is <span class="mono">1</span>.</p>

<h2 id="nor">NOR</h2>

<p>NOR is a 2-input gate that evaluates the <a href="https://en.wikipedia.org/wiki/Logical_NOR" target="_blank">joint denial</a>. The output is <span class="mono">1</span> only when both inputs are <span class="mono">0</span>. It is a <a href="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" target="_blank">universal gate</a> that can be combined to form any other logic gate.</p>

<p>The code below realizes a NOR gate by feeding 2 inputs into an inverter.</p>

<pre class="code">
<span class="filename">nor.t</span>
<span class="line"><span class="normal">not </span><span class="number">0 0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>The following image presents the outputs for all possible inputs.</p>

<object data="nor.svg" type="image/svg+xml" class="diagram">NOR</object>

<p>The L-Tetrimino operates as an OR gate, resulting in output opposite of OR.</p>

<h2 id="nand">NAND</h2>

<p>NAND is a 2-input gate that provides the complement of <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a>. The output is <span class="mono">0</span> only when both inputs are <span class="mono">1</span>. It is a universal gate that can be combined to form any other logic gate.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>: <span class="math"><span class="overline">AB</span> = <span class="overline">A</span> + <span class="overline">B</span></span>. The code below uses this equivalence. It realizes NAND as inverters feeding into an OR.</p>

<pre class="code">
<span class="filename">nand.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 6</span></span>
</pre>

<p>The follow image reveals the output for all possible inputs.</p>

<object data="nand.svg" type="image/svg+xml" class="diagram">NAND</object>

<p>The horizontal I-Tetrimino functions as an OR gate.</p>

<h2 id="and">AND</h2>

<p>AND is a 2-input gate that performs <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a>. The output is <span class="mono">1</span> only when both inputs are <span class="mono">1</span>.</p>

<p>The code below constructs AND from a NAND gate followed by an inverter.</p>

<pre class="code">
<span class="filename">and.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">0 5</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 10</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object data="and.svg" type="image/svg+xml" class="diagram">AND</object>

<p>The J-Tetrimino of the upper inverter functions as an OR gate.</p>

<h2 id="xor">XOR</h2>

<p>XOR is a 2-input gate that performs <a href="https://en.wikipedia.org/wiki/Exclusive_or" target="_blank">exclusive disjunction</a>. It outputs <span class="mono">1</span> only when both inputs are unequal.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">A &oplus; B<span></p>
      
<p><span class="math">= (A &ne; B)</p>      
      
<p><span class="math">= <span class="overline">A</span>B + A<span class="overline">B</span></p>      
     
<p><span class="math">= <span class="overline">A</span>A + <span class="overline">A</span>B + A<span class="overline">B</span> + B<span class="overline">B</span><span></p>
      
<p><span class="math">= <span class="overline">A</span>(A + B) + <span class="overline">B</span>(A + B)</p>  

<p><span class="math">= <span class="overline">A</span> <span class="overline">C</span> + <span class="overline">B</span> <span class="overline">C</span>, C = <span class="overline">A + B</span></p>  

<p><span class="math">= <span class="overline">A + C</span> + <span class="overline">B + C</span>, C = <span class="overline">A + B</span></span></p>

<p>That suggests the following construction of XOR from 3 NOR gates and an OR gate.</p>

<object data="xor-schematic.svg" type="image/svg+xml" class="diagram">XOR Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">xor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">3</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">2 5</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 11</span></span>
</pre>

<p><span class="mono">_norLeft</span> is a NOR gate composed of two O-Tetriminos. It is detailed in a later section.</p>

<p>Here are the results for all input combinations:</p>

<object data="xor.svg" type="image/svg+xml" class="diagram">XOR</object>

<p>The vertical I-Tetriminos and the L-and-J-Tetriminos resting on the O-Tetrimino act as wires. The bases of the inverters serve as OR gates, making them function as NORs. The horizontal I-Tetrimino at the top operates as an OR gate.</p>

<h2 id="xnor">XNOR</h2>

<p>XNOR is a 2-input gate that evaluates <a href="https://en.wikipedia.org/wiki/Logical_equality" target="_blank">equality</a>. The output is <span class="mono">1</span> only when both inputs are equal. It is the complement of XOR.</p>

<p>The code below composes XNOR from XOR followed by an inverter.</p>

<pre class="code">
<span class="filename">xnor.t</span>
<span class="line"><span class="normal">xor </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">0 11</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 16</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object data="xnor.svg" type="image/svg+xml" class="diagram">XNOR</object>

<h1 id="wires">Wires</h1>

<p>This section discusses <span class="term">wires</span>, the structures that transfer bits from one part of a circuit to another.</p>

<h2 id="fan-out">Fan-out</h2>

<p><span class="term">Fan-out</span> is the number of connections radiating from an output node. As illustrated in the animation below, lines of S-and-Z-Tetriminos enable unlimited fan-out.</p>

<object data="fan-out.svg" type="image/svg+xml" class="diagram">Fan-out</object>

<p>Rising staircases of horizontal I-Tetriminos can achieve the same.</p>

<h2 id="fan-in">Fan-in</h2>

<p>Wires that converge on a common node require a device to combine their signals, such as a multi-input OR gate. <span class="term">Fan-in</span> is the number of inputs of such a device. As demonstrated in the following animation, a line of Z-or-S-Tetriminos can provide unlimited fan-in. </p>

<object data="fan-in.svg" type="image/svg+xml" class="diagram">Fan-in</object>

<p>Alternatively, a tree of gates can merge a boundless number of inputs.</p>

<h2 id="crossing">Crossing</h2>

<p>The wires of a circuit can cross over each other without connecting in a 3-dimensional universe. But, on the 2-dimensional playfield, a cross requires a planar device that mutually exchanges 2 inputs. The device implements the <a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" target="_blank">XOR swap algorithm</a>. It stores the XOR of inputs <span class="math">A</span> and <span class="math">B</span> into a temporary variable, <span class="math">C</span>: </p>

<p><span class="math">C = A &oplus; B</span></p>

<p>Then it XORs the inputs with the temporary variable, which swaps them:</p>

<p><span class="math">A &oplus; C = A &oplus; A &oplus; B = B</span></p>

<p><span class="math">B &oplus; C = B &oplus; A &oplus; B = A</span></p>

<p>The algorithm suggests the following circuit.</p>

<object data="swap-schematic.svg" type="image/svg+xml" class="diagram">Swap Schematic</object>

<p>Since the circuit has no cross-overs and XOR is realizable, it achieves a planar swap.</p>

<p>In the code below, which is based on that schematic, the lower XOR gate is expanded into 3 NORs and a horizontal I-Tetrimino operating as an OR. The other pieces function as wires.</p>

<pre class="code">
<span class="filename">swap.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">ll </span><span class="number">-4</span></span>
<span class="line"><span class="normal">jr </span><span class="number">3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">5</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">_norRight </span><span class="number">3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">6 7</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">jd </span><span class="number">-6</span></span>
<span class="line"><span class="normal">ld </span><span class="number">5</span></span>
<span class="line"><span class="normal">xor </span><span class="number">-4 10</span></span>
<span class="line"><span class="normal">xor </span><span class="number">4 10</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i1 </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">i0 </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o1 </span><span class="number">-6..-3 21</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o0 </span><span class="number">2..5 21</span></span>
</pre>

<p><span class="mono">_norLeft</span> and <span class="mono">_norRight</span> are NOR gates composed of two O-Tetriminos. They are detailed in a later section.</p>

<p>Here are the results for all input combinations:</p>

<object data="swap.svg" type="image/svg+xml" class="diagram">Swap</object>

<p>The following animation makes repeated use of the swap circuit. It shows a diagonal wire crossing over multiple vertical wires.</p>

<object data="cross-seven.svg" type="image/svg+xml" class="diagram">Cross Seven</object>

<h2 id="multiplexing">Multiplexing</h2>

<p>A multiplexer is a controlled switch that channels one of the inputs to the output. The output of a 2-to-1 multiplexer is <span class="math">AS + B<span class="overline">S</span></span> where <span class="math">A</span> and <span class="math">B</span> are the inputs, and <span class="math">S</span> is the selector.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">AS + B<span class="overline">S</span></span></p>

<p><span class="math">= AS + <span class="high-overline"><span class="overline">B</span> + S</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">AS</span>(<span class="overline">B</span> + S)</span></span></p>

<p>That suggests the following construction from 2 NAND gates, an OR gate, and an inverter.</p>

<object data="mux-schematic.svg" type="image/svg+xml" class="diagram">Multiplexer Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">muxLeft.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-4</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-4 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-1 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">4 1</span></span>
<span class="line"><span class="normal">jr </span><span class="number">1</span></span>
<span class="line"><span class="normal">o </span><span class="number">2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">3</span></span>
<span class="line"><span class="normal">nand </span><span class="number">0 7</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">l </span><span class="number">-6..-3 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">s </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">r </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 13</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object data="mux.svg" type="image/svg+xml" class="diagram">Multiplexer</object>

<p>The selector (the center input) is <span class="mono">0</span> in the upper row and <span class="mono">1</span> in the lower row. As its name suggests, <span class="mono">muxLeft</span> outputs the left input when the selector is <span class="mono">1</span>. The horizontally reflected version, <span class="mono">muxRight</span>, outputs the right input when the selector is <span class="mono">1</span>.</p>

<h1 id="functions">Functions</h1>

<p>This section describes the arithmetic and logic functions created for the computer.</p>

<h2 id="interoperability">Interoperability</h2>

<p>The functions are stackable. Meaning, the output of any function can serve as the input of another. To make that work:</p>

<ul>
<li>Each function operates on an <span class="nowrap">8-bit</span>, <span class="nowrap">16-bit</span>, or <span class="nowrap">24-bit</span> value.</li>
<li>The number of input bits always equals the number of output bits.</li> 
<li>Each input node has a corresponding output node in the same column.</li> 
<li>The terminals are evenly spaced, 10 cells apart. That width provides room for wide components, such as the swap circuit. And a round, base-10 number makes measurements easier.</li>
</ul>

<h2 id="arrays">Arrays</h2>

<p>Some <span class="nowrap">16-bit</span> functions interpret the input value, <span class="math">V</span>, as an array of 2 bytes, <span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span>, where <span class="math">A</span> and <span class="math">B</span> are the high and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 652px">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top right green">B<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>Similarly, some <span class="nowrap">24-bit</span> functions interpret the input value, <span class="math">V</span>, as an array of 3 bytes, <span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span>, where <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> are the high, middle, and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top green">B<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>One <span class="nowrap">24-bit</span> function interprets the input value, <span class="math">V</span>, as a 2-element array, <span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span>, where <span class="math">W</span> is a word composed of the high and middle bytes of <span class="math">V</span>, and <span class="math">C</span> is the low byte of <span class="math">V</span>:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top cyan">W<span class="sub">15</span></td><td class="top cyan">W<span class="sub">14</span></td><td class="top cyan">W<span class="cyan">13</span></td><td class="top cyan">W<span class="sub">12</span></td><td class="top cyan">W<span class="sub">11</span></td><td class="top cyan">W<span class="sub">10</span></td><td class="top cyan">W<span class="sub">9</span></td><td class="top cyan">W<span class="sub">8</span></td><td class="top cyan">W<span class="sub">7</span></td><td class="top cyan">W<span class="sub">6</span></td><td class="top cyan">W<span class="sub">5</span></td><td class="top cyan">W<span class="sub">4</span></td><td class="top cyan">W<span class="sub">3</span></td><td class="top cyan">W<span class="sub">2</span></td><td class="top cyan">W<span class="sub">1</span></td><td class="top cyan">W<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>Functions that accept arrays return arrays with the same dimensions.</p>

<h2 id="identity">Identity</h2>

<p>An <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a> echos the provided value:</p>

<p><span class="math">f(x) = x</span></p> 

<p>The image below depicts an <span class="nowrap">8-bit</span> identity function. The height is arbitrary.</p>

<object data="identity.svg" type="image/svg+xml" class="diagram">Identity</object>

<h2 id="constant">Constant</h2>

<p>A constant function returns the same value regardless of the argument:</p>

<p><span class="math">f(x) = k</span></p>

<p>There are two <span class="nowrap">1-bit</span> versions. The first outputs <span class="mono">0</span>. This is achieved by XORing the input with itself:</p>

<p><span class="math">f(A) = A &oplus; A = </span><span class="serif">0</span></p>

<p>The code below links both inputs of an XOR gate with a horizontal I-Tetrimino.</p>

<pre class="code">
<span class="filename">false.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 12</span></span>
</pre>

<p>The tests in the following image affirm the circuit always outputs <span class="mono">0</span>.</p>

<object data="false.svg" type="image/svg+xml" class="diagram">False</object>

<p>The second <span class="nowrap">1-bit</span> function outputs <span class="mono">1</span>. This is accomplished by XNORing the input with itself:</p>

<p><span class="math">f(A) = <span class="overline">A &oplus; A</span> = </span><span class="serif">1</span></p>

<p>A horizontal I-Tetrimino joins the inputs of an XNOR gate in the code below.</p>

<pre class="code">
<span class="filename">true.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xnor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 17</span></span>
</pre>

<p>The following image reveals the circuit invariably yields <span class="mono">1</span>.</p>

<object data="true.svg" type="image/svg+xml" class="diagram">True</object>

<p><span class="nowrap">8-bit</span> constant functions are realized by applying the <span class="nowrap">1-bit</span> versions to each bit. The following example resets a byte to <span class="mono">0</span>.</p>

<object data="clear.svg" type="image/svg+xml" class="diagram">Clear</object>

<p>The image below depicts the requisite <span class="math">f(x) = </span><span class="serif">42</span> function. </p>

<object data="constant-42.svg" type="image/svg+xml" class="diagram">42</object>

<h2 id="logical-left-shift">Logical Left Shift</h2>

<p>Logical left shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the left. The rightmost bit is set to <span class="mono">0</span> and the leftmost bit is lost:</p>

<object data="logical-left-shift.svg" type="image/svg+xml" class="diagram">Logical Left Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting a signed or unsigned value left by <span class="math">n</span> bits is equivalent to multiplying by <span class="serif">2</span><span class="math pow">n</span>: 

<p><span class="math">f(x) = </span><span class="serif">2</span><span class="math pow">n</span><span class="math">x</span></p>

<h2 id="logical-right-shift">Logical Right Shift</h2>

<p>Logical right shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the right. The leftmost bit is set to <span class="mono">0</span> and the right most bit is lost:</p>

<object data="logical-right-shift.svg" type="image/svg+xml" class="diagram">Logical Right Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting an unsigned value right by <span class="math">n</span> bits is equivalent to dividing by <span class="serif">2</span><span class="math pow">n</span> (rounding toward <span class="serif">0</span>):</p>

<p><span class="math">f(x) = </span><span class="math">x</span><span class="serif">/2</span><span class="math pow">n</span></p>

<h2 id="logical-and">Logical AND</h2>

<p>The logical AND function operates on a 3-byte array, where all 3 elements are Booleans, variables restricted to <span class="mono">0</span> and <span class="mono">1</span>. It ANDs the first and second elements together, and stores the result in the third element:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="math">]</span>, where <span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">C = AB</span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged while <span class="math">X</span> is discarded.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are ANDed together:</p>

<object data="and-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Logical AND Schematic</object>

<p>In the Tetris realization below, the AND gate is miniscule in comparison to the swap circuits required for <span class="math">A<span class="sub">0</span></span> to traverse the <span class="math">B</span> lines.</p>

<object data="and-a-b-c.svg" type="image/svg+xml" class="diagram">Logical AND</object>

<h2 id="logical-and-not">Logical AND-NOT</h2>

<p>The logical AND-NOT function operates on a 2-byte array, where both elements are Booleans, variables restricted to <span class="mono">0</span> and <span class="mono">1</span>. It replaces the first element with the first element ANDed with the inverse of the second element:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q = A<span class="overline">B</span></span></p>

<p><span class="math">B</span> passes through unchanged while <span class="math">A</span> is lost.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are used to produce <span class="math">Q</span>:</p>

<object data="and-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>In the Tetris version, shown below, the horizontal <span class="math">B<span class="sub">0</span></span> wire is realized as a chain of swap circuits. The swaps are stacked from right-to-left, producing a diagonal line while shuttling the signal.</p>

<object data="and-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>There is a variation that operates on an array of 3 Booleans. It sets the first element to the second element ANDed with the inverse of the third element:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="math">]</span>, where <span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">C = A<span class="overline">B</span></span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged while <span class="math">X</span> is discarded.</p>

<p>As above, only the lowest bits of <span class="math">A</span> and <span class="math">B</span> are used to generate the result:</p>

<object data="and-c-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>The Tetris version follows.</p>

<object data="and-c-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT</object>

<h2 id="bitwise-and">Bitwise AND</h2>

<p>The bitwise AND function operates on a 2-byte array. It sets the first byte to the bitwise AND of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = AB</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an AND gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-and-fb-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>In the Tetris version below, the row of AND gates is in the upper-left. The parallelogram dominating the space is composed of parallel chains of swap circuits that propagate the bits of <span class="math">B</span> from right-to-left. Each chain is equivalent to one of the horizontal wires in the schematic. Since the swap circuits must be stacked to form a chain, the signals advance diagonally-upward.</p>

<object data="bitwise-and-fb.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<p>There is a variation that sets the second byte to the bitwise AND of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q </span><span class="math">]</span></p>

<p><span class="math">Q = AB</span> and <span class="math">A</span> passes through, unchanged.</p>

<p>Its circuit is the horizontal reflection of the one above:</p>

<object data="bitwise-and-af-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>The Tetris realization follows.</p>

<object data="bitwise-and-af.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<h2 id="bitwise-or">Bitwise OR</h2>

<p>The bitwise OR function operates on a 2-byte array. It sets the first byte to the bitwise OR of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = A + B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an OR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-or-schematic.svg" type="image/svg+xml" class="diagram">Bitwise OR Schematic</object>

<p>In the Tetris version below, the row of yellow O-Tetriminos in the upper-left are the OR gates. The parallelogram dominating the space is composed of parallel chains of swap circuits that propagate the bits of <span class="math">B</span> from right-to-left. Each chain is equivalent to one of the horizontal wires in the schematic. Since the swap circuits must be stacked to form a chain, the signals advance diagonally-upward.</p>

<object data="bitwise-or.svg" type="image/svg+xml" class="diagram">Bitwise OR</object>

<p>The horizontal reflection was not implemented.</p>

<h2 id="bitwise-xor">Bitwise XOR</h2>

<p>The bitwise XOR function operates on a 2-byte array. It sets the first byte to the bitwise XOR of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = A &oplus; B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an XOR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-xor-schematic.svg" type="image/svg+xml" class="diagram">Bitwise XOR Schematic</object>

<p>In the Tetris version below, the row of XOR gates is in the upper-left. The parallelogram dominating the space is composed of parallel chains of swap circuits that propagate the bits of <span class="math">B</span> from right-to-left. Each chain is equivalent to one of the horizontal wires in the schematic. Since the swap circuits must be stacked to form a chain, the signals advance diagonally-upward.</p>

<object data="bitwise-xor.svg" type="image/svg+xml" class="diagram">Bitwise XOR</object>

<p>The horizontal reflection was not implemented.</p>

<h2 id="byte-swap">Byte Swap</h2>

<p>The byte swap function exchanges the elements of a 2-byte array:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, A </span><span class="serif">]</span></p>

<p>It is realized with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object data="swap-8-schematic.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap Schematic</object>

<p>The diamond pattern in the schematic appears in the Tetris version below due to extensive use of the swap circuit.</p>

<object data="swap-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap</object>

<h2 id="byte-match">Byte Match</h2>

<p>The byte match function operates on a 2-byte array:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, X</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, M </span><span class="serif">]</span></p>

<p><span class="math">A</span> is compared against a bit pattern. If it matches, <span class="math">M</span> is <span class="mono">1</span>. If it doesn’t, <span class="math">M</span> is <span class="mono">0</span>. In either case, <span class="math">A</span> passes through unchanged while <span class="math">X</span> is discarded.</p>

<p>The bit pattern consists of zeros, ones, and <a href="https://en.wikipedia.org/wiki/Don%27t-care_term" target="_blank">don’t-cares</a>. Meaning, each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, is either compared against a constant or it is ignored. For example, the following expression checks if all <span class="math">A<span class="sub">i</span></span> are <span class="mono">1</span>:</p> 

<p><span class="math">M = A<span class="sub">7 </span>A<span class="sub">6 </span>A<span class="sub">5 </span>A<span class="sub">4 </span>A<span class="sub">3 </span>A<span class="sub">2 </span>A<span class="sub">1 </span>A<span class="sub">0 </span> = <span class="high-overline"><span class="overline2">A<span class="sub">7</span></span> + <span class="overline2">A<span class="sub">6</span></span> + <span class="overline2">A<span class="sub">5</span></span> + <span class="overline2">A<span class="sub">4</span></span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>That suggests the following circuit.</p>

<object data="match-ff-right-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Right</object>

<p>Each <span class="math">A<span class="sub">i</span></span> column contains an inverter pair, which enables <span class="math">A</span> to traverse unmodified. For an arbitrary constant, <span class="math">K</span>, inverter pairs only exist in the columns where <span class="math">K<span class="sub">i</span></span> is <span class="mono">1</span>. For instance, the expression below checks if <span class="math">A</span> is <span class="mono">0</span>:</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span> + A<span class="sub">1</span> + A<span class="sub">0</span></span></span></p>

<p>It requires no inverter pairs, as illustrated by the Tetris realization:</p>

<object data="match-zero-right.svg" type="image/svg+xml" class="diagram">Match Zero Right</object>

<p>Horizontal J-Tetriminos operate as OR gates. They feed each input bit to both terminals of a swap circuit.</p>

<p>The following expression checks if <span class="math">A</span> is binary value <span class="mono">00101111</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> A<span class="sub">5</span> <span class="overline2">A<span class="sub">4</span></span> A<span class="sub">3</span> A<span class="sub">2</span> A<span class="sub">1</span> A<span class="sub">0</span> = <span class="high-overline">A<span class="sub">7</span> + A<span class="sub">6</span> + <span class="overline2">A<span class="sub">5</span></span> + A<span class="sub">4</span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>It is actualized by introducing inverter pairs corresponding to the <span class="mono">1</span> bits:</p>

<object data="match-smn-right.svg" type="image/svg+xml" class="diagram">Match SMN Right</object>

<p>Don’t-care bits are omitted from the OR chain. For instance, the following expression tests if A is <span class="mono">000000**</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span></span></span></p>

<p>In the Tetris realization below, 2 of the horizontal J-Tetriminos are absent, enabling <span class="math">A<span class="sub">1</span></span> and <span class="math">A<span class="sub">0</span></span> to cross the OR chain without contributing to it.</p>

<object data="match-tax-right.svg" type="image/svg+xml" class="diagram">Match TAX Right</object>

<p>There is a variation of the byte match function where the parameters are swapped:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">X, A</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> M, A </span><span class="serif">]</span></p>

<p>Its circuit is nearly the horizontal reflection of the one above:  </p>

<object data="match-ff-left-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Left</object>

<p>In the Tetris version below, the inverter pairs are omitted, resulting in a zero detector. </p>

<object data="match-zero-left.svg" type="image/svg+xml" class="diagram">Match Zero Left</object>

<h2 id="equals">Equals</h2>

<p>The equals function operates on a 3-byte array:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="serif">]</span></p>

<p><span class="math">E</span> is <span class="mono">1</span> if <span class="math">A</span> equals <span class="math">B</span>. Otherwise, <span class="math">E</span> is <span class="mono">0</span>. Either way, <span class="math">A</span> and <span class="math">B</span> pass through unchanged while <span class="math">X</span> is discarded.</p>

<p><span class="math">E</span> is defined by the following expression, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<p><span class="math">E = (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)</span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span></span></p>

<p>That suggests the following circuit.</p>

<object data="equals-a-b-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>In the Tetris version below, a constant bit function seeds the AND chain with <span class="mono">1</span> (see lower-right).</p>

<object data="equals-a-b-e.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Since the evaluation order is established by the sequence in which components are built, each input propagates upward as it advances from left-to-right. The diamond arrangement of swap circuits is a consequence of nearly-parallel, diagonally-upward lines that terminate on the vertical AND chain.</p>

<p>There is a variation of the equals function where the parameters are rearranged:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> E, A, B </span><span class="serif">]</span></p>

<p>Its circuit is roughly the horizontal reflection of the one above:</p>

<object data="equals-e-a-b-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Here is the Tetris realization:</p>

<object data="equals-e-a-b.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>There is a another variation that uses all 3 input bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, V </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="math">]</span>, where <span class="math">V,E </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">E</span> is <span class="mono">1</span> iff <span class="math">A</span> equals <span class="math">B</span> and <span class="math">V</span> is <span class="mono">1</span>:</p>

<p><span class="math">E = (A = B)V</span> 

<p><span class="math">= (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)V<span class="sub">0</span></span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span> V<span class="sub">0</span></span></p>
  
<p>It provides a way to compare multiple bytes:</p>

<p><span class="math">V = (T = U)</span></p>

<p><span class="math">V&prime; = (R = S)V = (R = S)(T = U)</span></p>

<p><span class="math">V&Prime; = (P = Q)V&prime; = (P = Q)(R = S)(T = U)</span></p>

<p>And so on.</p>

<p>The variation can be realized by using the lowest bit of <span class="math">V</span> as the seed of the AND chain. Instead, in an effort to reuse wherever possible, an AND gate was added to the top of the existing circuit:</p>

<object data="equals-a-b-and-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The Tetris implementation follows.</p>

<object data="equals-a-b-and-e.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The horizontal reflection of this variation was not implemented. </p>

<h2 id="byte-copy">Byte Copy</h2>

<p>The byte copy function operates on a 2-byte array. It copies the first byte to the second byte:</p> 

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, A </span><span class="serif">]</span></p>

<p>This is accomplished with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object data="copy-a-b-schematic.svg" type="image/svg+xml" class="diagram">Copy A to B Schematic</object>

<p>As shown below, the Tetris version is dominated by swap circuits.</p>

<object data="copy-a-b.svg" type="image/svg+xml" class="diagram">Copy A to B</object>

<p>Since the evaluation order is established by the sequence in which components are built, each signal propagates upward as it advances from left-to-right. The triangular arrangement is a consequence of the parallel, diagonally-upward lines. After the center wire is crossed, horizontal lines of Z-Tetriminos are used in the same way as the horizontal lines in the schematic above it.</p>

<p>A variation of the function copies the second byte to the first byte:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, B </span><span class="serif">]</span></p>

<p>It is the horizontal reflection of the previous circuit:</p>

<object data="copy-b-a-schematic.svg" type="image/svg+xml" class="diagram">Copy B to A Schematic</object>

<p>The Tetris version follows.</p>

<object data="copy-b-a.svg" type="image/svg+xml" class="diagram">Copy B to A</object>

<h2 id="conditional-byte-copy">Conditional Byte Copy</h2>

<p>The conditional byte copy function operates on a 3-byte array. It either copies the first byte to the second byte, or it does nothing, per the value of the third byte.</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>. Otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>This is achieved by the circuit below where each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of a 2-to-1 multiplexer that selects between <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> based on <span class="math">C<span class="sub">0</span></span>.</p>

<object data="copy-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Here is the Tetris version:</p>

<object data="copy-a-b-c.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Flipping the circuit horizontally creates a variation that either copies the third byte to the second byte, or does nothing, per the value of the first byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, Q, B </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>. Otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">C</span> and <span class="math">B</span> pass through, unchanged.</p>

<p>The flipped circuit appears below.</p>

<object data="copy-c-b-a-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>The Tetris version follows.</p>

<object data="copy-c-b-a.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Repositioning the multiplexers from the <span class="math">A</span> lines to the <span class="math">B</span> lines reverses the roles of the second and third bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, Q </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>. Otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>Here is the schematic:</p>

<object data="copy-c-a-b-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Below is the Tetris version.</p>

<object data="copy-c-a-b.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Finally, flipping that circuit horizontally yields a variation that either copies the second byte to the first byte, or does nothing, per the value of the third byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>. Otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">B</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>The flipped circuit follows.</p>

<object data="copy-b-a-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Here is the Tetris realization:</p>

<object data="copy-b-a-c.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<h2 id="decrement">Decrement</h2>

<p>The decrement function subtracts one from its argument:</p>

<p><span class="math">f(x) = x &minus; </span><span class="serif">1</span></p>

<p>It consists of chain of <a href="https://en.wikipedia.org/wiki/Subtractor#Half_subtractor" target="_blank">half subtractors</a>, devices capable of single-digit subtraction. Each accepts a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">minuend</a>, <span class="math">X</span>, and a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">subtrahend</a>, <span class="math">Y</span>, and outputs their signed difference, a <span class="nowrap">2-bit</span> value composed of the sign bit, <span class="math">B</span>, and the ones bit, <span class="math">D</span>. The table below lists all possibilities.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">B</th><th class="math">D</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &minus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &minus; 1 = &minus;1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &minus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &minus; 1 = 0</span></td></tr>
</table>

<p><span class="math">B</span> and <span class="math">D</span> can be expressed as:</p>

<p><span class="math">B = <span class="overline">X</span>Y</span></p>

<p><span class="math">D = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = B + X<span class="overline">Y</span></span></p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math"><span class="overline">X</span>Y = <span class="overline">X</span>X + <span class="overline">X</span>Y = <span class="overline">X</span>(X + Y) = <span class="high-overline">X + <span class="overline">X + Y</span></span> = <span class="overline">X + T</span>, T = <span class="overline">X + Y</span></span></p>

<p><span class="math">X<span class="overline">Y</span> = X<span class="overline">Y</span> + Y<span class="overline">Y</span> = <span class="overline">Y</span>(X + Y) = <span class="high-overline">Y + <span class="overline">X + Y</span></span> = <span class="overline">Y + T</span>, T = <span class="overline">X + Y</span></span></p>

<p>Cleaning up:</p>

<p><span class="math">T = <span class="overline">X + Y</span></span></p>

<p><span class="math">B = <span class="overline">X + T</span></span></p>

<p><span class="math">D = B + <span class="overline">Y + T</span></span></p>

<p>That implies the following circuit.</p>

<object data="half-subtractor-schematic.svg" type="image/svg+xml" class="diagram">Half Subtractor Schematic</object>

<p>In the code below, which is based on that schematic, a horizontal I-Tetrimino functions as the upper OR.</p>

<pre class="code">
<span class="filename">halfSubtractor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-1</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-2</span></span>
<span class="line"><span class="normal">lr </span><span class="number">3</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">nor nor1 </span><span class="number">1 1</span></span>
<span class="line"><span class="normal">nor nor2 </span><span class="number">-1 6</span></span>
<span class="line"><span class="normal">nor nor3 </span><span class="number">3 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-4</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">b </span><span class="number">-5 14</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">d </span><span class="number">-2 14</span></span>
</pre>

<p>Here are the outputs for all possible inputs:</p>

<object data="half-subtractor.svg" type="image/svg+xml" class="diagram">Half Subtractor</object>

<p>For the function, half subtractors are chained in the following configuration where each <span class="math">I<span class="sub">i</span></span> is an input digits and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object data="decrementer-schematic.svg" type="image/svg+xml" class="diagram">Decrementer Schematic</object>

<p>The circuit is a binary odometer that counts down. If a digit rolls back (transitions from <span class="mono">0</span> to <span class="mono">1</span>), then the digit to its left is decremented. The signal to decrement a digit is referred to as the <span class="term">borrow</span>. The initial <span class="term">borrow-in</span> is <span class="mono">1</span> (far right). If an input digit is <span class="mono">0</span> and the borrow-in is <span class="mono">1</span>, then both the output digit and the <span class="term">borrow-out</span> is <span class="mono">1</span>.</p>

<p>The <span class="nowrap">8-bit</span> function in the image below decrements <span class="mono">42</span>. The evaluation order is the order in which components are built. It starts with a <span class="nowrap">1-bit</span> constant function at the bottom-right that supplies the initial borrow-in. From there, digits are evaluated right-to-left (and bottom-up). The final borrow-out is discarded.</p>

<object data="decrementer-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Decrementer</object>

<p>When the input is <span class="mono">0</span>, the decrement function rolls back to the maximum value. This is demonstrated in the following image that shows the <span class="nowrap">16-bit</span> version. </p>

<object data="decrementer-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Decrementer</object>

<h2 id="increment">Increment</h2>

<p>The increment function adds one to its argument:</p>

<p><span class="math">f(x) = x + </span><span class="serif">1</span></p>

<p>It consists of chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder" target="_blank">half adders</a>, devices capable of single-digit addition. Each accepts two <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span> and <span class="math">Y</span>, and outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below lists all possibilities.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 = 2</span></td></tr>
</table>

<p><span class="math">C</span> and <span class="math">S</span> can be expressed as:</p>

<p><span class="math">C = XY = <span class="high-overline"><span class="overline">X</span> + <span class="overline">Y</span></span></span></p>

<p><span class="math">S = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = <span class="overline">X</span>X + <span class="overline">X</span>Y + X<span class="overline">Y</span> + Y<span class="overline">Y</span> = (<span class="overline">X</span> + <span class="overline">Y</span>)(X + Y) = <span class="overline">C</span>(X + Y) = <span class="high-overline">C + <span class="overline">X + Y</span></span></span></p>

<p>That implies the following circuit.</p>

<object data="half-adder-schematic.svg" type="image/svg+xml" class="diagram">Half Adder Schematic</object>

<p>In the code below, which is based on that schematic, the <span class="mono">swap</span> (line <span class="mono">14</span>) enables the output of the bottom NOR (line <span class="mono">13</span>) to hop over the input of the <span class="math">Y</span> inverter (line <span class="mono">17</span>). The <span class="math">X</span> inverter (line <span class="mono">16</span>) feeds into the middle NOR (line <span class="mono">18</span>), which in turn feeds into the top NOR (line <span class="mono">25</span>).</p>

<pre class="code">
<span class="filename">halfAdder.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-6</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">jl </span><span class="number">2</span></span>
<span class="line"><span class="normal">jr </span><span class="number">2</span></span>
<span class="line"><span class="normal">nor </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">swap </span><span class="number">2 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-7 28</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-3 28</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-5 33</span></span>
<span class="line"><span class="normal">lr </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">3</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-1</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-3 38</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-8</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-3..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">1..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">c </span><span class="number">-8 44</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">s </span><span class="number">-3..0 44</span></span>
</pre>

<p>In the following image that shows the outputs for all possible inputs, the swap circuit dominates the space.</p>

<object data="half-adder.svg" type="image/svg+xml" class="diagram">Half Adder</object>

<p>For the function, half adders are chained in the configuration below where each <span class="math">I<span class="sub">i</span></span> is an input digits and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object data="incrementor-schematic.svg" type="image/svg+xml" class="diagram">Incrementor Schematic</object>

<p>The circuit is a binary odometer that counts up. If a digit rolls over (transitions from <span class="mono">1</span> to <span class="mono">0</span>), then the digit to its left is incremented. The signal to increment a digit is referred to as the <span class="term">carry</span>. The initial <span class="term"><span class="nowrap">carry-in</span></span> is <span class="mono">0</span> (far right). If an input digit is <span class="mono">1</span> and the <span class="nowrap">carry-in</span> is <span class="mono">1</span>, then output digit is <span class="mono">0</span> and the <span class="term"><span class="nowrap">carry-out</span></span> is <span class="mono">1</span>.</p>

<p>The <span class="nowrap">8-bit</span> function in the following image increments <span class="mono">42</span>. The evaluation order is the order in which components are built. It starts with a <span class="nowrap">1-bit</span> constant function at the bottom-right that supplies the initial <span class="nowrap">carry-in</span>. From there, digits are evaluated right-to-left (and bottom-up). The final <span class="nowrap">carry-out</span> is discarded.</p>

<object data="incrementor-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Incrementor</object>

<p>When the input is the maximum value, the increment function rolls over to <span class="mono">0</span>. This is demonstrated in the image below that shows the <span class="nowrap">16-bit</span> version.</p>

<object data="incrementor-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Incrementor</object>

<h2 id="conditional-increment">Conditional Increment</h2>

<p>The conditional increment function operates on a 2-element array, <span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span>, where <span class="math">W</span> is a signed or unsigned, <span class="nowrap">16-bit</span> integer, and <span class="math">C</span> is a Boolean (a byte restricted to <span class="mono">0</span> and <span class="mono">1</span>):</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">W </span><span class="serif">+ 1</span> if <span class="math">C</span> is <span class="serif">1</span>. Otherwise, <span class="math">Q</span> is <span class="math">W</span>. Either way, <span class="math">C</span> passes through, unchanged.</p>

<p>As shown in the schematic below, it is realized by feeding the lowest bit of <span class="math">C</span> into the <span class="nowrap">carry-in</span> of a <span class="nowrap">16-bit</span> incrementer. The <span class="nowrap">carry-out</span> is discarded.</p>

<object data="conditional-increment-schematic.svg" type="image/svg+xml" class="diagram">Conditional Increment Schematic</object>

<p>Here is the Tetris version:</p>

<object data="conditional-increment.svg" type="image/svg+xml" class="diagram">Conditional Increment</object>

<h2 id="add">Add</h2>

<p>The add function operates on a 2-byte array. It sets the first byte to the sum of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></p>

<p><span class="math">Q = A + B</span>, where the plus sign denotes arithmetic addition.</p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>The implementation of the function consists of a chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder" target="_blank">full adders</a>, devices capable of single-digit addition. Each accepts three <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span>, <span class="math">Y</span>, and <span class="math">Z</span>, and outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below lists all possibilities.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="math">Z</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 0 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 1 = 3</span></td></tr>
</table>

<p><span class="math">S</span> can be expressed as an OR of ANDs and NOTs from the rows of the table where it is <span class="mono">1</span>: 

<p><span class="math">S = <span class="overline">X</span> <span class="overline">Y</span> Z + <span class="overline">X</span> Y <span class="overline">Z</span> + X <span class="overline">Y</span> <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math">= <span class="overline">X</span> (<span class="overline">Y</span> Z + Y <span class="overline">Z</span>) + X (<span class="overline">Y</span> <span class="overline">Z</span> + Y Z)</span></p>

<p><span class="math">= <span class="overline">X</span> (Y &oplus; Z) + X <span class="overline">(Y &oplus; Z)</span></span></p>

<p><span class="math">= X &oplus; Y &oplus; Z</span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math"> &oplus; Z</span></span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">(X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math">) &oplus; Z</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">(X &oplus; Y)</span> &oplus; Z</span></span></p>

<p>Similarly, <span class="math">C</span> can be expressed from the rows of the table where it is <span class="mono">1</span>:</p>

<p><span class="math">C = <span class="overline">X</span> Y Z + X <span class="overline">Y</span> Z + X Y <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math"> = Z (<span class="overline">X</span> Y + X <span class="overline">Y</span>) + X Y (<span class="overline">Z</span> + Z)</span></p>

<p><span class="math"> = Z (X <span class="overline">X</span> + <span class="overline">X</span> Y + X <span class="overline">Y</span> + Y <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) (<span class="overline">X</span> + <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) <span class="overline">(X Y)</span> + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y) + (Y X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y + X <span class="overline">X</span> <span class="overline">Y</span>) + (Y X Y + Y <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X (X Y + <span class="overline">X</span> <span class="overline">Y</span>) + Y (X Y + <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X <span class="overline">(X &oplus; Y)</span> + Y <span class="overline">(X &oplus; Y)</span></span></p>

<p><span class="math"> = Z (X + Y) + <span class="overline">(X &oplus; Y)</span> (X + Y)</span></p>

<p><span class="math"> = (X + Y) (Z + <span class="overline">X &oplus; Y</span>)</span></p>

<p>They can be combined:</p>

<p><span class="math">T = <span class="overline">X &oplus; Y</span></span></p>

<p><span class="math">S = <span class="overline">T &oplus; Z</span></span></p>

<p><span class="math">C = (X + Y) (Z + T) = <span class="high-overline"><span class="overline">X + Y</span> + <span class="overline">Z + T</span></span></span></p>

<p>Since XNOR can be realized from 4 NORs, the result suggests the following.</p>

<object data="full-adder-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic</object>

<p>The circuit employed by the Tetris version preserves <span class="math">X</span> by outputting it between <span class="math">C</span> and <span class="math">S</span>. As shown below, it requires 9 NORs and 3 crosses.</p>

<object data="full-adder-x-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic, Outputs X</object>

<p>The following image presents the Tetris version for all <span class="math">Y</span> and <span class="math">Z</span> when <span class="math">X</span> is <span class="mono">0</span>. The space is dominated by the 3 swap circuits.</p>

<object data="full-adder-x-0.svg" type="image/svg+xml" class="diagram">Full Adder, X = 0</object>

<p>Here are the outcomes when <span class="math">X</span> is <span class="mono">1</span>:</p>

<object data="full-adder-x-1.svg" type="image/svg+xml" class="diagram">Full Adder, X = 1</object>

<p>For the function, full adders are chained, as shown below. Each accepts a pair of addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, and outputs a sum digit, <span class="math">Q<span class="sub">i</span></span>, along with an unmodified addend digit, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="adder-schematic.svg" type="image/svg+xml" class="diagram">4-bit Adder Schematic</object>

<p>As when addition is done by hand, the digit columns are evaluated right-to-left. In each column, if the sum of the <span class="nowrap">carry-in</span>, <span class="math">Z</span>, and the addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, is not a single digit number, then the upper digit of that sum, <span class="math">C</span>, is carried out to the next column. The initial carry-in is <span class="mono">0</span> (far right) and the final carry-out is lost.</p>

<p>Crisscrossing wires are required to interlace the inputs and to disentangle the outputs:</p>

<object data="add-schematic.svg" type="image/svg+xml" class="diagram">8-bit Adder Schematic</object>

<p>The Tetris realization retains the triangular patterns from all the cross overs:</p>

<object data="add.svg" type="image/svg+xml" class="diagram">8-bit Adder</object>

<p>The full adders are stacked diagonally to enable the carries to ripple in the expected order.</p>

<h2 id="subtract">Subtract</h2>

<p>The subtract function operates on a 2-byte array. It sets the first byte to the difference of the first byte and the second byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></p>

<p><span class="math">Q = A &minus; B</span></p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>Since <span class="math">A</span>, <span class="math">B</span>, and <span class="math">Q</span> are <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two’s complement numbers</a>, the subtraction can be transformed into a sum:</p>

<p><span class="math">A &minus; B = A + -B = A + </span><span class="serif">~</span><span class="math">B + </span><span class="serif">1</span>, where <span class="serif">~</span> means <a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT" target="_blank">bitwise inversion</a>.</p>

<p>Consequentially, the subtraction circuit is the modified addition circuit shown below.</p>

<object data="subtract-schematic.svg" type="image/svg+xml" class="diagram">8-bit Subtractor Schematic</object>

<p>The <span class="mono">1</span> required by the transformation is provided by the initial carry-in (far right).</p>

<p>The bits of <span class="math">B</span> are inverted twice to return it with its original value.</p>

<p>The Tetris realization follows.</p>

<object data="subtract.svg" type="image/svg+xml" class="diagram">8-bit Subtractor</object>

<h2 id="height-unification">Height Unification</h2>

<p>Of all the implemented functions, subtract is the tallest, at least as they have been portrayed thus far. In reality, the functions are padded with buffers that extends them to a common height. As such, every function fits in a rectangle of 1 of 3 possible sizes: the base covers either 8, 16, or 24 bits, and the height is some constant. This enables functions to operate like interchangeable, building blocks of logic.</p>

<h2 id="function-catalog">Function Catalog</h2>

<p>...</p>

<h1 id="memory">Memory</h1>

<p>This section describes how memory works.</p>

<h2 id="memory-implementation">Implementation</h2>

<p>Memory is an information storage device consisting of a rectangular pile with finite dimensions. The left edge of the pile abuts the left boundary of the workspace. The memory state is encoded as a sequence of bits in the <span class="nowrap">top-2</span> rows. The bits are regularly-spaced, 10 columns apart. And the number of bits is divisible by 8, which makes the sequence a finite list of bytes ordered left-to-right.</p>

<p>The bytes are manipulated by applying functions. This involves constructing a function on top of the bytes to be changed and using identity functions to keep the remaining bytes the same. Since functions have a uniform height, the identity functions also keep the pile rectangular.</p>

<p>An example of byte manipulation appears below. The numbered, green rows contain successive memory states. The blue row comprises the functions that transition states. Memory <span class="nowrap">state <span class="mono">0</span></span> (the bottom row) consists of 5 bytes that are all zero. <span class="nowrap">Byte <span class="mono">2</span></span> is incremented by building the <span class="mono">INC</span> function on the surface of the pile at the location of <span class="nowrap">byte <span class="mono">2</span></span>, and erecting identity functions (the up arrows) on top of the remaining bytes. The result is memory <span class="nowrap">state <span class="mono">1</span></span> (the top row). The delta appears yellow.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">1</td><td class="top mono bottom green">00</td><td class="top left bottom mono green">00</td><td class="top left bottom mono yellow">01</td><td class="top left bottom mono green">00</td><td class="top left right bottom mono green">00</td></tr>
<tr><td class="row-number"></td><td class="bottom blue">&#129093;</td><td class="left bottom blue">&#129093;</td><td class="left bottom mono blue">INC</td><td class="left bottom blue">&#129093;</td><td class="left right bottom blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono bottom green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left right bottom mono green">00</td></tr>

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table> 

<p>In the following example, memory is initialized to <span class="serif">[ </span><span class="mono">00, 01, 02, 03, 04</span><span class="serif"> ]</span>. Then, through a series of steps, byte <span class="mono">0</span> is set to the sum of the other bytes.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top yellow">0A</td><td class="left bottom top mono yellow">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left right bottom top mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono yellow">0A</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono yellow">06</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">06</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom yellow">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table>

<p>The <span class="mono">SWAP</span> function arranges addends into adjacent bytes to enable <span class="mono">ADD_AB_FB</span> to add them. It also shuttles the final sum into <span class="nowrap">byte <span class="mono">0</span></span>.</p>

<h2 id="metatetrisscript">MetaTetrisScript</h2>

<p>The blindfolded player cannot read the contents of memory, but it can manipulate it by executing <span class="term">MetaTetrisScript</span>, a language that specifies where to assemble functions. Each instruction of the language consists of a structure name and a byte index:</p>

<p class="definition">structure x</p>

<p>It means:</p>

<ol>
<li>Build the specified structure on the surface of the pile at <span class="nowrap">byte <span class="mono">x</span></span>. Since bits are 10 columns apart and there are 8 bits per byte, the left edge of the structure coincides with playfield column 80<span class="mono">x</span>.</li> 
<li>Build identity functions on top of the other bytes.</li>
</ol>

<p>The code below formalizes the steps of the previous example.</p>

<pre class="code">
<span class="line"><span class="normal">COPY_B_A </span><span class="number">0</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">3</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">0</span></span>
</pre>

<p>Each MetaTetrisScript instruction can be translated into TetrisScript instructions. But, to build structures on top of the pile, the player must keep track of the pile height. It is equal to the number of memory state transitions times the uniform function height. In addition, the player needs the width of the pile and the width of each function to know how many identity functions to build. Disclosing these values does not expose the contents of memory to the player.</p>

<h2 id="expansion">Expansion</h2>

<p>The number of allocated bytes&mdash;the width of the pile divided by 80&mdash;is finite. But, since the workspace spans to infinity, memory capacity has no bounds. The player can construct functions beyond the edge of the pile by expanding it. This involves building a constant function on the playfield floor to initialize a new byte, and then repeatedly assembling identity functions above it until it reaches the height of the rest of the pile. This is portrayed in the following example. It shows a newly allocated byte appended to the right side of the previous pile.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top green">0A</td><td class="left bottom top mono green">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left bottom top mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">06</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">06</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono green">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom green">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue mono">CLEAR</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td><td class="left right mono green">?</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td><td class="column-number">5</td></tr>  
</table>

<p>Since the region containing <span class="nowrap">byte <span class="mono">5</span></span> starts out empty, memory state <span class="mono">0</span> (the bottom row) shows its initial value as question mark. To allocate the byte, a <span class="mono">CLEAR</span> function is constructed directly on the playfield floor, establishing the value zero as exhibited in memory state <span class="mono">1</span>. Then multiple identity functions propagate the zero to the top of the pile.</p> 

<p>The player carries out this action when a MetaTetrisScript instruction directs it to construct a function outside the current bounds of the pile. To do so, the player keeps track of both the pile height and the (potentially increasing) pile width.</p>

<p>For the models of computation discussed below, memory is never deallocated, though it is possible. The process requires the player to keep track of the heights of all the columns. With that, it can contract the pile and later, during subsequent expansion, it can restore abandoned columns back to the pile height.</p>

<h2 id="memory-initialization">Initialization</h2>

<p>Although the player could initialize memory by dropping a sequence of constant functions directly onto the playfield floor, that would violate its principles. The blindfolded player can never be made aware of any memory state, including the initial state. Instead, the playfield, rather than starting out empty, begins with the input dataset already encoded within it. And, due to the way memory expands, the unallocated region is effectively initialized to zeros.</p>

<h2 id="dynamic-array-abstraction">Dynamic Array Abstraction</h2>

<p>When a function is constructed, it interacts exclusively with the surface of the pile. Everything beneath&mdash;the full history of memory&mdash;is irrelevant. Only the current state matters. This suggests an abstraction where memory operates like a <a href="https://en.wikipedia.org/wiki/Dynamic_array" target="_blank">dynamic array</a>, a random access, variable-size list of bytes. Applying a function at byte <span class="math">i</span> means updating bytes <span class="math">i</span> through <span class="math">i + n</span>, where <span class="math">n</span> is the byte-width of the function. All the other bytes remain the same. In other words, even though the pile is a <span class="nowrap">2-dimensional</span> matrix, it acts like a <span class="nowrap">1-dimensional</span> array where functions modify element sequences.</p>

<h1 id="computer-architecture">Computer Architecture</h1>

<p>...</p>

<h2 id="turing-machine">Turing Machine</h2>

<p>A <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank">Turing machine</a> is a mathematical model used to investigate <a href="https://en.wikipedia.org/wiki/Computability" target="_blank">computability</a>. There are several ways to define it. For this discussion, it consists of the following parts.</p>

<ul>
  <li>A <a href="https://en.wikipedia.org/wiki/Tape_drive" target="_blank">tape drive</a>.
    <ul style="padding-top: 1em;">
      <li>Mounted onto the drive is an infinitely long <span class="term">tape</span> capable of storing an endless a sequence of bits. A finite (and arbitrary) region of the tape is initialized with an input dataset. The remainder contains zeros.</li>
      <li>The read/write <span class="term">head</span> of the drive is limited to accessing a single bit. The drive can shift the tape to move the head one bit left or one bit right in the sequence. The head is initially positioned over the leftmost bit of the input dataset.</li>
    </ul>
  </li>
  <li style="padding-top: 1em;">A <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">state machine</a>.
    <ul style="padding-top: 1em;">
      <li>A <span class="term">register</span> stores the current state, one of a finite many. It is initialized to a starting state.</li>
      <li>A <span class="term">state-transition table</span> with a finite number of entries. The key of each entry is the pair consisting of the current state and the current bit under the head. The value of each entry is a list of 3 instructions: 
        <ol style="padding-top: 1em;">
          <li>Write a specified bit value at the position of the head.</li>
          <li>Move the head one bit in a specified direction.</li> 
          <li>Update the register with a specified state.</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>During each cycle of the machine:</p>
<ol>
  <li>The head reads a bit value.</li>
  <li>The bit value along with the current state is used to do a lookup in the state-transition table.</li>
  <li>The instructions in the <span class="nowrap">looked-up</span> entry are executed.</li>
</ol>

<p>There are several ways to emulate a Turing machine using the dynamic array abstraction discussed above. The startup configuration of one approach places the state register into the first <span class="serif">N</span> bytes of the array, <span class="nowrap"><span class="serif">a<span class="sub2">0</span></span>&nldr;<span class="serif">a<span class="sub2">N&minus;1</span></span></span>. <span class="serif">N</span> is large enough to cover all possible state values and the register is initialized with the starting state.</p>

<p>The byte immediately after the register, <span class="nowrap"><span class="serif">a<span class="sub2">N</span></span></span>, is set to <span class="mono">FF</span>. It operates as a boundary marker.</p> 

<p>The remaining bytes, <span class="nowrap"><span class="serif">a<span class="sub2">N+1</span>&nldr;a<span class="sub2">&infin;</span></span></span>, represent the tape. The tape extends infinitely in both directions, but the array only does so in one. To compensate, the array stores 2 tracks as if the tape had been folded in half. That is:</p> 

<ul>
  <li><span class="nowrap">Bit 0</span> of each byte, <span class="serif">a:0<span class="sub2">i+N+1</span></span>, stores the <span class="serif">i<span class="sup2">th</span></span> bit of the tape indexed from the leftmost bit of the input dataset and moving rightward.</li>
  <li><span class="nowrap">Bit 1</span> of each byte, <span class="serif">a:1<span class="sub2">i+N+1</span></span>, stores the <span class="serif">i<span class="sup2">th</span></span> bit of the tape indexed from the bit left of leftmost bit of the input dataset and moving leftward.</li>
</ul>

<p>The next two bits store the position of the head. Specifically:</p>

<ul>
  <li><span class="nowrap">Bit 2</span> of each byte, <span class="serif">a:2<span class="sub2">i+N+1</span></span>, is <span class="mono">1</span> iff the head is located at the <span class="serif">i<span class="sup2">th</span></span> bit of the tape indexed from the leftmost bit of the input dataset and moving rightward.</li>
  <li><span class="nowrap">Bit 3</span> of each byte, <span class="serif">a:3<span class="sub2">i+N+1</span></span>, is <span class="mono">1</span> iff the head is located at the <span class="serif">i<span class="sup2">th</span></span> bit of the tape indexed from the bit left of leftmost bit of the input dataset and moving leftward.</li>
</ul>

<p>To make this clear, the example below depicts the startup configuration of a machine where <span class="serif nowrap">N = 3</span> and <span class="serif nowrap">a<span class="sub2">i &ge; 10</span> = 0</span>.</p>

<table class="borderless">
  <tr><th class="mono">i</th><th class="mono">76543210</th></tr>
  <tr><td class="mono">0</td><td class="mono">00001001</td></tr>
  <tr><td class="mono">1</td><td class="mono">10101101</td></tr>	
  <tr><td class="mono">2</td><td class="mono">01100010</td></tr>
  <tr><td class="mono">3</td><td class="mono">11111111</td></tr>
  <tr><td class="mono">4</td><td class="mono">00000101</td></tr>
  <tr><td class="mono">5</td><td class="mono">00000001</td></tr>
  <tr><td class="mono">6</td><td class="mono">00000000</td></tr>
  <tr><td class="mono">7</td><td class="mono">00000001</td></tr>
  <tr><td class="mono">8</td><td class="mono">00000000</td></tr>
  <tr><td class="mono">9</td><td class="mono">00000001</td></tr>
</table>

<p>The register, <span class="serif">a<span class="sub2">0</span>&nldr;a<span class="sub2">2</span></span>, contains the start state, <span class="nowrap"><span class="serif">[</span><span class="mono"> 09, AD, 62 </span><span class="serif">]</span></span>. Those are random values picked for this example.</p>  

<p>The boundary marker, <span class="mono">FF</span>, is in <span class="serif">a<span class="sub2">3</span></span>.</p>

<p>The input dataset, <span class="nowrap"><span class="serif">[</span><span class="mono"> 1, 1, 0, 1, 0, 1 </span><span class="serif">]</span></span>, is in <span class="nowrap"><span class="serif">a:0<span class="sub2">4</span>&nldr;a:0<span class="sub2">9</span></span></span>. On the tape, everything to the left of the input dataset is zero. Hence, <span class="nowrap"><span class="serif">a:1<span class="sub2">4</span>&nldr;a:1<span class="sub2">9</span></span></span> contains all zeros.</p>

<p><span class="serif">a:2<span class="sub2">4</span></span> is <span class="mono">1</span>, which indicates that the head points to the first element of the input dataset.

<p>The register starts at index 0, but it is not fixed there. As revealed in the following animation, the register moves back-and-forth through the array by repeatedly applying the <span class="mono">SWAP</span> function.</p>  
  
<object data="animated-register.svg" type="image/svg+xml" class="diagram">Animated Register</object>  
  
<p>A move from <span class="serif">i</span> to <span class="serif">i+1</span> requires <span class="serif">N</span> swaps: <span class="serif nowrap">[ a<span class="sub2">i+N</span>, a<span class="sub2">i+N&minus;1</span> ], [ a<span class="sub2">i+N&minus;1</span>, a<span class="sub2">i+N&minus;2</span> ], &mldr;, [ a<span class="sub2">i+1</span>, a<span class="sub2">i</span> ]</span>.</p>

<p>A move from <span class="serif">i</span> to <span class="serif">i&minus;1</span> also requires <span class="serif">N</span> swaps: <span class="serif nowrap">[ a<span class="sub2">i&minus;1</span>, a<span class="sub2">i</span> ], [ a<span class="sub2">i</span>, a<span class="sub2">i+1</span> ], &mldr;, [ a<span class="sub2">i+N&minus;2</span>, a<span class="sub2">i+N&minus;1</span> ]</span>.</p>

<p>Each time the register moves to some index <span class="serif">i</span>, a transition function, <span class="serif">T</span>, operates on the register bytes, <span class="serif nowrap">a<span class="sub2">i</span>&nldr;a<span class="sub2">i+N&minus;1</span></span>, and the 3 bytes immediately to the right of the register, <span class="serif nowrap">a<span class="sub2">i+N</span>&nldr;a<span class="sub2">i+N+2</span></span>: 

<p><span class="serif nowrap">T( a<span class="sub2">i</span>&nldr;a<span class="sub2">i+N+2</span> ) &rarr; a&prime;<span class="sub2">i</span>&nldr;a&prime;<span class="sub2">i+N+2</span></span></p>

<p>Of those 3 extra bytes, <span class="serif">T</span> checks the middle one, <span class="serif">a<span class="sub2">i+N+1</span></span>, for the head. If the head is not found (<span class="serif nowrap">a:2<span class="sub2">i+N+1</span></span> and <span class="serif nowrap">a:3<span class="sub2">i+N+1</span></span> are both 0), then <span class="serif">T</span> lets the inputs pass through, unchanged. Otherwise, <span class="serif">T</span> uses the data bit corresponding to the head, <span class="serif nowrap">a:0<span class="sub2">i+N+1</span></span> or <span class="serif nowrap">a:1<span class="sub2">i+N+1</span></span>, in conjunction with the register value to update the data bit, to move the head, and to update the register value.</p>  

<p><span class="serif">T</span> is able to move the head because the 3 extra bytes include both adjacent neighbors of the byte containing the head. However, the first of the 3, <span class="serif">a<span class="sub2">i+N</span></span>, might be set to the boundary marker, <span class="mono">FF</span>, which represents the &ldquo;fold&rdquo; in the tape. This leads to the possibilities depicted in the following table.</p>

<object data="moving-the-head.svg" type="image/svg+xml" class="diagram">Moving the Head</object>  

<p>Each triplet portrays a state of the 3 extra bytes. The center column contains the initial configurations. The left and right columns show the 8 possible outcomes after the head moves left and right, respectively. The upper and lower circles correspond to bits 2 and 3 of each byte, where an unfilled circle is a <span class="mono">0</span> and a filled circle is a <span class="mono">1</span>.</p>

<p>In the first row, the head moves in the direction corresponding to the specified direction. In the second row, the head moves opposite to the specified direction because the tape is &ldquo;folded over&rdquo;. In the third and fourth rows, both circles of the left byte are filled since it contains the boundary marker. In the third row, moving left transfers the head from bit 2 to bit 3. Similarly, in the fourth row, moving right does the opposite.</p>

TODO EXPLAIN THAT T CAN BE COMPOSED OF FUNCTIONS IN THE CATALOG OR ANYTHING ELSE.

TODO EXPLAIN THAT THE REGISTER MOVES IN EXPANDING CYCLES.

TODO Each iterations takes more steps than its predecessor. But it is always a finite number of steps, enabling the machine to progress.

<h2 id="linear-bounded-automaton">Linear Bounded Automaton</h2>

<h2 id="instruction-set">Instruction Set</h2>

<h3 id="transfer-instructions">Transfer</h3>

<p>Transfer instructions copy the contents of a source register into a destination register. They do not affect the flags.</p>  

<p>The transfer instruction format is:</p> 

<p class="definition">T(source)(destination)</p>

<p>where <span class="mono">source</span>,<span class="mono">destination</span><span class="serif"> &isin; { </span><span class="mono">A</span>, <span class="mono">B</span>, <span class="mono">M</span>, <span class="mono">N</span><span class="serif"> }</span> and <span class="mono">source</span> &ne; <span class="mono">destination</span>.  

<p>Each transfer instruction corresponds to a <span class="nowrap">1-byte</span> opcode with bits <span class="mono">0000ssdd</span>, where <span class="mono">ss</span> and <span class="mono">dd</span> are one of the values below.</p>

<table class="borderless">
  <tr><th class="borderless">Value</th><th class="borderless">Register</th></tr>
  <tr><td class="mono">00</td><td class="mono">A</td></tr>
  <tr><td class="mono">01</td><td class="mono">B</td></tr>	
  <tr><td class="mono">10</td><td class="mono">M</td></tr>
  <tr><td class="mono">11</td><td class="mono">N</td></tr>
</table>

<p>The 12 transfer instructions follow.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">TAB</td><td class="mono">B = A;</td><td class="mono">01</td></tr>
  <tr><td class="mono">TAM</td><td class="mono">M = A;</td><td class="mono">02</td></tr>
  <tr><td class="mono">TAN</td><td class="mono">N = A;</td><td class="mono">03</td></tr>
  <tr><td class="mono">TBA</td><td class="mono">A = B;</td><td class="mono">04</td></tr>
  <tr><td class="mono">TBM</td><td class="mono">M = B;</td><td class="mono">06</td></tr>
  <tr><td class="mono">TBN</td><td class="mono">N = B;</td><td class="mono">07</td></tr>
  <tr><td class="mono">TMA</td><td class="mono">A = M;</td><td class="mono">08</td></tr>
  <tr><td class="mono">TMB</td><td class="mono">B = M;</td><td class="mono">09</td></tr>
  <tr><td class="mono">TMN</td><td class="mono">N = M;</td><td class="mono">0B</td></tr>
  <tr><td class="mono">TNA</td><td class="mono">A = N;</td><td class="mono">0C</td></tr>
  <tr><td class="mono">TNB</td><td class="mono">B = N;</td><td class="mono">0D</td></tr>
  <tr><td class="mono">TNM</td><td class="mono">M = N;</td><td class="mono">0E</td></tr>
</table>

<h3 id="arithmetic-and-logic-instructions">Arithmetic and Logic</h3>

<p>The arithmetic and logic instructions assign <span class="mono">A</span> to an <span class="nowrap">8-bit</span> function of <span class="mono">A</span> or of <span class="mono">A</span> and <span class="mono">B</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">ADD</td><td class="mono">A += B;</td><td class="mono">10</td></tr>    
  <tr><td class="mono">AND</td><td class="mono">A &= B;</td><td class="mono">11</td></tr>
  <tr><td class="mono">DEC</td><td class="mono">--A;</td><td class="mono">12</td></tr>
  <tr><td class="mono">INC</td><td class="mono">++A;</td><td class="mono">13</td></tr>
  <tr><td class="mono">LS2</td><td class="mono">A <<= 2;</td><td class="mono">14</td></tr>
  <tr><td class="mono">LS3</td><td class="mono">A <<= 3;</td><td class="mono">15</td></tr>
  <tr><td class="mono">LS4</td><td class="mono">A <<= 4;</td><td class="mono">16</td></tr>
  <tr><td class="mono">OR</td><td class="mono">A |= B;</td><td class="mono">17</td></tr>
  <tr><td class="mono">RS1</td><td class="mono">A >>>= 1;</td><td class="mono">18</td></tr>
  <tr><td class="mono">RS5</td><td class="mono">A >>>= 5;</td><td class="mono">19</td></tr>
  <tr><td class="mono">SUB</td><td class="mono">A -= B;</td><td class="mono">1A</td></tr>
  <tr><td class="mono">XOR</td><td class="mono">A ^= B;</td><td class="mono">1B</td></tr>
</table>

<p><span class="mono">AND</span>, <span class="mono">OR</span>, and <span class="mono">XOR</span> are bitwise operations.</p>

<p>The <span class="nowrap">carry-outs</span> of <span class="mono">ADD</span> and <span class="mono">INC</span>, the <span class="nowrap">borrow-outs</span> of <span class="mono">SUB</span> and <span class="mono">DEC</span>, and the <span class="span">shift-outs</span> of the shift instructions are lost. There is no add-with-carry instruction nor a subtract-with-borrow instruction. All shift instructions <span class="nowrap">shift-in</span> <span class="mono">0</span>.</p> 

<p><span class="mono">Z</span> is set to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is zero; otherwise, it is reset to <span class="mono">0</span>.</p>

<p><span class="mono">N</span> is set to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is negative (if bit 7 is <span class="mono">1</span>); otherwise, it is reset to <span class="mono">0</span>.</p>

<p>Each arithmetic and logic instruction corresponds to a <span class="nowrap">1-byte</span> opcode with bits <span class="mono">0001xxxx</span>. Of the 16 possibilities, only 12 are assigned. Potential additions include bitwise <span class="mono">NOT</span> and shifts with other values. The set above was designed to satisfy the requirements of a single program, one that runs Tetris.</p>

<h3 id="set-instructions">Set</h3>

<h3 id="branch-instructions">Branch</h3>

<p>Branch instructions direct execution to an arbitrary location in the program. With one exception, they have the following format.</p>

<p class="definition">mnemonic label</p>

<p>A label is declared at the branch destination. It consists of an identifier followed by a colon. During assembly, it is interpreted as the address of the code immediately after it.</p>

<p>The branch instructions are summarized in the table below.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">JMP label</td><td class="borderless2">Jump</td><td class="mono">P = label;</td><td class="mono">20</td></tr>    
  <tr><td class="mono">BNE label</td><td class="borderless2">Branch Not Equal</td><td class="mono">if (Z == 0) P = label;</td><td class="mono">22</td></tr>
  <tr><td class="mono">BEQ label</td><td class="borderless2">Branch Equal</td><td class="mono">if (Z == 1) P = label;</td><td class="mono">23</td></tr>
  <tr><td class="mono">BPL label</td><td class="borderless2">Branch Plus</td><td class="mono">if (N == 0) P = label;</td><td class="mono">24</td></tr>
  <tr><td class="mono">BMI label</td><td class="borderless2">Branch Minus</td><td class="mono">if (N == 1) P = label;</td><td class="mono">25</td></tr>
  <tr><td class="mono">JSR label</td><td class="borderless2">Jump Subroutine</td><td class="mono">R = P; P = label;</td><td class="mono">28</td></tr>
  <tr><td class="mono">RTS</td><td class="borderless2">Return Subroutine</td><td class="mono">P = R;</td><td class="mono">70</td></tr>
</table>

<p><span class="mono">JSR</span> backs up the Program Counter, <span class="mono">P</span>, in the Return Register, <span class="mono">R</span>. <span class="mono">RTS</span> restores <span class="mono">P</span> from <span class="mono">R</span>. This enables calling subroutines one level deep.</p> 

<p>No other instructions can access <span class="mono">R</span>, thwarting the possibilities of a <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stack</a> or <a href="https://en.wikipedia.org/wiki/Indirect_branch" target="_blank">indirect branching</a>. But that complexity is not required for the Tetris program.</p> 

TODO Explain the opcodes.

<h2 id="assembly-language">Assembly Language</h2>

<h3 id="assembly-language-literals">Literals</h3>

<p>A byte literal consists of 2 hexadecimal digits. Examples follow.</p>

<pre class="code">
<span class="line"><span class="keyword">define</span> <span class="identifier">X</span> <span class="number">42</span>    <span class="comment">; #define X 0x42</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="number">D3</span>         <span class="comment">; A = 0xD3;</span></span>
<span class="line"></span>
<span class="line"><span class="label">i:</span> <span class="number">00</span>          <span class="comment">; i = 0;</span></span>
<span class="line"></span>
<span class="line"><span class="label">values:</span>        <span class="comment">; values[] = { 0xFF, 0x00, 0x01, 0x0B, 0xF5, 0xFF, 0x00, 0x0B };</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span></span>
</pre>

<p>Line <span class="mono">1</span> declares the constant <span class="mono">X</span>, which can be used as an instruction operand in place of <span class="mono">42</span> (hex).</p>

<p>Line <span class="mono">3</span> is an instruction that sets register <span class="mono">A</span> to <span class="mono">D3</span>.</p>

<p>Line <span class="mono">5</span> demonstrates how to create a byte variable. It declares a symbolic label called <span class="mono">i</span>. A label is a constant assigned to the address of the code immediately following its colon, which, in this case, is a literal that allocates and initializes a byte to zero. Put another way, <span class="mono">i</span> is a fixed pointer to the byte.</p>

<p>Line <span class="mono">7</span> declares a symbolic label called <span class="mono">values</span>. It is followed by literals that allocate and initialize 8 bytes, making <span class="mono">values</span> a fixed pointer to the start of a byte array.</p>

<h3 id="assembly-language-define">DEFINE</h3>

</body>

</html>
