<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html lang="en">

<head>
<title>Tetris is Turing-complete</title>
<link rel="stylesheet" href="style.css?v=2022-10-29" type="text/css"/>
<link rel="icon" href="favicon.svg" type="image/svg+xml"/>
<link rel="icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="shortcut icon" href="favicon.ico" sizes="any" type="image/x-icon"/>
<link rel="mask-icon" href="mask-icon.svg" color="#000000"/>
<link rel="apple-touch-icon" href="apple-touch-icon.png"/>
<link rel="manifest" href="manifest.json"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Bentham&family=Open+Sans&family=Source+Code+Pro&family=Source+Serif+Pro&family=Roboto+Mono&display=swap" rel="stylesheet"/>
<meta name="theme-color" content="#FFFFFF"/>
<meta name="date" content="2022-10-29"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

<body>

<p class="title">Tetris is Turing-complete</p>

<p>This article presents a method for embedding a programmable, general-purpose, digital computer into Tetris. It describes the capabilities and performance of an implementation that runs Tetris on Tetris.</p>

<h1 id="introduction">Introduction</h1>

<p>This section introduces a way to calculate within Tetris.</p>

<h2 id="fundamentals">Fundamentals</h1>

<p>The <span class="term">playfield</span> is the grid of square cells where Tetris is played. The standard playfield, shown below, consists of twenty visible rows and ten columns, but the dimensions are arbitrary.</p>

<object data="standard-playfield.svg" type="image/svg+xml" class="diagram">Standard Playfield</object>

<p>Each playfield cell is in one of two states: empty or solid.</p>

<p><span class="term">Tetriminos</span>&mdash;the falling pieces&mdash;are composed of four solid cells, painted any color. Each has a single-character, shape-based name:</p>

<object data="seven-tetriminos.svg" type="image/svg+xml" class="diagram">Seven Tetriminos</object>

<p>A <span class="term">rotation system</span> describes how Tetriminos rotate in relation to the surrounding cells and the playfield boundaries. This project uses the right-handed <a href="https://tetris.wiki/Nintendo_Rotation_System" target="_blank">Nintendo Rotation System</a> (NRS), due to its simplicity. But <a href="https://tetris.wiki/Category:Rotation_systems" target="_blank">various rotation systems</a> exist and any of them will work just as well.</p>

<p>NRS centers each Tetrimino in a 5&times;5 matrix and it quarter turns them. Of the 28 possible orientations, it uses only 19:</p>

<object data="orientation-table.svg" type="image/svg+xml" class="diagram">Orientation Table</object>

<p>In the table above, the leftmost column comprises the <span class="term">spawn orientations</span>, the way the pieces initially appear. The steps of clockwise rotation span left-to-right. And the mnemonic over each orientation consists of Tetrimino type concatenated with the first letter of &ldquo;down&rdquo;, &ldquo;left&rdquo;, &ldquo;up&rdquo;, &ldquo;right&rdquo;, &ldquo;horizontal&rdquo;, &ldquo;vertical&rdquo;, or nothing for O.</p>

<p>A <span class="term">move</span> is a 90&deg; rotation or a one-cell translation of the piece in play. The following terms apply to translation.</p>

<ul>
    <li>A <span class="term">shift</span> is a horizontal translation.</li>
    <li>A <span class="term">drop</span> is a downward translation.
        <ul>
            <li>A <span class="term">soft drop</span> is a player-controlled, one-cell drop.</li>
            <li>A <span class="term">hard drop</span> is a player-controlled, drop as far down as the piece can go. The move <span class="term">locks</span> the piece where it lands.</li>
            <li>A <span class="term">gravity drop</span> is an automatic, one-cell drop triggered by the <span class="term">fall timer</span>.</li>
        </ul>
    </li>
</ul>

<p>A move is preceded by a <span class="term">request to move</span>. Per NRS, the request is granted iff all four cells of the transformed Tetrimino are empty and they are within the bounds of the playfield. If the fall timer’s request for a gravity drop is denied, the piece locks and the next piece spawns.</p>

<p>Spawning involves a <span class="term">randomizer</span>, the mechanism that determines the sequence of pieces presented to the player. Any randomizer guaranteed to eventually produce all Tetriminos types in some order from any point in the sequence will work with the method described in this article.</p>

<h2 id="method-overview">Method Overview</h2>

<p>A process encodes input data into the cells of the <span class="nowrap">bottom-two</span> rows of a playfield infinite in width and height, but bounded by the floor. An <span class="term">agent</span> drops Tetriminos onto those cells, forming a structure that functions identical to a combinational logic circuit. A process decodes output data from the <span class="nowrap">top-two</span> rows of that structure:</p>

<object data="boolean-circuit.svg" type="image/svg+xml" class="diagram">Boolean Circuit</object>

<p>The agent builds a second structure above the first, such that the output rows of the first serve as the input rows of the second. It repeats with a third structure, a fourth, a fifth, and so on. The effect is a state machine, where the data rows are the states and the structures are the transition functions:</p>

<object data="state-machine.svg" type="image/svg+xml" class="diagram">State Machine</object>

<p>There exists a modification of this technique where the data capacity of a state always exceeds its predecessor. The modification provides a way to build an abstract computing device with unbounded storage that can simulate an arbitrary Turing machine operating on a given input.</p>

<h2 id="blindfolded-agent">The Blindfolded Agent</h2>

<p>If the agent can see, then it can be the calculator. That is, a sighted agent can read input by observing the playfield, it can perform calculations by its own means, and it can write output by dropping pieces that update the playfield. In other words, it can make Tetris function like RAM.</p>

<p>To eliminate that possibility, the agent must play blindfolded. Input data, intermediate states, and output data must be inaccessible to the agent. With that constraint, if the system composed of the agent and the game processes information in the manor of a computer, then Tetris must be functioning as both RAM and a CPU.</p>

<h2 id="infinite-playfield">Infinite Playfield</h2>

<p>On an infinite playfield, Tetriminos spawn at row infinity and column zero. When a newly spawned piece falls, it never gets closer to the floor due to the nature of infinity. This means, in finite&mdash;though potentially vast&mdash;time, the agent can shift the piece into any finite column. And once in position, the agent can hard drop the piece.</p>  

<p>A hard drop attempts to vertically translate the piece from row infinity to row zero, crossing all the space in between in the same time it takes to perform a soft drop. Along the way, the piece can encounter a barrier of solid cells that stops it. And, once stopped, the piece locks into place.</p> 

<p>A more generalized version, the <span class="term">semihard drop</span>, attempts to vertically translate the piece from row infinity to a specified, finite row. If it encounters a barrier along the way, it locks into place. Otherwise, the agent is free to shift, rotate, and drop the piece from there. A semihard dropped piece does get closer to the floor as it falls because the move puts it on a finite row.</p>

<p>The agent’s actions are limited to those that take finite time. It cannot clear a line because it cannot carry out the infinite moves required to arrange infinite pieces into a line. But, as demonstrated in successive sections, it can build structures of unbounded, yet finite, width and height.</p> 

<p>Since the agent cannot clear lines, the game remains stuck on the first level. It perpetually runs at the lowest drop speed.</p>

<h2 id="spawn-signal">Spawn Signal</h2>

<p>With no visual feedback, the blindfolded agent precisely controls the falling piece with a carefully timed sequence of requests to move it. The agent knows when to begin the sequence because the game provides a signal that conveys the randomly selected Tetrimino type to the agent when a spawn occurs.</p>

<p>On a completely empty playfield, the game would satisfy every request in the sequence and the agent would know exactly where the piece is at any time. But the playfield is not necessarily empty and the agent is not privy to its contents.</p>

<p>Since the game denies requests to move the piece into solid cells, the blindfolded agent can never be certain where a piece ultimately ends up. For example, in the animation below, the agent attempts to shift the <span class="nowrap">O-Tetrimino</span> into <span class="nowrap">column 1</span>. The attempt works on the empty playfield on the left, but it fails on the nonempty playfield on the right.</p>

<object data="shift-interruption.svg" type="image/svg+xml" class="diagram">Shift Interruption</object>

<p>In the following example, the agent attempts to drop the <span class="nowrap">O-Tetrimino</span> onto the floor. Again, the attempt works on the empty playfield on the left, but it fails on the nonempty playfield on the right.</p>

<object data="drop-interruption.svg" type="image/svg+xml" class="diagram">Drop Interruption</object>

<p>Since the spawn signal occurs shortly after a piece locks, the agent could abuse it to learn about the contents of the playfield. Specifically, it could semihard drop a piece into a column and then monitor how long it takes gravity to trigger the spawn signal. That duration is proportional to the column height.</p>

<p>To render such abuse ineffective, the game only provides a spawn signal subsequent to a hard drop. In other words, the agent must force the piece to lock. If it waits for gravity to do so, it will not be signaled when the next piece spawns.</p>

<h2 id="type-filtering">Type Filtering</h2>

<p>Building a structure logically-equivalent to a Boolean circuit requires placement of a specific sequence of Tetriminos. But the agent cannot summon the pieces it needs into existence. Instead, it filters the provided pieces. When the randomizer spawns a piece the agent does not want, the agent hard drops it onto an unbounded pile of discards in column &minus;2.</p>

<object data="discards-pile.svg" type="image/svg+xml" class="diagram">Discards Pile</object>

<p>The agent makes structures from the remaining pieces in <span class="nowrap">columns &ge; 0</span>. That infinite region&mdash;bounded on the bottom by the floor and on the left by the discards pile&mdash;serves as the workspace for building circuits.</p>

<h2 id="boolean-circuit-nodes">Boolean Circuit Nodes</h2>

<p>Nodes consist of pairs of vertically-adjacent cells. They can be in the following states.</p>

<object data="boolean-circuit-nodes.svg" type="image/svg+xml" class="diagram">Boolean Circuit Nodes</object>

<ul>
    <li><span class="mono">0</span> (false) &mdash; lower-cell solid, upper-cell empty</li> 
    <li><span class="mono">1</span> (true) &mdash; upper-cell solid, lower-cell empty or solid</li>  
    <li><span class="mono">?</span> (unassigned) &mdash; both cells empty</li>  
</ul>

<p>Nodes are composed of one or more pairs, all in the same state. Typically, a node is a contiguous, horizontal line of pairs, but not necessarily. The pairs of a node can be separated in space, even vertically separated. The image below shows one possible encoding of <span class="mono">01010</span>.</p>

<object data="encoding-01010.svg" type="image/svg+xml" class="diagram">01010</object>

<p>The right-most bit is stored in a noncontiguous node.</p>

<h2 id="tetrisscript">TetrisScript</h2>

<p>The agent builds structures by executing <span class="term">TetrisScript</span>, a language for expressing where to put the pieces. It has only three instruction types. The first directs the agent to hard drop a specified Tetrimino into a specified column. It consists of the mnemonic describing the Tetrimino’s type and orientation, and the target column index:</p>

<p class="definition">mnemonic x</p>

<p>It commands the agent to:</p>

<ol>
    <li>Discard Tetriminos until the randomizer spawns the one specified by <span class="mono">mnemonic</span>'s type.</li> 
    <li>Rotate the piece into <span class="mono">mnemonic</span>'s orientation.</li>   
    <li>Shift the piece to column <span class="mono">x</span>.</li>   
    <li>Hard drop the piece.</li> 
</ol>

<p>The example below demonstrates this instructions type.</p>

<pre class="code">
<span class="filename">example1.t</span>
<span class="line"><span class="normal">td </span><span class="number">1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">5</span></span>
<span class="line"><span class="normal">zh </span><span class="number">9</span></span>
<span class="line"><span class="normal">o </span><span class="number">13</span></span>
<span class="line"><span class="normal">sh </span><span class="number">16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">20</span></span>
<span class="line"><span class="normal">ih </span><span class="number">25</span></span>
</pre>

<p>The code guides the agent to produce the following.</p>

<object data="example1.svg" type="image/svg+xml" class="diagram">example1</object>

<p>The second instruction type directs the agent to semihard drop a specified Tetrimino into a specified column down to a specified row. Then, it directs the agent to hard drop the Tetrimino into a different specified column. It consists of the mnemonic describing the Tetrimino’s type and orientation, the semihard drop’s column index, the semihard drop’s row index, and the hard drop's column index:</p>

<p class="definition">mnemonic x1 y x2</p>

<p>It commands the agent to:</p>

<ol>
    <li>Discard Tetriminos until the randomizer spawns the one specified by <span class="mono">mnemonic</span>'s type.</li> 
    <li>Rotate the piece into <span class="mono">mnemonic</span>'s orientation.</li>   
    <li>Shift the piece to column <span class="mono">x1</span>.</li>
    <li>Semihard drop the piece to row <span class="mono">y</span>.</li>
    <li>Shift the piece to column <span class="mono">x2</span>.</li>
    <li>Hard drop the piece.</li> 
</ol>

<p>If a gravity drop occurs after <span class="nowrap">step 4</span>, but before <span class="nowrap">step 5</span> finishes, the agent will misplace the piece. To avert that possibility, the agent has a timer synchronized with the fall timer, which it uses to semihard drop immediately after a gravity drop. Doing so maximizes the time to shift from <span class="nowrap">column <span class="mono">x1</span></span> to <span class="nowrap">column <span class="mono">x2</span></span>. That strategy works as long as the distance between <span class="mono">x1</span> and <span class="mono">x2</span> is not greater-than the maximum shift achievable in the period between gravity drops.</p>

<p>The following code demonstrates the second instruction type.</p>

<pre class="code">
<span class="filename">example2.t</span>
<span class="line"><span class="normal">td </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">jd </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">zh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">o </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ld </span><span class="number">1 15 2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1 15 2</span></span>
</pre>

<p>Those are the instructions for the structure below.</p>

<object data="example2.svg" type="image/svg+xml" class="diagram">example2</object>

<p>The third instruction type provides a way to compose complex structures from simpler ones. It directs the agent to build a specified structure at a specified location. It consists of the name of the structure to build, the target column index, and the target row index:</p>

<p class="definition">structure x y</p>

<p>It commands the agent to:
  
<ol>  
    <li>Replace the instruction with the structure's TetrisScript program instructions.</li>
    <li>Increment the column and row arguments of each of the structure's instructions by <span class="mono">x</span> and <span class="mono">y</span>, respectively.</li>
    <li>Execute the modified instructions.</li>
</ol>

<p>The following code demonstrates this instruction type. It references the prior examples.</p>

<pre class="code">
<span class="filename">example3.t</span>
<span class="line"><span class="normal">example1 </span><span class="number">3 0</span></span>
<span class="line"><span class="normal">example2 </span><span class="number">14 2</span></span>
</pre>

<p>The agent expands those instructions, offsetting the column and row indices per the provided coordinates:</p>

<pre class="code">
<span class="filename">example3Expanded.t</span>
<span class="line"><span class="comment"># example1 3 0</span></span>
<span class="line"><span class="normal">td </span><span class="number">4</span></span>
<span class="line"><span class="normal">jd </span><span class="number">8</span></span>
<span class="line"><span class="normal">zh </span><span class="number">12</span></span>
<span class="line"><span class="normal">o </span><span class="number">16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">19</span></span>
<span class="line"><span class="normal">ld </span><span class="number">23</span></span>
<span class="line"><span class="normal">ih </span><span class="number">28</span></span>
<span class="line"></span>
<span class="line"><span class="comment"># example2 14 2</span></span>
<span class="line"><span class="normal">td </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">jd </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">zh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">o </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">sh </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ld </span><span class="number">15 17 16</span></span>
<span class="line"><span class="normal">ih </span><span class="number">15 17 16</span></span>
</pre>

<p>As exhibited by lines 1 and 10, <a href="https://en.wikipedia.org/wiki/Comment_(computer_programming)#Line_comments" target="_blank">line comments</a> begin with a <span class="mono">#</span> and they end with a <a href="https://en.wikipedia.org/wiki/Newline" target="_blank">newline</a> character. TetrisScript does not support <a href="https://en.wikipedia.org/wiki/Comment_(computer_programming)#Block_comment" target="_blank">block comments</a>.</p>

<p>The agent recursively expands instructions of the third type until all what remains are instructions of the first and second types. This means, <a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank">circular dependencies</a> are not allowed.</p>

<p>The code above guides the agent to create structure below.</p>

<object data="example3.svg" type="image/svg+xml" class="diagram">example3</object>

<p>To make testing circuits easier, TetrisScript provides <a href="https://en.wikipedia.org/wiki/Directive_(programming)" target="_blank">directives</a> for labeling nodes:</p>

<pre class="definition">
in name x1 y1 x2 y2 ... xN yN

out name x1 y1 x2 y2 ... xN yN
</pre>

<p>The node type, <span class="mono">in</span> or <span class="mono">out</span>, is followed by the node name. The successive coordinates specify the node location. They refer to the lower-cell of the vertically-adjacent pairs. Each coordinate is either a single integer or a range of integers, <span class="mono nowrap">min..max</span>.</p>

<p>The example below declares five input nodes.</p>

<pre class="code">
<span class="filename">nodes.t</span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">2..4 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">c </span><span class="number">6 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">d </span><span class="number">7 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">e </span><span class="number">9..10 0 12..13 0</span></span>
</pre>

<p>Node <span class="mono">a</span> is a single pair. Node <span class="mono">b</span> is a horizontal line consisting of three pairs. Nodes <span class="mono">c</span> and <span class="mono">d</span> are adjoining, single pairs. Node <span class="mono">e</span> is disjoint. They are illustrated below, where nodes <span class="mono">a</span>, <span class="mono">b</span>, <span class="mono">c</span>, <span class="mono">d</span>, and <span class="mono">e</span> are set to <span class="mono">0</span>, <span class="mono">1</span>, <span class="mono">0</span>, <span class="mono">1</span>, and <span class="mono">0</span>, respectively.</p>

<object data="nodes.svg" type="image/svg+xml" class="diagram">Nodes</object>

<h1 id="logic-gates">Logic Gates</h1>

<p>This section explains how to construct logic gates, structures that produce a single binary output from one or more binary inputs.</p>

<h2 id="buffer">Buffer</h2>

<p>A buffer is a single-input, binary <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a>. The output value is the input value, unchanged.</p>

<p>The code below realizes a buffer by dropping a vertical <span class="nowrap">I-Tetrimino</span> onto an input node.</p>

<pre class="code">
<span class="filename">buffer.t</span>
<span class="line"><span class="normal">iv </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 4</span></span>
</pre>

<p>The result for both input values follows.</p>

<object data="animated-buffer.svg" type="image/svg+xml" class="diagram">Animated Buffer</object>

<p>The cells of the output node mirror the cells of the input node. Any Tetrimino or any stack of Tetriminos can be used to copy data in this way.</p>

<h2 id="inverter-not">Inverter (NOT)</h2>

<p>An inverter is a single-input gate where the output is the <a href="https://en.wikipedia.org/wiki/Negation" target="_blank">complement</a> of the input.</p>

<p>The code below makes an inverter by sandwiching an <span class="nowrap">O-Tetrimino</span> between horizontal L- and J-Tetriminos.</p>

<pre class="code">
<span class="filename">not.t</span>
<span class="line"><span class="normal">lu </span><span class="number">0</span></span>
<span class="line"><span class="normal">o </span><span class="number">0 4 1</span></span>
<span class="line"><span class="normal">jd </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-1..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>Note: While workspace coordinates are always &ge; 0 due to the floor and the discards pile, structure definitions may contain negative column indices because the coordinates are relative to where the structure is built.</p>

<p>The following animation shows what happens for both input values.</p>

<object data="animated-not.svg" type="image/svg+xml" class="diagram">Animated NOT</object>

<p>When the input is <span class="mono">0</span>, the <span class="nowrap">L-Tetrimino</span> lands low. That enables the <span class="nowrap">O-Tetrimino</span> to shift upon the <span class="nowrap">L-Tetrimino's</span> protuberance. The <span class="nowrap">J-Tetrimino</span>, in turn, lands high, producing an output of <span class="mono">1</span>.</p>

<p>When the input is <span class="mono">1</span>, the <span class="nowrap">L-Tetrimino</span> lands high. That causes it to act a barrier that obstructs the horizontal movement of the <span class="nowrap">O-Tetrimino</span>. Consequentially, the <span class="nowrap">J-Tetrimino</span> lands low, generating an output of <span class="mono">0</span>.</p>

<p>In both cases, the output is the opposite of the input.</p>

<p>A horizontally reflected version exists purely for aesthetics reasons. The image below shows <span class="mono">notLeft</span> (an alias for <span class="mono">not</span>) and its reflection, <span class="mono">notRight</span>.</p>

<object data="nots.svg" type="image/svg+xml" class="diagram">notLeft and notRight</object>

<h2 id="or">OR</h2>

<p>OR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_disjunction" target="_blank">disjunction</a> of its inputs. That is, the output is <span class="mono">0</span> only when both inputs are <span class="mono">0</span>.</p>

<p>The code below creates an OR gate by dropping a single <span class="nowrap">O-Tetrimino</span> onto abutting input nodes.</p>

<pre class="code">
<span class="filename">or.t</span>
<span class="line"><span class="normal">o </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 2</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object data="or.svg" type="image/svg+xml" class="diagram">OR</object>

<p>The <span class="nowrap">O-Tetrimino</span> lands low unless one or both inputs is <span class="mono">1</span>.</p>

<h2 id="nor">NOR</h2>

<p>NOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_NOR" target="_blank">joint denial</a> of its inputs. That is, the output is <span class="mono">1</span> only when both inputs are <span class="mono">0</span>.</p>

<p>It is a <a href="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" target="_blank">universal gate</a>. NOR gates alone can be combined to form any other gate.</p>

<p>The code below realizes a NOR gate by feeding two inputs into an inverter.</p>

<pre class="code">
<span class="filename">nor.t</span>
<span class="line"><span class="normal">not </span><span class="number">0 0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 5</span></span>
</pre>

<p>The following image presents the outputs for all possible inputs.</p>

<object data="nor.svg" type="image/svg+xml" class="diagram">NOR</object>

<p>The <span class="nowrap">L-Tetrimino</span> operates as an OR gate, resulting in output opposite of OR.</p>

<h2 id="nand">NAND</h2>

<p>NAND is a <span class="nowrap">two-input</span> gate that outputs the complement of the <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a> of its inputs. That is, the output is <span class="mono">0</span> only when both inputs are <span class="mono">1</span>.</p>

<p>It is a universal gate. NAND gates alone can be combined to form any other gate.</p>

<p>The code below realizes NAND as inverters feeding into an OR. It is based on one of <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>, <span class="math"><span class="overline">AB</span> = <span class="overline">A</span> + <span class="overline">B</span></span>.</p>

<pre class="code">
<span class="filename">nand.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 6</span></span>
</pre>

<p>The follow image reveals the output for all possible inputs.</p>

<object data="nand.svg" type="image/svg+xml" class="diagram">NAND</object>

<p>The horizontal <span class="nowrap">I-Tetrimino</span> functions as an OR gate.</p>

<h2 id="and">AND</h2>

<p>AND is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">conjunction</a> of its inputs. That is, the output is <span class="mono">1</span> only when both inputs are <span class="mono">1</span>.</p>

<p>The code below constructs AND from a NAND gate connected to an inverter.</p>

<pre class="code">
<span class="filename">and.t</span>
<span class="line"><span class="normal">notLeft </span><span class="number">-2 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">1 0</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">0 5</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-3..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 10</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object data="and.svg" type="image/svg+xml" class="diagram">AND</object>

<p>The <span class="nowrap">J-Tetrimino</span> of the upper inverter functions as an OR gate.</p>

<h2 id="xor">XOR</h2>

<p>XOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Exclusive_or" target="_blank">exclusive disjunction</a> of its inputs. That is, it outputs <span class="mono">1</span> only when the inputs are unequal.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">A &oplus; B<span></p>
      
<p><span class="math">= (A &ne; B)</p>      
      
<p><span class="math">= <span class="overline">A</span>B + A<span class="overline">B</span></p>      
     
<p><span class="math">= <span class="overline">A</span>A + <span class="overline">A</span>B + A<span class="overline">B</span> + B<span class="overline">B</span><span></p>
      
<p><span class="math">= <span class="overline">A</span>(A + B) + <span class="overline">B</span>(A + B)</p>  

<p><span class="math">= <span class="overline">A</span> <span class="overline">C</span> + <span class="overline">B</span> <span class="overline">C</span>, C = <span class="overline">A + B</span></p>  

<p><span class="math">= <span class="overline">A + C</span> + <span class="overline">B + C</span>, C = <span class="overline">A + B</span></span></p>

<p>That suggests the following construction of XOR from 3 NOR gates and an OR gate.</p>

<object data="xor-schematic.svg" type="image/svg+xml" class="diagram">XOR Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">xor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">3</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">2 5</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 11</span></span>
</pre>

<p><span class="mono">_norLeft</span> is a compact NOR gate composed of two <span class="nowrap">O-Tetriminos</span>. It is detailed in <a href="#intermediate-gates">a later section</a>.</p>

<p>Here are the results for all input combinations:</p>

<object data="xor.svg" type="image/svg+xml" class="diagram">XOR</object>

<p>The L- and J-Tetriminos resting on the <span class="nowrap">O-Tetriminos</span> and the vertical <span class="nowrap">I-Tetriminos</span> act as wires. The bases of the inverters serve as OR gates, making them function as NORs. And the horizontal <span class="nowrap">I-Tetrimino</span> at the top operates as an OR gate.</p>

<h2 id="xnor">XNOR</h2>

<p>XNOR is a <span class="nowrap">two-input</span> gate that outputs the <a href="https://en.wikipedia.org/wiki/Logical_equality" target="_blank">equality</a> of its inputs. That is, the output is <span class="mono">1</span> only when the inputs are equal.</p>

<p>The code below constructs XNOR from an XOR gate connected to an inverter.</p>

<pre class="code">
<span class="filename">xnor.t</span>
<span class="line"><span class="normal">xor </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">0 11</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 16</span></span>
</pre>

<p>The following image shows the outputs for all possible inputs.</p>

<object data="xnor.svg" type="image/svg+xml" class="diagram">XNOR</object>

<h2 id="intermediate-gates">Intermediate Gates</h2>

<p>The <a href="#inverter-not">inverter described above</a> consists of an O wedged between an L and a J. However, it is possible to implement an inverter with a single <span class="nowrap">O-Tetrimino</span>:</p>

<pre class="code">
<span class="filename">_notLeft.t</span>
<span class="line"><span class="normal">o </span><span class="number">-1 2 0</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 1</span></span>
</pre>

<p>As shown in the animated constructions below, the input and output nodes overlap. When the input is <span class="mono">1</span>, the overlap establishes an output of <span class="mono">0</span> before the <span class="nowrap">O-Tetrimino</span> drops. Though, when the input is <span class="mono">0</span>, the output node is initially unassigned.</p>

<object data="animated-intermediate-not.svg" type="image/svg+xml" class="diagram">Intermediate NOT</object>

<p><span class="mono">_notLeft</span>'s compact size translates to smaller circuits, which should be motivation to use it frequently. But in practice, it is used sparingly because, when the input is <span class="mono">1</span>, it fails to support the <span class="nowrap">O-Tetrimino</span>. If that <span class="nowrap">O-Tetrimino</span> leaks out of a circuit, it will plummet until it meets the surface of the pile, where it can interfere with other circuits. The resultant unpredictable behavior renders such circuits incompatible with an important optimization, described in <a href="#simulation">a later section</a>, which depends on consistent circuit operation.</p>

<p>To use <span class="mono">_notLeft</span> safely, the <span class="nowrap">O-Tetrimino</span> must be caught. This is practical only in the interior of circuits, where the surrounding components act as barriers. There, <span class="mono">_notLeft</span> and other leaky gates are relegated to processing intermediate values, hence the designation, &ldquo;intermediate gates&rdquo;. Their names start with an underscore to make them instantly distinguishable from ordinary gates.</p>

<p>Smaller circuits suggest faster processing. But the aforementioned optimization makes circuits built purely out of ordinary gates compute just as quickly despite their larger size. There is no justification for intermediate gates except that their compact nature effectuates aesthetically pleasing designs. That is the impetus behind the following variation of the intermediate inverter.</p>

<pre class="code">
<span class="filename">_notLeft2.t</span>
<span class="line"><span class="normal">o </span><span class="number">-1 2 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 1</span></span>
</pre>

<p><span class="mono">_notLeft2</span> nudges the <span class="nowrap">O-Tetrimino</span> right twice:</p>

<object data="animated-intermediate-not-2.svg" type="image/svg+xml" class="diagram">Intermediate NOT 2</object>

<p>The construction assumes the fall speed is slow enough to slide the <span class="nowrap">O-Tetrimino</span> across the surface of the input node when the input value is <span class="mono">0</span>.</p>

<p><span class="mono">_notLeft2</span> is attached to the output of an ordinary OR gate to create an intermediate NOR gate:</p>

<pre class="code">
<span class="filename">_norLeft.t</span>
<span class="line"><span class="normal">or </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">_notLeft2 </span><span class="number">-1 2</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">0 3</span></span>
</pre>

<p>Its response to all possible inputs appears below.</p>

<object data="intermediate-nor.svg" type="image/svg+xml" class="diagram">Intermediate NOR</object>

<p>On <span class="nowrap">line 2</span> of the code, if <span class="mono">_notLeft2</span> is replaced with <span class="mono">_notLeft</span>, the intermediate NOR gate works just as well. However, when both inputs are <span class="mono">0</span>, the vertical column of <span class="nowrap">O-Tetriminos</span> becomes lopsided, an aesthetically displeasing configuration.</p>

<p><span class="mono">_norLeft</span> is found in the interior of the ordinary XOR gate to reduce its size and to guarantee the <span class="nowrap">O-Tetrimino</span> is always caught.</p>

<p>The &ldquo;<span class="mono">Left</span>&rdquo; in the names of these intermediate gates refers the side of the inputs nudged by the <span class="nowrap">O-Tetrimino</span>. Horizontally-reflected versions exist called <span class="mono">_notRight</span>, <span class="mono">_notRight2</span>, and <span class="mono">_norRight</span>.</p>

<p>The intermediate NAND gate, <span class="mono">_nand</span>, uses intermediate inverters to feed input complements into an ordinary OR gate:</p>

<pre class="code">
<span class="filename">_nand.t</span>
<span class="line"><span class="normal">_notLeft </span><span class="number">-1 0</span></span>
<span class="line"><span class="normal">_notRight </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">or </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 3</span></span>
</pre>

<p>Intermediate NAND leaks up to two <span class="nowrap">O-Tetriminos</span>:</p>

<object data="intermediate-nand.svg" type="image/svg+xml" class="diagram">Intermediate NAND</object>

<p>The intermediate AND gate, <span class="mono">_andLeft</span>, consists of an intermediate NAND in series with an intermediate inverter:</p>

<pre class="code">
<span class="filename">_andLeft.t</span>
<span class="line"><span class="normal">_nand </span><span class="number">0 0</span></span>
<span class="line"><span class="normal">_notLeft2 </span><span class="number">-1 3</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 4</span></span>
</pre>

<p>Here is its responses to all inputs:</p>

<object data="intermediate-and.svg" type="image/svg+xml" class="diagram">Intermediate AND</object>

<p>Its horizontally-reflected version goes by the name <span class="mono">_andRight</span>.</p>

<p>While a single intermediate NOR appears in the ordinary XOR, the intermediate XOR, <span class="mono">_xor</span>, employs three of them:</p>

<pre class="code">
<span class="filename">_xor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">3</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">_norRight </span><span class="number">3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">or </span><span class="number">0 9</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">a </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">b </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..0 11</span></span>
</pre>

<p>Like the intermediate NAND and AND gates, intermediate XOR emits up to two <span class="nowrap">O-Tetriminos</span>:</p>

<object data="intermediate-xor.svg" type="image/svg+xml" class="diagram">Intermediate XOR</object>

<p>Other intermediate gates are possible. But aside from the intermediate NOR gate and the intermediate inverter it is based on, the rest are not used. Their petiteness and visual appeal are not compelling enough to use them over ordinary gates, which operate safely in all circumstances.</p>

<h1 id="wires">Wires</h1>

<p>This section discusses <span class="term">wires</span>, the structures that transfer bits from one part of a circuit to another.</p>

<h2 id="fan-out">Fan-out</h2>

<p><span class="term">Fan-out</span> is the number of connections radiating from an output node. As illustrated in the animation below, lines of S- and Z-Tetriminos enable unlimited fan-out.</p>

<object data="fan-out.svg" type="image/svg+xml" class="diagram">Fan-out</object>

<p>Rising staircases of horizontal I-Tetriminos can achieve the same.</p>

<h2 id="fan-in">Fan-in</h2>

<p>Wires that converge on a common node require a device to combine their signals, such as a multi-input OR gate. <span class="term">Fan-in</span> is the number of inputs of such a device. As demonstrated in the following animation, a line of Z- or S-Tetriminos can provide unlimited fan-in. </p>

<object data="fan-in.svg" type="image/svg+xml" class="diagram">Fan-in</object>

<p>Alternatively, a tree of gates can merge a boundless number of inputs.</p>

<h2 id="crossing">Crossing</h2>

<p>In a three-dimensional universe, wires can cross over each other without connecting. But on the two-dimensional playfield, a cross requires a planar device that mutually exchanges inputs. That device implements the <a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" target="_blank">XOR swap algorithm</a>. It stores the XOR of inputs <span class="math">A</span> and <span class="math">B</span> into a temporary variable, <span class="math">C</span>:</p>

<p><span class="math">C = A &oplus; B</span></p>

<p>Then it XORs the inputs with that temporary variable, which swaps them:</p>

<p><span class="math">A &oplus; C = A &oplus; A &oplus; B = B</span></p>

<p><span class="math">B &oplus; C = B &oplus; A &oplus; B = A</span></p>

<p>Those steps suggests this circuit:</p>

<object data="swap-schematic.svg" type="image/svg+xml" class="diagram">Swap Schematic</object>

<p>Since two-dimensional XOR gates exist and the circuit does not contain any cross-overs, it achieves a planar swap.</p>

<p>In following the actualization, the lower XOR gate of the schematic is made from three NORs and a horizontal I-Tetrimino operating as an OR. The other pieces function as wires.</p>

<pre class="code">
<span class="filename">swap.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">ll </span><span class="number">-4</span></span>
<span class="line"><span class="normal">jr </span><span class="number">3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">5</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">lu </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ju </span><span class="number">1</span></span>
<span class="line"><span class="normal">_norLeft </span><span class="number">-3 5</span></span>
<span class="line"><span class="normal">_norRight </span><span class="number">3 5</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">2</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">6 7</span></span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">jd </span><span class="number">-6</span></span>
<span class="line"><span class="normal">ld </span><span class="number">5</span></span>
<span class="line"><span class="normal">xor </span><span class="number">-4 10</span></span>
<span class="line"><span class="normal">xor </span><span class="number">4 10</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i1 </span><span class="number">-4..-1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">i0 </span><span class="number">0..3 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o1 </span><span class="number">-6..-3 21</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o0 </span><span class="number">2..5 21</span></span>
</pre>

<p>As demonstrated below, the outputs are the inputs, but positionally exchanged.</p>

<object data="swap.svg" type="image/svg+xml" class="diagram">Swap</object>

<p>The following animation shows a diagonal wire crossing over multiple vertical wires via repeated application of the swap circuit.</p>

<object data="cross-seven.svg" type="image/svg+xml" class="diagram">Cross Seven</object>

<h2 id="multiplexing">Multiplexing</h2>

<p>A <span class="term">multiplexer</span> is a switch that channels one of the inputs to the output. A <span class="nowrap">2-to-1</span> multiplexer outputs <span class="math">AS + B<span class="overline">S</span></span>, where <span class="math">A</span> and <span class="math">B</span> are the inputs, and <span class="math">S</span> is the <span class="term">selector</span> that controls the switch.</p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math">AS + B<span class="overline">S</span></span></p>

<p><span class="math">= AS + <span class="high-overline"><span class="overline">B</span> + S</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">AS</span>(<span class="overline">B</span> + S)</span></span></p>

<p>That suggests two NAND gates, an OR gate, and an inverter arranged as follows.</p>

<object data="mux-schematic.svg" type="image/svg+xml" class="diagram">Multiplexer Schematic</object>

<p>The code below is based on that schematic.</p>

<pre class="code">
<span class="filename">muxLeft.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-4</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-4 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-1 1</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">4 1</span></span>
<span class="line"><span class="normal">jr </span><span class="number">1</span></span>
<span class="line"><span class="normal">o </span><span class="number">2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">ih </span><span class="number">3</span></span>
<span class="line"><span class="normal">nand </span><span class="number">0 7</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">l </span><span class="number">-6..-3 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">s </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">r </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 13</span></span>
</pre>

<p>Here are the results for all input combinations:</p>

<object data="mux.svg" type="image/svg+xml" class="diagram">Multiplexer</object>

<p>The selector (the center input) is <span class="mono">0</span> in the upper-row and <span class="mono">1</span> in the lower-row.</p>

<p>As suggested by its name, <span class="mono">muxLeft</span> outputs the left-input when the selector is <span class="mono">1</span>. A horizontally-reflected version, <span class="mono">muxRight</span>, outputs the right-input when the selector is <span class="mono">1</span>.</p>

<h1 id="functions">Functions</h1>

<p>This section describes the arithmetic and logic functions created for the machine that runs Tetris.</p>

<h2 id="building-blocks">Composition</h2>

<p>Function surfaces are   Two functions are <a href="https://en.wikipedia.org/wiki/Function_composition" target="_blank">composed</a> by building one on top of the other. Upon contact, the output of one function becomes the input of other. To ensure compatibility, functions are designed with the following rules.</p>

<ul>
  <li>The bottom and top surfaces of the function consist of the input and output nodes are arranged in a row, respectively.</li>

  
<li>The number of input nodes equals the number of output nodes. It varies per function, but the number is either 8, 16, or 24.</li>
<li>The input and outputs are a row of single-column nodes, evenly spaced, ten columns apart. The spacing provides sufficient room for bits to cross or to combine. And a round, base-10 number simplifies measurements during design.</li>
<li>The input and output nodes line up. That is, the input node for the <span class="math">i<span class="sup">th</span></span> bit of the input value is in the same column as the output node for the <span class="math">i<span class="sup">th</span></span> bit of the output value.</li> 
<li>The number of rows between the inputs and the outputs is always the same. Meaning, functions have a uniform height.</li>
</ul>

<h2 id="arrays">Arrays</h2>

<p>Some <span class="nowrap">16-bit</span> functions interpret the input value, <span class="math">V</span>, as a <span class="nowrap">2-byte</span> array, <span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span>, where <span class="math">A</span> and <span class="math">B</span> are the high and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 652px">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top right green">B<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>Similarly, some <span class="nowrap">24-bit</span> functions interpret the input value, <span class="math">V</span>, as a <span class="nowrap">3-byte</span> array, <span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span>, where <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> are the high, middle, and low bytes of <span class="math">V</span>, respectively:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top red">A<span class="sub">7</span></td><td class="top red">A<span class="sub">6</span></td><td class="top red">A<span class="sub">5</span></td><td class="top red">A<span class="sub">4</span></td><td class="top red">A<span class="sub">3</span></td><td class="top red">A<span class="sub">2</span></td><td class="top red">A<span class="sub">1</span></td><td class="top red">A<span class="sub">0</span></td><td class="top green">B<span class="sub">7</span></td><td class="top green">B<span class="sub">6</span></td><td class="top green">B<span class="sub">5</span></td><td class="top green">B<span class="sub">4</span></td><td class="top green">B<span class="sub">3</span></td><td class="top green">B<span class="sub">2</span></td><td class="top green">B<span class="sub">1</span></td><td class="top green">B<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>One <span class="nowrap">24-bit</span> function interprets the input value, <span class="math">V</span>, as a <span class="nowrap">two-element</span> array, <span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span>, where <span class="math">W</span> is a word composed of the high and middle bytes of <span class="math">V</span>, and <span class="math">C</span> is the low byte of <span class="math">V</span>:</p>

<table class="bits" style="width: 978px;">
<tr><td class="top cyan">W<span class="sub">15</span></td><td class="top cyan">W<span class="sub">14</span></td><td class="top cyan">W<span class="cyan">13</span></td><td class="top cyan">W<span class="sub">12</span></td><td class="top cyan">W<span class="sub">11</span></td><td class="top cyan">W<span class="sub">10</span></td><td class="top cyan">W<span class="sub">9</span></td><td class="top cyan">W<span class="sub">8</span></td><td class="top cyan">W<span class="sub">7</span></td><td class="top cyan">W<span class="sub">6</span></td><td class="top cyan">W<span class="sub">5</span></td><td class="top cyan">W<span class="sub">4</span></td><td class="top cyan">W<span class="sub">3</span></td><td class="top cyan">W<span class="sub">2</span></td><td class="top cyan">W<span class="sub">1</span></td><td class="top cyan">W<span class="sub">0</span></td><td class="top yellow">C<span class="sub">7</span></td><td class="top yellow">C<span class="sub">6</span></td><td class="top yellow">C<span class="sub">5</span></td><td class="top yellow">C<span class="sub">4</span></td><td class="top yellow">C<span class="sub">3</span></td><td class="top yellow">C<span class="sub">2</span></td><td class="top yellow">C<span class="sub">1</span></td><td class="top right yellow">C<span class="sub">0</span></td></tr>
<tr><td class="bottom blue">V<span class="sub">23</span></td><td class="bottom blue">V<span class="sub">22</span></td><td class="bottom blue">V<span class="sub">21</span></td><td class="bottom blue">V<span class="sub">20</span></td><td class="bottom blue">V<span class="sub">19</span></td><td class="bottom blue">V<span class="sub">18</span></td><td class="bottom blue">V<span class="sub">17</span></td><td class="bottom blue">V<span class="sub">16</span></td><td class="bottom blue">V<span class="sub">15</span></td><td class="bottom blue">V<span class="sub">14</span></td><td class="bottom blue">V<span class="sub">13</span></td><td class="bottom blue">V<span class="sub">12</span></td><td class="bottom blue">V<span class="sub">11</span></td><td class="bottom blue">V<span class="sub">10</span></td><td class="bottom blue">V<span class="sub">9</span></td><td class="bottom blue">V<span class="sub">8</span></td><td class="bottom blue">V<span class="sub">7</span></td><td class="bottom blue">V<span class="sub">6</span></td><td class="bottom blue">V<span class="sub">5</span></td><td class="bottom blue">V<span class="sub">4</span></td><td class="bottom blue">V<span class="sub">3</span></td><td class="bottom blue">V<span class="sub">2</span></td><td class="bottom blue">V<span class="sub">1</span></td><td class="bottom right blue">V<span class="sub">0</span></td></tr>
</table>

<p>A function that accepts an array will return an array of identical dimension.</p>

<h2 id="identity">Identity</h2>

<p>An <a href="https://en.wikipedia.org/wiki/Identity_function" target="_blank">identity function</a> echos the provided value:</p>

<p><span class="math">f(x) = x</span></p> 

<p>The image below depicts an <span class="nowrap">8-bit</span> identity function of an arbitrary height.</p>

<object data="identity.svg" type="image/svg+xml" class="diagram">Identity</object>

<h2 id="constant">Constant</h2>

<p>A constant function outputs the same value regardless of its input:</p>

<p><span class="math">f(x) = k</span></p>

<p>A <span class="nowrap">1-bit</span> function that always returns <span class="mono">0</span> is realized by XORing the input with itself:</p>

<p><span class="math">f(A) = A &oplus; A = </span><span class="serif">0</span></p>

<p>The code below links both inputs of an XOR gate with a horizontal I-Tetrimino.</p>

<pre class="code">
<span class="filename">false.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-2..1 12</span></span>
</pre>

<p>The tests in the following image affirm the circuit consistently outputs <span class="mono">0</span>.</p>

<object data="false.svg" type="image/svg+xml" class="diagram">False</object>

<p>A <span class="nowrap">1-bit</span> function that always returns <span class="mono">1</span> is realized by XNORing the input with itself:</p>

<p><span class="math">f(A) = <span class="overline">A &oplus; A</span> = </span><span class="serif">1</span></p>

<p>A horizontal I-Tetrimino joins the inputs of an XNOR gate in the code below.</p>

<pre class="code">
<span class="filename">true.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">xnor </span><span class="number">0 1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">i </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">o </span><span class="number">-1..1 17</span></span>
</pre>

<p>The following image reveals the circuit invariably yields <span class="mono">1</span>.</p>

<object data="true.svg" type="image/svg+xml" class="diagram">True</object>

<p>A constant byte function is an assemblage of eight <span class="nowrap">1-bit</span> constant functions. The image below depicts the constant byte function <span class="nowrap"><span class="math">f(x) = </span><span class="serif">0</span></span> for an arbitrary input value.</p>

<object data="clear.svg" type="image/svg+xml" class="diagram">Clear</object>

<p>And here is the requisite <span class="math">f(x) = </span><span class="serif">42</span> function:</p>

<object data="constant-42.svg" type="image/svg+xml" class="diagram">42</object>

<h2 id="logical-left-shift">Logical Left Shift</h2>

<p>Logical left shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the left. The rightmost bit is set to <span class="mono">0</span> and the leftmost bit is lost:</p>

<object data="logical-left-shift.svg" type="image/svg+xml" class="diagram">Logical Left Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting a signed or unsigned value left by <span class="math">n</span> bits is equivalent to multiplying by <span class="serif">2</span><span class="math pow">n</span>: 

<p><span class="math">f(x) = </span><span class="serif">2</span><span class="math pow">n</span><span class="math">x</span></p>

<h2 id="logical-right-shift">Logical Right Shift</h2>

<p>Logical right shift is an <span class="nowrap">8-bit</span> function that moves every input bit one position to the right. The leftmost bit is set to <span class="mono">0</span> and the right most bit is lost:</p>

<object data="logical-right-shift.svg" type="image/svg+xml" class="diagram">Logical Right Shift</object>

<p>The circuit can be stacked to shift by an arbitrary number of bit positions. Shifting an unsigned value right by <span class="math">n</span> bits is equivalent to dividing by <span class="serif">2</span><span class="math pow">n</span>, rounding toward <span class="serif">0</span>:</p>

<p><span class="math">f(x) = </span><span class="math">x</span><span class="serif"> / 2</span><span class="math pow">n</span></p>

<h2 id="logical-and">Logical AND</h2>

<p>The logical AND function operates on a <span class="nowrap">3-byte</span> array, where all three bytes are Booleans, values restricted to <span class="mono">0</span> and <span class="mono">1</span>. It ANDs the first and second bytes together, and it puts the result in the third byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="math">]</span>, where <span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">C = AB</span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are ANDed together:</p>

<object data="and-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Logical AND Schematic</object>

<p>In the Tetris realization below, the AND gate is miniscule in comparison to the swap circuits required for <span class="math">A<span class="sub">0</span></span> to traverse the <span class="math">B</span> lines.</p>

<object data="and-a-b-c.svg" type="image/svg+xml" class="diagram">Logical AND</object>

<h2 id="logical-and-not">Logical AND-NOT</h2>

<p>The logical AND-NOT function operates on a <span class="nowrap">2-byte</span> array, where both bytes are Booleans, values restricted to <span class="mono">0</span> and <span class="mono">1</span>. It replaces the first byte with the first byte ANDed with the inverse of the second byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q = A<span class="overline">B</span></span></p>

<p><span class="math">B</span> passes through unchanged, while <span class="math">A</span> is lost.</p>

<p>Since <span class="math">A</span> and <span class="math">B</span> are Booleans, only their lowest bits are used to produce <span class="math">Q</span>:</p>

<object data="and-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>The wire leading to the inverter&mdash;the horizontal line in the schematic above&mdash;appears diagonal in the Tetris realization because it consists of swap circuits stacked right-to-left, the arrangement required to propagate the signal across the <span class="math">B</span> lines:</p>

<object data="and-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>There is a variation that operates on a 3-byte array, where all three bytes are Booleans. It sets the first byte to the second byte ANDed with the inverse of the third byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="math">]</span>, where <span class="math">A,B,C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">C = A<span class="overline">B</span></span></p>

<p><span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p>As above, only the lowest bits of <span class="math">A</span> and <span class="math">B</span> are used to generate the result:</p>

<object data="and-c-a-not-b-schematic.svg" type="image/svg+xml" class="diagram">Logical AND NOT Schematic</object>

<p>The Tetris version follows.</p>

<object data="and-c-a-not-b.svg" type="image/svg+xml" class="diagram">Logical AND NOT</object>

<h2 id="bitwise-and">Bitwise AND</h2>

<p>The bitwise AND function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise AND of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = AB</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an AND gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-and-fb-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>In the Tetris version below, the AND gates are arranged in a line in the top-left. The space-dominating parallelogram is composed of parallel chains of swap circuits that propagate the bits of <span class="math">B</span> from right-to-left. Each chain is equivalent to one of the horizontal wires in the schematic. Since the swap circuits must be stacked to form a chain, the signals advance diagonally-upward.</p>

<object data="bitwise-and-fb.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<p>There is a variation that sets the second byte to the bitwise AND of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q </span><span class="math">]</span></p>

<p><span class="math">Q = AB</span> and <span class="math">A</span> passes through, unchanged.</p>

<p>Its circuit is the horizontal reflection of the one above:</p>

<object data="bitwise-and-af-schematic.svg" type="image/svg+xml" class="diagram">Bitwise AND Schematic</object>

<p>The Tetris realization follows.</p>

<object data="bitwise-and-af.svg" type="image/svg+xml" class="diagram">Bitwise AND</object>

<h2 id="bitwise-or">Bitwise OR</h2>

<p>The bitwise OR function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise OR of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = A + B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an OR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-or-schematic.svg" type="image/svg+xml" class="diagram">Bitwise OR Schematic</object>

<p>In the Tetris version below, the line of yellow <span class="nowrap">O-Tetriminos</span> in the top-left are the OR gates. The explanation for the parallelogram is the same as the one described for bitwise AND.</p>

<object data="bitwise-or.svg" type="image/svg+xml" class="diagram">Bitwise OR</object>

<p>A horizontally reflected version was not implemented.</p>

<h2 id="bitwise-xor">Bitwise XOR</h2>

<p>The bitwise XOR function operates on a <span class="nowrap">2-byte</span> array. It sets the first byte to the bitwise XOR of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="math">]</span></p>

<p><span class="math">Q = A &oplus; B</span> and <span class="math">B</span> passes through, unchanged.</p>

<p>As revealed in the following schematic, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of an XOR gate that combines each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, with each bit of <span class="math">B</span>, <span class="math">B<span class="sub">i</span></span>.</p>

<object data="bitwise-xor-schematic.svg" type="image/svg+xml" class="diagram">Bitwise XOR Schematic</object>

<p>In the Tetris version below, the XOR gates are arranged in a line in the top-left. The explanation for the parallelogram is the same as the one described for bitwise AND.</p>

<object data="bitwise-xor.svg" type="image/svg+xml" class="diagram">Bitwise XOR</object>

<p>A horizontally reflected version was not implemented.</p>

<h2 id="byte-swap">Byte Swap</h2>

<p>The byte swap function exchanges the elements of a <span class="nowrap">2-byte</span> array:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, A </span><span class="serif">]</span></p>

<p>It is realized with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object data="swap-8-schematic.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap Schematic</object>

<p>The diamond pattern in the schematic appears in the Tetris version below due to extensive use of the swap circuit.</p>

<object data="swap-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Swap</object>

<h2 id="byte-match">Byte Match</h2>

<p>The byte match function operates on a <span class="nowrap">2-byte</span> array:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, X</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, M </span><span class="serif">]</span></p>

<p><span class="math">A</span> is compared against a bit pattern. If it matches, <span class="math">M</span> is <span class="mono">1</span>; otherwise, <span class="math">M</span> is <span class="mono">0</span>. In either case, <span class="math">A</span> passes through unchanged, while <span class="math">X</span> is discarded.</p>

<p>The bit pattern consists of zeros, ones, and <a href="https://en.wikipedia.org/wiki/Don%27t-care_term" target="_blank">don’t-cares</a>. Meaning, each bit of <span class="math">A</span>, <span class="math">A<span class="sub">i</span></span>, is either compared against a constant or it is ignored. For example, the following expression checks if all <span class="math">A<span class="sub">i</span></span> are <span class="mono">1</span>:</p> 

<p><span class="math">M = A<span class="sub">7 </span>A<span class="sub">6 </span>A<span class="sub">5 </span>A<span class="sub">4 </span>A<span class="sub">3 </span>A<span class="sub">2 </span>A<span class="sub">1 </span>A<span class="sub">0 </span> = <span class="high-overline"><span class="overline2">A<span class="sub">7</span></span> + <span class="overline2">A<span class="sub">6</span></span> + <span class="overline2">A<span class="sub">5</span></span> + <span class="overline2">A<span class="sub">4</span></span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>That suggests the following circuit.</p>

<object data="match-ff-right-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Right</object>

<p>Each <span class="math">A<span class="sub">i</span></span> column contains an inverter pair, which enables <span class="math">A</span> to traverse unmodified. For an arbitrary constant, <span class="math">K</span>, inverter pairs only exist in the columns where <span class="math">K<span class="sub">i</span></span> is <span class="mono">1</span>. For instance, the expression below checks if <span class="math">A</span> is <span class="mono">0</span>:</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span> + A<span class="sub">1</span> + A<span class="sub">0</span></span></span></p>

<p>It requires no inverter pairs, as illustrated by the Tetris realization:</p>

<object data="match-zero-right.svg" type="image/svg+xml" class="diagram">Match Zero Right</object>

<p>Horizontal <span class="nowrap">J-Tetriminos</span> operate as OR gates. Each feeds an input bit to both terminals of a swap circuit.</p>

<p>The following expression checks if <span class="math">A</span> is binary value <span class="mono">00101111</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> A<span class="sub">5</span> <span class="overline2">A<span class="sub">4</span></span> A<span class="sub">3</span> A<span class="sub">2</span> A<span class="sub">1</span> A<span class="sub">0</span> = <span class="high-overline">A<span class="sub">7</span> + A<span class="sub">6</span> + <span class="overline2">A<span class="sub">5</span></span> + A<span class="sub">4</span> + <span class="overline2">A<span class="sub">3</span></span> + <span class="overline2">A<span class="sub">2</span></span> + <span class="overline2">A<span class="sub">1</span></span> + <span class="overline2">A<span class="sub">0</span></span></span></span></p>

<p>It is actualized by introducing inverter pairs corresponding to the <span class="mono">1</span> bits:</p>

<object data="match-smn-right.svg" type="image/svg+xml" class="diagram">Match SMN Right</object>

<p>Don’t-care bits are omitted from the OR chain. For instance, the following expression tests if A is <span class="mono">000000**</span>.</p>

<p><span class="math">M = <span class="overline2">A<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span></span> = <span class="overline2">A<span class="sub">7</span> + A<span class="sub">6</span> + A<span class="sub">5</span> + A<span class="sub">4</span> + A<span class="sub">3</span> + A<span class="sub">2</span></span></span></p>

<p>In the Tetris realization below, two of the horizontal <span class="nowrap">J-Tetriminos</span> are absent, enabling <span class="math">A<span class="sub">1</span></span> and <span class="math">A<span class="sub">0</span></span> to cross the OR chain without contributing to it.</p>

<object data="match-tax-right.svg" type="image/svg+xml" class="diagram">Match TAX Right</object>

<p>There is a variation of the byte match function where the parameters are swapped:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">X, A</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> M, A </span><span class="serif">]</span></p>

<p>Its circuit is nearly the horizontal-reflection of the one above:  </p>

<object data="match-ff-left-schematic.svg" type="image/svg+xml" class="diagram">Match $FF Left</object>

<p>In the Tetris version below, the inverter pairs are omitted, resulting in a zero detector. </p>

<object data="match-zero-left.svg" type="image/svg+xml" class="diagram">Match Zero Left</object>

<h2 id="equals">Equals</h2>

<p>The equals function operates on a <span class="nowrap">3-byte</span> array:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, X </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="serif">]</span></p>

<p><span class="math">E</span> is <span class="mono">1</span> if <span class="math">A</span> equals <span class="math">B</span>; otherwise, <span class="math">E</span> is <span class="mono">0</span>. Either way, <span class="math">A</span> and <span class="math">B</span> pass through unchanged, while <span class="math">X</span> is discarded.</p>

<p><span class="math">E</span> is defined by the following expression, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<p><span class="math">E = (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)</span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span></span></p>

<p>That suggests the following circuit.</p>

<object data="equals-a-b-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>In the Tetris version below, a constant bit function seeds the AND chain with <span class="mono">1</span> (see lower-right).</p>

<object data="equals-a-b-e.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Since the evaluation order is established by the sequence in which components are built, each input propagates upward as it advances from left-to-right. The diamond arrangement of swap circuits is a consequence of nearly-parallel, diagonally-upward lines that terminate on the vertical AND chain.</p>

<p>There is a variation of the equals function where the parameters are rearranged:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> X, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> E, A, B </span><span class="serif">]</span></p>

<p>Its circuit is roughly the horizontal-reflection of the one above:</p>

<object data="equals-e-a-b-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>Here is the Tetris realization:</p>

<object data="equals-e-a-b.svg" type="image/svg+xml" class="diagram">E = (A == B)</object>

<p>There is a another variation that uses all three input bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, V </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, B, E </span><span class="math">]</span>, where <span class="math">V,E </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">E</span> is <span class="mono">1</span> iff <span class="math">A</span> equals <span class="math">B</span> and <span class="math">V</span> is <span class="mono">1</span>:</p>

<p><span class="math">E = (A = B)V</span> 

<p><span class="math">= (A<span class="sub">7</span> = B<span class="sub">7</span>)(A<span class="sub">6</span> = B<span class="sub">6</span>)(A<span class="sub">5</span> = B<span class="sub">5</span>)(A<span class="sub">4</span> = B<span class="sub">4</span>)(A<span class="sub">3</span> = B<span class="sub">3</span>)(A<span class="sub">2</span> = B<span class="sub">2</span>)(A<span class="sub">1</span> = B<span class="sub">1</span>)(A<span class="sub">0</span> = B<span class="sub">0</span>)V<span class="sub">0</span></span></p>

<p><span class="math">= <span class="overline2">A<span class="sub">7</span> &oplus; B<span class="sub">7</span></span> <span class="overline2">A<span class="sub">6</span> &oplus; B<span class="sub">6</span></span> <span class="overline2">A<span class="sub">5</span> &oplus; B<span class="sub">5</span></span> <span class="overline2">A<span class="sub">4</span> &oplus; B<span class="sub">4</span></span> <span class="overline2">A<span class="sub">3</span> &oplus; B<span class="sub">3</span></span> <span class="overline2">A<span class="sub">2</span> &oplus; B<span class="sub">2</span></span> <span class="overline2">A<span class="sub">1</span> &oplus; B<span class="sub">1</span></span> <span class="overline2">A<span class="sub">0</span> &oplus; B<span class="sub">0</span></span> V<span class="sub">0</span></span></p>
  
<p>It provides a way to compare multiple bytes:</p>

<p><span class="math">V = (T = U)</span></p>

<p><span class="math">V&prime; = (R = S)V = (R = S)(T = U)</span></p>

<p><span class="math">V&Prime; = (P = Q)V&prime; = (P = Q)(R = S)(T = U)</span></p>

<p>And so on.</p>

<p>The variation can be realized by using the lowest bit of <span class="math">V</span> as the seed of the AND chain. Instead, in an effort to reuse wherever possible, an AND gate was added to the top of the existing circuit:</p>

<object data="equals-a-b-and-e-schematic.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The Tetris implementation follows.</p>

<object data="equals-a-b-and-e.svg" type="image/svg+xml" class="diagram">E = (A == B) V</object>

<p>The horizontal-reflection of this variation was not implemented. </p>

<h2 id="byte-copy">Byte Copy</h2>

<p>The byte copy function operates on a <span class="nowrap">2-byte</span> array. It copies the first byte to the second byte:</p> 

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> A, A </span><span class="serif">]</span></p>

<p>This is accomplished with the following wiring, where <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> are the <span class="math">i<span class="sup">th</span></span> bits of <span class="math">A</span> and <span class="math">B</span>, respectively.</p>

<object data="copy-a-b-schematic.svg" type="image/svg+xml" class="diagram">Copy A to B Schematic</object>

<p>The Tetris version appears below.</p>

<object data="copy-a-b.svg" type="image/svg+xml" class="diagram">Copy A to B</object>

<p>The space-dominating triangle consists of diagonally-upward chains of swap circuit. After they cross the center wire, horizontal lines of <span class="nowrap">Z-Tetriminos</span> carry the signals the rest of the way.</p>

<p>A variation of the function copies the second byte to the first byte:</p>

<p><span class="math">f(</span><span class="serif"> [</span><span class="math">A, B</span><span class="serif">] </span><span class="math">) = </span><span class="serif">[</span><span class="math"> B, B </span><span class="serif">]</span></p>

<p>It is the horizontal-reflection of the previous circuit:</p>

<object data="copy-b-a-schematic.svg" type="image/svg+xml" class="diagram">Copy B to A Schematic</object>

<p>The Tetris version follows.</p>

<object data="copy-b-a.svg" type="image/svg+xml" class="diagram">Copy B to A</object>

<h2 id="conditional-byte-copy">Conditional Byte Copy</h2>

<p>The conditional byte copy function operates on a <span class="nowrap">3-byte</span> array. It either copies the first byte to the second byte, or it does nothing, per the value of the third byte.</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> A, Q, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>In its circuit, shown below, each bit of <span class="math">Q</span>, <span class="math">Q<span class="sub">i</span></span>, is the output of a <span class="nowrap">2-to-1</span> multiplexer that selects between <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span> based on <span class="math">C<span class="sub">0</span></span>.</p>

<object data="copy-a-b-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Here is the Tetris version:</p>

<object data="copy-a-b-c.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Flipping the circuit horizontally creates a variation that either copies the third byte to the second byte, or does nothing, per the value of the first byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, Q, B </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">C</span> and <span class="math">B</span> pass through, unchanged.</p>

<p>The flipped circuit appears below.</p>

<object data="copy-c-b-a-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>The Tetris version follows.</p>

<object data="copy-c-b-a.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Repositioning the multiplexers from the <span class="math">A</span> lines to the <span class="math">B</span> lines reverses the roles of the second and third bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> C, A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> C, A, Q </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">A</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">B</span>. In both cases, <span class="math">A</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>Here is the schematic:</p>

<object data="copy-c-a-b-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Below is the Tetris version.</p>

<object data="copy-c-a-b.svg" type="image/svg+xml" class="diagram">Q = C ? B : A</object>

<p>Finally, flipping that circuit horizontally yields a variation that either copies the second byte to the first byte, or does nothing, per the value of the third byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">B</span> if <span class="math">C</span> is <span class="mono">1</span>; otherwise, <span class="math">Q</span> is <span class="math">A</span>. In both cases, <span class="math">B</span> and <span class="math">C</span> pass through, unchanged.</p>

<p>The flipped circuit follows.</p>

<object data="copy-b-a-c-schematic.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<p>Here is the Tetris realization:</p>

<object data="copy-b-a-c.svg" type="image/svg+xml" class="diagram">Q = C ? A : B</object>

<h2 id="decrement">Decrement</h2>

<p>The decrement function subtracts one from its argument:</p>

<p><span class="math">f(x) = x &minus; </span><span class="serif">1</span></p>

<p>Its circuit consists of chain of <a href="https://en.wikipedia.org/wiki/Subtractor#Half_subtractor" target="_blank">half subtractors</a>, devices capable of single-digit subtraction. Each half subtractor accepts a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">minuend</a>, <span class="math">X</span>, and a <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Subtraction#Notation_and_terminology" target="_blank">subtrahend</a>, <span class="math">Y</span>, and it returns their signed difference, a <span class="nowrap">2-bit</span> value composed of the sign bit, <span class="math">B</span>, and the ones bit, <span class="math">D</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">B</th><th class="math">D</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &minus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &minus; 1 = &minus;1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &minus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &minus; 1 = 0</span></td></tr>
</table>

<p>The table reveals <span class="math">B</span> and <span class="math">D</span> are:</p>

<p><span class="math">B = <span class="overline">X</span>Y</span></p>

<p><span class="math">D = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = B + X<span class="overline">Y</span></span></p>

<p>From <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a>:</p>

<p><span class="math"><span class="overline">X</span>Y = <span class="overline">X</span>X + <span class="overline">X</span>Y = <span class="overline">X</span>(X + Y) = <span class="high-overline">X + <span class="overline">X + Y</span></span> = <span class="overline">X + T</span>, T = <span class="overline">X + Y</span></span></p>

<p><span class="math">X<span class="overline">Y</span> = X<span class="overline">Y</span> + Y<span class="overline">Y</span> = <span class="overline">Y</span>(X + Y) = <span class="high-overline">Y + <span class="overline">X + Y</span></span> = <span class="overline">Y + T</span>, T = <span class="overline">X + Y</span></span></p>

<p>Cleaning up:</p>

<p><span class="math">T = <span class="overline">X + Y</span></span></p>

<p><span class="math">B = <span class="overline">X + T</span></span></p>

<p><span class="math">D = B + <span class="overline">Y + T</span></span></p>

<p>That implies the following circuit.</p>

<object data="half-subtractor-schematic.svg" type="image/svg+xml" class="diagram">Half Subtractor Schematic</object>

<p>In the code below, which is based on that schematic, a horizontal I-Tetrimino functions as the upper OR.</p>

<pre class="code">
<span class="filename">halfSubtractor.t</span>
<span class="line"><span class="normal">ih </span><span class="number">0</span></span>
<span class="line"><span class="normal">ih </span><span class="number">4</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-1</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-2</span></span>
<span class="line"><span class="normal">lr </span><span class="number">3</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">nor nor1 </span><span class="number">1 1</span></span>
<span class="line"><span class="normal">nor nor2 </span><span class="number">-1 6</span></span>
<span class="line"><span class="normal">nor nor3 </span><span class="number">3 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-3</span></span>
<span class="line"><span class="normal">ih </span><span class="number">1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-1</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-4</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-2..1 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">2..5 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">b </span><span class="number">-5 14</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">d </span><span class="number">-2 14</span></span>
</pre>

<p>Here is its response to all input combinations:</p>

<object data="half-subtractor.svg" type="image/svg+xml" class="diagram">Half Subtractor</object>

<p>In the full circuit, half subtractors are chained in the following configuration, where each <span class="math">I<span class="sub">i</span></span> is an input digits, and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object data="decrementer-schematic.svg" type="image/svg+xml" class="diagram">Decrementer Schematic</object>

<p>The circuit is a binary odometer that counts down. When a digit rolls back&mdash;when it transitions from <span class="mono">0</span> to <span class="mono">1</span>&mdash;the digit to its left is decremented. The signal to decrement a digit is referred to as the <span class="term">borrow</span>. The initial <span class="term nowrap">borrow-in</span> is <span class="mono">1</span> (far right). Its effect ripples right-to-left. For each half subtractor, if the input digit is <span class="mono">0</span> and the <span class="nowrap">borrow-in</span> is <span class="mono">1</span>, then both the output digit and the <span class="term nowrap">borrow-out</span> are <span class="mono">1</span>. Otherwise, the <span class="nowrap">borrow-out</span> is <span class="mono">0</span> and all digits to its left remain the same.</p>

<p>The image below depicts a Tetris realization of an <span class="nowrap">8-bit</span> decrement function that calculated <span class="nowrap serif">42 &minus; 1</span>. The sequence in which components were built determined the evaluation order. It started with a <span class="nowrap">1-bit</span> constant function in the bottom-right, which supplied the initial <span class="nowrap">borrow-in</span>. From there, digits were evaluated right-to-left and bottom-up. The final <span class="nowrap">borrow-out</span> was discarded.</p>

<object data="decrementer-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Decrementer</object>

<p>The following image shows a Tetris realization of a <span class="nowrap">16-bit</span> decrement function that calculated <span class="nowrap serif">0 &minus; 1</span>. It rolled back to all ones, the <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two's complement</a> representation of &minus;1 or the maximum unsigned integer value.</p>

<object data="decrementer-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Decrementer</object>

<h2 id="increment">Increment</h2>

<p>The increment function adds one to its argument:</p>

<p><span class="math">f(x) = x + </span><span class="serif">1</span></p>

<p>Its circuit consists of chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder" target="_blank">half adders</a>, devices capable of single-digit addition. Each half adder accepts two <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span> and <span class="math">Y</span>, and it outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 = 2</span></td></tr>
</table>

<p>The table reveals <span class="math">C</span> and <span class="math">S</span> are:</p>

<p><span class="math">C = XY = <span class="high-overline"><span class="overline">X</span> + <span class="overline">Y</span></span></span></p>

<p><span class="math">S = X &oplus; Y = (X &ne; Y) = <span class="overline">X</span>Y + X<span class="overline">Y</span> = <span class="overline">X</span>X + <span class="overline">X</span>Y + X<span class="overline">Y</span> + Y<span class="overline">Y</span> = (<span class="overline">X</span> + <span class="overline">Y</span>)(X + Y) = <span class="overline">C</span>(X + Y) = <span class="high-overline">C + <span class="overline">X + Y</span></span></span></p>

<p>That implies the following circuit.</p>

<object data="half-adder-schematic.svg" type="image/svg+xml" class="diagram">Half Adder Schematic</object>

<p>In the code below, which is based on that schematic, the <span class="mono">swap</span> (line 14) enables the output of the bottom NOR (line 13) to hop over the input of the <span class="math">Y</span> inverter (line 17). The <span class="math">X</span> inverter (line 16) feeds into the middle NOR (line 18), which, in turn, feeds into the top NOR (line 25).</p>

<pre class="code">
<span class="filename">halfAdder.t</span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-6</span></span>
<span class="line"><span class="normal">jl </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-7</span></span>
<span class="line"><span class="normal">jl </span><span class="number">2</span></span>
<span class="line"><span class="normal">jr </span><span class="number">2</span></span>
<span class="line"><span class="normal">nor </span><span class="number">0 1</span></span>
<span class="line"><span class="normal">swap </span><span class="number">2 6</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-2</span></span>
<span class="line"><span class="normal">notRight </span><span class="number">-7 28</span></span>
<span class="line"><span class="normal">notLeft </span><span class="number">-3 28</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-5 33</span></span>
<span class="line"><span class="normal">lr </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">iv </span><span class="number">4</span></span>
<span class="line"><span class="normal">sh </span><span class="number">3</span></span>
<span class="line"><span class="normal">sh </span><span class="number">1</span></span>
<span class="line"><span class="normal">sh </span><span class="number">-1</span></span>
<span class="line"><span class="normal">nor </span><span class="number">-3 38</span></span>
<span class="line"><span class="normal">ju </span><span class="number">-7</span></span>
<span class="line"><span class="normal">iv </span><span class="number">-8</span></span>
<span class="line"><span class="normal">ih </span><span class="number">-1</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">in </span><span class="normal">x </span><span class="number">-3..0 0</span></span>
<span class="line"><span class="keyword">in </span><span class="normal">y </span><span class="number">1..2 0</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">c </span><span class="number">-8 44</span></span>
<span class="line"><span class="keyword">out </span><span class="normal">s </span><span class="number">-3..0 44</span></span>
</pre>

<p>As revealed in the following image, which shows the responses to all input combinations, the Tetris realization of a half adder is significantly larger than a half subtractor due to the swap circuit.</p>

<object data="half-adder.svg" type="image/svg+xml" class="diagram">Half Adder</object>

<p>In the full circuit, half adders are chained in the configuration below, where each <span class="math">I<span class="sub">i</span></span> is an input digits, and each <span class="math">Q<span class="sub">i</span></span> is an output digit.</p>

<object data="incrementor-schematic.svg" type="image/svg+xml" class="diagram">Incrementor Schematic</object>

<p>The circuit is a binary odometer that counts up. When a digit rolls over&mdash;when it transitions from <span class="mono">1</span> to <span class="mono">0</span>&mdash;the digit to its left is incremented. The signal to increment a digit is referred to as the <span class="term">carry</span>. The initial <span class="term"><span class="nowrap">carry-in</span></span> is <span class="mono">0</span> (far right). Its effect ripples right-to-left. For each half adder, if both the input digit and the <span class="nowrap">carry-in</span> is <span class="mono">1</span>, then the output digit is <span class="mono">0</span> and the <span class="term nowrap">carry-out</span> is <span class="mono">1</span>. Otherwise, the <span class="nowrap">carry-out</span> is <span class="mono">0</span> and all digits to its left remain the same.</p>

<p>The image below depicts a Tetris realization of an <span class="nowrap">8-bit</span> increment function that calculated <span class="nowrap serif">42 + 1</span>. A <span class="nowrap">1-bit</span> constant function at the bottom-right supplied the initial <span class="nowrap">carry-in</span>. The final <span class="nowrap">carry-out</span> was discarded.</p>

<object data="incrementor-8.svg" type="image/svg+xml" class="diagram"><span class="nowrap">8-bit</span> Incrementor</object>

<p>The following image shows a Tetris realization of a <span class="nowrap">16-bit</span> increment function. The input is all ones, the two's complement representation of &minus;1 or the maximum unsigned integer value. The function rolled over to all zeros, in agreement with <span class="nowrap serif">&minus;1 + 1.</span></p>

<object data="incrementor-16.svg" type="image/svg+xml" class="diagram"><span class="nowrap">16-bit</span> Incrementor</object>

<h2 id="conditional-increment">Conditional Increment</h2>

<p>The conditional increment function operates on a 2-element array, <span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span>, where <span class="math">W</span> is a signed or unsigned <span class="nowrap">16-bit</span> integer, and <span class="math">C</span> is a Boolean, a byte restricted to <span class="mono">0</span> and <span class="mono">1</span>:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> W, C </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, C </span><span class="math">]</span>, where <span class="math">C </span><span class="serif">&isin; { </span><span class="mono">0</span><span class="math">, </span><span class="mono">1</span><span class="serif"> }</span></p>

<p><span class="math">Q</span> is <span class="math">W </span><span class="serif">+ 1</span> if <span class="math">C</span> is <span class="serif">1</span>; otherwise, <span class="math">Q</span> is <span class="math">W</span>. Either way, <span class="math">C</span> passes through, unchanged.</p>

<p>As shown below, its circuit consists of a <span class="nowrap">16-bit</span> incrementer, where the <span class="nowrap">carry-in</span> is <span class="math">C<span class="sub">0</span></span> and the <span class="nowrap">carry-out</span> is discarded.</p>

<object data="conditional-increment-schematic.svg" type="image/svg+xml" class="diagram">Conditional Increment Schematic</object>

<p>Here is the Tetris version:</p>

<object data="conditional-increment.svg" type="image/svg+xml" class="diagram">Conditional Increment</object>

<h2 id="add">Add</h2>

<p>The add function operates on a 2-byte array. It sets the first byte to the sum of both bytes:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></p>

<p><span class="math">Q = A + B</span>, where the plus sign denotes arithmetic add.</p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>Its circuit consists of a chain of <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder" target="_blank">full adders</a>, devices capable of single-digit addition. Each full adder accepts three <span class="nowrap">1-bit</span> <a href="https://en.wikipedia.org/wiki/Addition#Notation_and_terminology" target="_blank">addends</a>, <span class="math">X</span>, <span class="math">Y</span>, and <span class="math">Z</span>, and it outputs their sum, a <span class="nowrap">2-bit</span> value composed of the twos bit, <span class="math">C</span>, and the ones bit, <span class="math">S</span>. The table below shows the outputs for all possible inputs.</p>

<table class="borderless">
<tr><th class="math">X</th><th class="math">Y</th><th class="math">Z</th><th class="border-left math">C</th><th class="math">S</th><th class="border-left borderless">Meaning</th></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 0 = 0</span></td></tr>
<tr><td class="mono">0</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 0 &plus; 1 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">0</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">0 &plus; 1 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">0</td><td class="border-left mono">0</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 0 = 1</span></td></tr>
<tr><td class="mono">1</td><td class="mono">0</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 0 &plus; 1 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">0</td><td class="border-left mono">1</td><td class="mono">0</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 0 = 2</span></td></tr>
<tr><td class="mono">1</td><td class="mono">1</td><td class="mono">1</td><td class="border-left mono">1</td><td class="mono">1</td><td class="border-left borderless"><span class="serif">1 &plus; 1 &plus; 1 = 3</span></td></tr>
</table>

<p>Per the table rows where <span class="math">S</span> is <span class="mono">1</span>:</p>

<p><span class="math">S = <span class="overline">X</span> <span class="overline">Y</span> Z + <span class="overline">X</span> Y <span class="overline">Z</span> + X <span class="overline">Y</span> <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math">= <span class="overline">X</span> (<span class="overline">Y</span> Z + Y <span class="overline">Z</span>) + X (<span class="overline">Y</span> <span class="overline">Z</span> + Y Z)</span></p>

<p><span class="math">= <span class="overline">X</span> (Y &oplus; Z) + X <span class="overline">(Y &oplus; Z)</span></span></p>

<p><span class="math">= X &oplus; Y &oplus; Z</span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math"> &oplus; Z</span></span></p>

<p><span class="math">= </span><span class="overline2"><span class="math">(X &oplus; Y &oplus; </span><span class="serif">1</span><span class="math">) &oplus; Z</span></span></p>

<p><span class="math">= <span class="high-overline"><span class="overline">(X &oplus; Y)</span> &oplus; Z</span></span></p>

<p>Per the table rows where <span class="math">C</span> is <span class="mono">1</span>:</p>

<p><span class="math">C = <span class="overline">X</span> Y Z + X <span class="overline">Y</span> Z + X Y <span class="overline">Z</span> + X Y Z</span></p>

<p><span class="math"> = Z (<span class="overline">X</span> Y + X <span class="overline">Y</span>) + X Y (<span class="overline">Z</span> + Z)</span></p>

<p><span class="math"> = Z (X <span class="overline">X</span> + <span class="overline">X</span> Y + X <span class="overline">Y</span> + Y <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) (<span class="overline">X</span> + <span class="overline">Y</span>) + X Y</span></p>

<p><span class="math"> = Z (X + Y) <span class="overline">(X Y)</span> + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X Y) + (X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y) + (Y X Y)</span></p>

<p><span class="math"> = Z (X + Y) + (X X Y + X <span class="overline">X</span> <span class="overline">Y</span>) + (Y X Y + Y <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X (X Y + <span class="overline">X</span> <span class="overline">Y</span>) + Y (X Y + <span class="overline">X</span> <span class="overline">Y</span>)</span></p>

<p><span class="math"> = Z (X + Y) + X <span class="overline">(X &oplus; Y)</span> + Y <span class="overline">(X &oplus; Y)</span></span></p>

<p><span class="math"> = Z (X + Y) + <span class="overline">(X &oplus; Y)</span> (X + Y)</span></p>

<p><span class="math"> = (X + Y) (Z + <span class="overline">X &oplus; Y</span>)</span></p>

<p>The expressions for <span class="math">S</span> and <span class="math">C</span> are combined:</p>

<p><span class="math">T = <span class="overline">X &oplus; Y</span></span></p>

<p><span class="math">S = <span class="overline">T &oplus; Z</span></span></p>

<p><span class="math">C = (X + Y) (Z + T) = <span class="high-overline"><span class="overline">X + Y</span> + <span class="overline">Z + T</span></span></span></p>

<p>The resultant expressions suggest the following circuit, where the XNORs (the gray rectangles) are composed from four NORs.</p>

<object data="full-adder-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic</object>

<p>The Tetris realization is based on a slight modification that forwards input <span class="math">X</span> through and out between <span class="math">C</span> and <span class="math">S</span>. It consists of nine NORs and three crosses, as shown below.</p>

<object data="full-adder-x-schematic.svg" type="image/svg+xml" class="diagram">Full Adder Schematic, Outputs X</object>

<p>Here are the results for <span class="math">X = </span><span class="mono">0</span> and all possible values of <span class="math">Y</span> and <span class="math">Z</span>:</p>

<object data="full-adder-x-0.svg" type="image/svg+xml" class="diagram">Full Adder, X = 0</object>

<p>Here are the results for <span class="math">X = </span><span class="mono">1</span> and all possible values of <span class="math">Y</span> and <span class="math">Z</span>:</p>

<object data="full-adder-x-1.svg" type="image/svg+xml" class="diagram">Full Adder, X = 1</object>

<p>The complete circuit consists of full adders chained in the arrangement below. Each full adder accepts a pair of addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, and it outputs their sum digit, <span class="math">Q<span class="sub">i</span></span>, along with one of the input digits, <span class="math">B<span class="sub">i</span></span>, unmodified.</p>

<object data="adder-schematic.svg" type="image/svg+xml" class="diagram">4-bit Adder Schematic</object>

<p>The circuit evaluates right-to-left. For each full adder, if the sum of the <span class="nowrap">carry-in</span>, <span class="math">Z</span>, and the addend digits, <span class="math">A<span class="sub">i</span></span> and <span class="math">B<span class="sub">i</span></span>, is not a single-digit number, then the high digit, <span class="math">C</span>, is carried out to the full adder on its left. The initial <span class="nowrap">carry-in</span> is <span class="mono">0</span> (far right) and the final <span class="nowrap">carry-out</span> is lost.</p>

<p>Crisscrossing wires are required to interlace the inputs and to disentangle the outputs:</p>

<object data="add-schematic.svg" type="image/svg+xml" class="diagram">8-bit Adder Schematic</object>

<p>The Tetris realization retains the triangular patterns from all the cross overs:</p>

<object data="add.svg" type="image/svg+xml" class="diagram">8-bit Adder</object>

<p>The full adders are stacked diagonally to enable the carries to ripple in the expected order.</p>

<h2 id="subtract">Subtract</h2>

<p>The subtract function operates on a 2-byte array. It sets the first byte to the difference of the first byte and the second byte:</p>

<p><span class="math">f( </span><span class="serif">[</span><span class="math"> A, B </span><span class="serif">]</span><span class="math"> ) = </span><span class="serif">[</span><span class="math"> Q, B </span><span class="serif">]</span>, where <span class="math">A,B,Q </span><span class="serif">&isin;</span> <span class="math">&#8484;</span></p>

<p><span class="math">Q = A &minus; B</span></p>

<p><span class="math">B</span> passes through, unchanged.</p>

<p>Since <span class="math">A</span>, <span class="math">B</span>, and <span class="math">Q</span> are two’s complement numbers, the subtraction can be transformed into a sum:</p>

<p><span class="math">A &minus; B = A + -B = A + </span><span class="serif">~</span><span class="math">B + </span><span class="serif">1</span>, where <span class="serif">~</span> means <a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT" target="_blank">bitwise inversion</a>.</p>

<p>Its circuit is a modification of the add circuit:</p>

<object data="subtract-schematic.svg" type="image/svg+xml" class="diagram">8-bit Subtractor Schematic</object>

<p>The initial <span class="nowrap">carry-in</span> (far right) serves as the <span class="serif">+ 1</span> term of the sum.</p>  

<p><span class="math">B</span> is inverted twice to output it unchanged.</p> 

<p>The Tetris realization follows.</p>

<object data="subtract.svg" type="image/svg+xml" class="diagram">8-bit Subtractor</object>

<h2 id="uniform-height">Uniform Height</h2>

<p>Subtract is the tallest function, at least as the functions have been portrayed thus far. In reality, functions are padded with buffers that extends them to a common height. As such, every functions fits in a rectangle with a base that covers either 8, 16, or 24 bits, and a height that matches the subtract function. With only those three possible dimensions, functions fit together like interchangeable, building blocks that process information.</p>

<h2 id="function-catalog">Function Catalog</h2>

<p>The table below provides the names and definitions of the functions created for the machine that runs Tetris. The missing byte match functions are covered separately.</p>

<p>Parameters <span class="mono">A</span> and <span class="mono">B</span> are bytes, <span class="mono">W</span> is a <span class="nowrap">16-bit</span> word, and <span class="mono">C</span>, <span class="mono">D</span>, and <span class="mono">E</span> are Booleans (bytes restricted to <span class="mono">0</span> and <span class="mono">1</span>).</p>

<table class="borderless">
  <tr><th class="borderless">Function</th><th class="borderless">Definition</th></tr>
  <tr><td class="pseudocode">CLEAR</td><td class="pseudocode">A<span class="serif"> &#8614; </span>0</td></tr>
  <tr><td class="pseudocode">DEC</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A - 1</td></tr>
  <tr><td class="pseudocode">DEC_16</td><td class="pseudocode">W<span class="serif"> &#8614; </span>W - 1</td></tr>
  <tr><td class="pseudocode">IDENTITY</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A</td></tr>
  <tr><td class="pseudocode">INC</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A + 1</td></tr>
  <tr><td class="pseudocode">INC_16</td><td class="pseudocode">W<span class="serif"> &#8614; </span>W + 1</td></tr>
  <tr><td class="pseudocode">LS2</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 2</td></tr>
  <tr><td class="pseudocode">LS3</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 3</td></tr>
  <tr><td class="pseudocode">LS4</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A << 4</td></tr>
  <tr><td class="pseudocode">RS1</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A >>> 1</td></tr>
  <tr><td class="pseudocode">RS5</td><td class="pseudocode">A<span class="serif"> &#8614; </span>A >>> 5</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td></tr>
  
  <tr><td class="pseudocode">ADD_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A + B, B ]</td></tr>
  <tr><td class="pseudocode">AND_AB_AF</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A, A & B ]</td></tr>
  <tr><td class="pseudocode">AND_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A & B, B ]</td></tr>
  <tr><td class="pseudocode">AND_NOT_AB_FB</td><td class="pseudocode">[ D, E ]<span class="serif"> &#8614; </span>[ D, D && !E ]</td></tr>
  <tr><td class="pseudocode">COPY_A_B</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A, A ]</td></tr>
  <tr><td class="pseudocode">COPY_B_A</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ B, B ]</td></tr>
  <tr><td class="pseudocode">INC_16_C</td><td class="pseudocode">[ W, C ]<span class="serif"> &#8614; </span>[ C ? W + 1 : W, C ]</td></tr>
  <tr><td class="pseudocode">OR_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A | B, B ]</td></tr>
  <tr><td class="pseudocode">SUB_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A - B, B ]</td></tr>
  <tr><td class="pseudocode">SWAP</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ B, A ]</td></tr>
  <tr><td class="pseudocode">XOR_AB_FB</td><td class="pseudocode">[ A, B ]<span class="serif"> &#8614; </span>[ A ^ B, B ]</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td></tr>
  
  <tr><td class="pseudocode">AND_A_B_C</td><td class="pseudocode">[ D, E, C ]<span class="serif"> &#8614; </span>[ D, E, D && E ]</td></tr>
  <tr><td class="pseudocode">C_AND_A_NOT_B</td><td class="pseudocode">[ C, D, E ]<span class="serif"> &#8614; </span>[ D && !E, D, E ]</td></tr>
  <tr><td class="pseudocode">CMP_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, B, A == B ]</td></tr>  
  <tr><td class="pseudocode">CMP_AND_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, B, (A == B) && C ]</td></tr>
  <tr><td class="pseudocode">C_CMP</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ A == B, A, B ]</td></tr>
  <tr><td class="pseudocode">COPY_A_B_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ A, C ? A : B, C ]</td></tr>
  <tr><td class="pseudocode">COPY_B_A_C</td><td class="pseudocode">[ A, B, C ]<span class="serif"> &#8614; </span>[ C ? B : A, B, C ]</td></tr>  
  <tr><td class="pseudocode">C_COPY_B_A</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ C, C ? B : A, B ]</td></tr>
  <tr><td class="pseudocode">C_COPY_A_B</td><td class="pseudocode">[ C, A, B ]<span class="serif"> &#8614; </span>[ C, A, C ? A : B ]</td></tr>
</table>

<p>A byte match functions accept a byte, <span class="mono">A</span>, and a Boolean, <span class="mono">C</span>. It returns <span class="mono">A</span>, unchanged, along with a Boolean indicating if <span class="mono">A</span> matches a specific bit pattern. The order of the parameters is declared in the function name:</p>

<table class="matchers">
  <tr><td style="text-align: right; padding-right: 15px;">Ends with <span class="mono">_C</span>:</td><td><span class="nowrap"><span class="mono">[ A, C ]<span class="serif"> &#8614; </span>[ A, isMatch(A) ]</span></span></td></tr>
  <tr><td style="text-align: left; padding-right: 15px;">Starts with <span class="mono">C_</span>:</td><td><span class="nowrap"><span class="mono">[ C, A ]<span class="serif"> &#8614; </span>[ isMatch(A), A ]</span></span></td></tr>
</table>

<p>The following table details the byte match functions. Those with bit patterns containing <a href="https://en.wikipedia.org/wiki/Don%27t-care_term" target="_blank">don’t-care</a> are capable of matching multiple values, as shown in the right column.</p>

<table class="borderless">
  <tr><th class="borderless">Function</th><th class="borderless">Pattern</th><th class="borderless">Values</th></tr>
  <tr><td class="pseudocode">ADD_C</td><td class="pseudocode">00010000</td><td class="pseudocode">10</td></tr> 
  <tr><td class="pseudocode">AND_C</td><td class="pseudocode">00010001</td><td class="pseudocode">11</td></tr>
  <tr><td class="pseudocode">BEQ_C</td><td class="pseudocode">00100011</td><td class="pseudocode">23</td></tr> 
  <tr><td class="pseudocode">BMI_C</td><td class="pseudocode">00100101</td><td class="pseudocode">25</td></tr> 
  <tr><td class="pseudocode">BNE_C</td><td class="pseudocode">00100010</td><td class="pseudocode">22</td></tr>
  <tr><td class="pseudocode">BPL_C</td><td class="pseudocode">00100100</td><td class="pseudocode">24</td></tr>   
  <tr><td class="pseudocode">DEC_C</td><td class="pseudocode">00010010</td><td class="pseudocode">12</td></tr> 
  <tr><td class="pseudocode">INC_C</td><td class="pseudocode">00010011</td><td class="pseudocode">13</td></tr> 
  <tr><td class="pseudocode">JMP_C</td><td class="pseudocode">00100000</td><td class="pseudocode">20</td></tr> 
  <tr><td class="pseudocode">JSR_C</td><td class="pseudocode">00101000</td><td class="pseudocode">28</td></tr> 
  <tr><td class="pseudocode">LDB_C</td><td class="pseudocode">01000001</td><td class="pseudocode">41</td></tr>  
  <tr><td class="pseudocode">LS2_C</td><td class="pseudocode">00010100</td><td class="pseudocode">14</td></tr> 
  <tr><td class="pseudocode">LS3_C</td><td class="pseudocode">00010101</td><td class="pseudocode">15</td></tr> 
  <tr><td class="pseudocode">LS4_C</td><td class="pseudocode">00010110</td><td class="pseudocode">16</td></tr> 
  <tr><td class="pseudocode">OR_C</td><td class="pseudocode">00010111</td><td class="pseudocode">17</td></tr>  
  <tr><td class="pseudocode">RS1_C</td><td class="pseudocode">00011000</td><td class="pseudocode">18</td></tr> 
  <tr><td class="pseudocode">RS5_C</td><td class="pseudocode">00011001</td><td class="pseudocode">19</td></tr> 
  <tr><td class="pseudocode">RTS_C</td><td class="pseudocode">01110000</td><td class="pseudocode">70</td></tr> 
  <tr><td class="pseudocode">SEA_C</td><td class="pseudocode">01010000</td><td class="pseudocode">50</td></tr> 
  <tr><td class="pseudocode">SEB_C</td><td class="pseudocode">01010001</td><td class="pseudocode">51</td></tr>
  <tr><td class="pseudocode">SMN_C</td><td class="pseudocode">00101111</td><td class="pseudocode">2F</td></tr>
  <tr><td class="pseudocode">STA_C</td><td class="pseudocode">00110000</td><td class="pseudocode">30</td></tr> 
  <tr><td class="pseudocode">STB_C</td><td class="pseudocode">00110001</td><td class="pseudocode">31</td></tr> 
  <tr><td class="pseudocode">SUB_C</td><td class="pseudocode">00011010</td><td class="pseudocode">1A</td></tr> 
  <tr><td class="pseudocode">XOR_C</td><td class="pseudocode">00011011</td><td class="pseudocode">1B</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  

  <tr><td class="pseudocode">TAX_C</td><td class="pseudocode">000000**</td><td class="pseudocode">00, 01, 02, 03</td></tr>   
  <tr><td class="pseudocode">TBX_C</td><td class="pseudocode">000001**</td><td class="pseudocode">04, 05, 06, 07</td></tr> 
  <tr><td class="pseudocode">TMX_C</td><td class="pseudocode">000010**</td><td class="pseudocode">08, 09, 0A, 0B</td></tr>
  <tr><td class="pseudocode">TNX_C</td><td class="pseudocode">000011**</td><td class="pseudocode">0C, 0D, 0E, 0F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  
  
  <tr><td class="pseudocode">TXA_C</td><td class="pseudocode">0000**00</td><td class="pseudocode">00, 04, 08, 0C</td></tr>   
  <tr><td class="pseudocode">TXB_C</td><td class="pseudocode">0000**01</td><td class="pseudocode">01, 05, 09, 0D</td></tr> 
  <tr><td class="pseudocode">TXM_C</td><td class="pseudocode">0000**10</td><td class="pseudocode">02, 06, 0A, 0E</td></tr>
  <tr><td class="pseudocode">TXN_C</td><td class="pseudocode">0000**11</td><td class="pseudocode">03, 07, 0B, 0F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">LDX_C</td><td class="pseudocode">0100000*</td><td class="pseudocode">40, 41</td></tr>  
  <tr><td class="pseudocode">STX_C</td><td class="pseudocode">0011000*</td><td class="pseudocode">30, 31</td></tr>   
  <tr><td class="pseudocode">SEX_C</td><td class="pseudocode">0101000*</td><td class="pseudocode">50, 51</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">THREE_C</td><td class="pseudocode">0010****</td><td class="pseudocode">20..2F</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>

  <tr><td class="pseudocode">MINUS_C</td><td class="pseudocode">1*******</td><td class="pseudocode">80..FF</td></tr>
  <tr><td class="pseudocode">C_MINUS</td><td class="pseudocode">1*******</td><td class="pseudocode">80..FF</td></tr>
  <tr><td class="separator"> </td><td class="separator"> </td><td class="separator"> </td></tr>  
  
  <tr><td class="pseudocode">ZERO_C</td><td class="pseudocode">00000000</td><td class="pseudocode">00</td></tr>
  <tr><td class="pseudocode">C_ZERO</td><td class="pseudocode">00000000</td><td class="pseudocode">00</td></tr>
</table>

<p>As their names suggest, the byte match functions primarily detect machine language <a href="https://en.wikipedia.org/wiki/Opcode" target="_blank">opcodes</a> or sets of opcodes. The most generic of them, <span class="mono">THREE_C</span>, matches the opcodes for all <span class="nowrap">3-byte</span> instructions.</p> 

<p><span class="mono">MINUS_C</span> and <span class="mono">C_MINUS</span> recognize negative numbers, those with <span class="nowrap">bit-7</span> set per <span class="nowrap">two’s complement</span>.</p>

<p><span class="mono">ZERO_C</span> and <span class="mono">C_ZERO</span> are <span class="nowrap">zero detectors</span>. </p>

<h1 id="memory">Memory</h1>

<p>This section begins by explaining how random-access memory is implemented in Tetris. Then it describes a language designed for manipulating the data contained within the implementation. Afterwards, it divulges how the implementation can store a limitless amount of information. That is followed by discussion on memory initialization. Finally, it presents an abstraction that reduces memory down to its essence.</p>

<h2 id="memory-implementation">Implementation</h2>

<p>The Tetris implementation of a computer’s <a href="https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage" target="_blank">main memory</a> consists of a rectangular pile with large, yet finite, dimensions. It stores an ordered list of bytes encoded as a sequence of nodes in its <span class="nowrap">top-two</span> rows. The nodes are evenly-spaced, ten columns apart, starting from <span class="nowrap">column 0</span>.</p>

<p>Since the blindfolded agent cannot see the playfield, it cannot read data from memory. But it can ask Tetris to perform to a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write" target="_blank">read-modify-write</a> operation on its behalf. To do so, the agent builds a function on top of the bytes to be changed. The function’s output&mdash;a row of 8, 16, or 24 evenly-spaced nodes&mdash;is the initial segment of a new surface of a taller pile. The agent raises the remaining surface flush with the function’s output by constructing identity functions over all the remaining bytes. The new surface contains the same data as the original surface, except for the bytes the agent indirectly modified.</p> 

<p>To make this clear, the following visualization depicts the layers of a rectangular pile resulting from a read-modify-write operation. The bottom layer shows the initial memory state: five bytes, all zeros. The agent built an <span class="nowrap">8-bit</span> increment function, <span class="mono">INC</span>, above <span class="nowrap">byte <span class="mono">2</span></span>. <span class="mono">INC</span>'s output created the first segment of the top layer (the yellow cell). Then the agent built identify functions over the remaining bytes (the <span class="nowrap">up-arrows</span>). The outputs of those functions formed the rest of top layer. The final memory state consists of five bytes, all zeros, except for <span class="nowrap">byte <span class="mono">2</span></span>.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">1</td><td class="top mono bottom green">00</td><td class="top left bottom mono green">00</td><td class="top left bottom mono yellow">01</td><td class="top left bottom mono green">00</td><td class="top left right bottom mono green">00</td></tr>
<tr><td class="row-number"></td><td class="bottom blue">&#129093;</td><td class="left bottom blue">&#129093;</td><td class="left bottom mono blue">INC</td><td class="left bottom blue">&#129093;</td><td class="left right bottom blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono bottom green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left bottom mono green">00</td><td class="left right bottom mono green">00</td></tr>

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table> 

<p>In the more elaborate example below, the agent delegated a sequence of read-modify-write operations to Tetris that set <span class="nowap">byte <span class="mono">0</span></span> to the sum of bytes <span class="mono">1</span>, <span class="mono">2</span>, <span class="mono">3</span>, and <span class="mono">4</span>.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top yellow">0A</td><td class="left bottom top mono yellow">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left right bottom top mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">0A</td><td class="left bottom mono yellow">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono yellow">0A</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono yellow">06</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono yellow">06</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">02</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono yellow">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom yellow">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left right bottom mono green">04</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td></tr>  
</table>

<p>Here is an explanation each operation:</p>

<ol>
  <li><span class="mono">COPY_B_A</span> copied byte <span class="mono">1</span> to byte <span class="mono">0</span>.</li>
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">1</span> and <span class="mono">2</span> into <span class="nowrap">byte <span class="mono">1</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">1</span> and <span class="mono">2</span>.</li> 
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">2</span> and <span class="mono">3</span> into <span class="nowrap">byte <span class="mono">2</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">2</span> and <span class="mono">3</span>.</li> 
  <li><span class="mono">ADD_AB_FB</span> put the sum of bytes <span class="mono">3</span> and <span class="mono">4</span> into <span class="nowrap">byte <span class="mono">3</span></span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">2</span> and <span class="mono">3</span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">1</span> and <span class="mono">2</span>.</li> 
  <li><span class="mono">SWAP</span> exchanged bytes <span class="mono">0</span> and <span class="mono">1</span>.</li> 
</ol>  

<p>The <span class="mono">SWAP</span> function provides a way to move values around in memory. Above, the agent used it bring values together for the add function. And it finished with three consecutive <span class="mono">SWAP</span>s to shuttle the computed sum from <span class="nowrap">byte <span class="mono">3</span></span> to <span class="nowrap">byte <span class="mono">0</span></span>.</p>

<h2 id="metatetrisscript">MetaTetrisScript</h2>

<p><span class="term">MetaTetrisScript</span> is a language for expressing read-modify-write operations. It has only two instruction types. The first consists of a function name and a memory address:</p>

<p class="definition">function address</p>

<p>It commands the agent to:</p>

<ol>
  <li>Execute the specified function's TetrisScript program on the surface of the pile at the specified address, covering either one, two, or three bytes of the surface per the function's byte width.</li> 
  <li>Execute <span class="mono">IDENTITY</span>'s TetrisScript program on the surface of the pile above all other bytes.</li>
</ol>

<p>The agent builds the specified function at column 80 &times; address since:</p>

<p>8 nodes/byte &times; 10 columns/node = 80 columns</p>

<p>For the specified function’s row index and the coordinates of the identity functions, the agent needs the pile's initial dimensions. The initial height provides the original surface row index. Every time the agent adds a layer to the pile, it increments that value by the uniform function height. The agent deduces the uniform function height along with the byte widths of all functions by building them ahead of time on a private playfield. It uses the specified function’s byte width along with the pile’s width to figure out how many identity functions to build and where to build them.</p>

<p>An example MetaTetrisScript follows. It formalizes the steps of the summation from the previous section.</p>

<pre class="code">
<span class="filename">sum.mt</span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">0</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">3</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">1</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">0</span></span>
</pre>

<p>The second instruction type executes a specified MetaTetrisScript program relative to a specified memory address. It consists of the program name and the address:</p>

<p class="definition">program address</p>

<p>It commands the agent to:</p>

<ol>
  <li>Replace the instruction with the program's instructions.</li>
  <li>Increment the address argument of each of the program's instructions by the specified address.</li>
  <li>Execute the modified instructions.</li>
</ol>

<p>The code below demonstrates this instruction type. It references the summation example.</p>

<pre class="code">
<span class="filename">sum5.mt</span>
<span class="line"><span class="normal">sum </span><span class="number">5</span></span>
</pre>

<p>The agent expands the instruction, offsetting the memory locations per the provided address:</p>

<pre class="code">
<span class="filename">sum5Expanded.mt</span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">5</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">6</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">7</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">8</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5</span></span>
</pre>

<p>The expanded version reveals that <span class="mono">sum5</span> totals bytes <span class="mono">6</span>, <span class="mono">7</span>, <span class="mono">8</span>, and <span class="mono">9</span>, and it puts the result into <span class="nowrap">byte <span class="mono">5</span></span>. In other words, it executes <span class="mono">sum</span> relative to <span class="nowrap">byte <span class="mono">5</span></span>.</p>

<p>The agent recursively expands instructions of the second type until all what remains are instructions of the first type. This means, circular dependencies are not allowed.</p>

<h2 id="expansion">Expansion</h2>

<p>The memory capacity is always finite, but it can be expanded indefinitely. To allocate a byte, the agent drops eight horizontal <span class="nowrap">I-Tetriminos</span> onto the playfield floor, evenly-spaced, ten columns apart, immediately to the right of the pile. That introduces eight new <span class="nowrap"><span class="mono">0</span>-nodes</span>:</p>

<object data="zeros.svg" type="image/svg+xml" class="diagram">Zeros</object>

<p>Then the agent repeatedly builds identity functions above the new nodes until the output of one of the identity functions reaches the height of the rest of the pile.</p>

<p>The process is portrayed in the following example. It shows a newly allocated byte appended to the summation pile.</p>

<table class="bits" style="width: 635.7px">
<tr><td class="row-number">9</td><td class="mono bottom top green">0A</td><td class="left bottom top mono green">01</td><td class="left bottom top mono green">02</td><td class="left bottom top mono green">03</td><td class="left bottom top mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr> 
  
<tr><td class="row-number">8</td><td class="mono bottom green">01</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>
  
<tr><td class="row-number">7</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">6</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">0A</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom right mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">5</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">06</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">4</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">06</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">3</td><td class="mono bottom green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">SWAP</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">2</td><td class="mono bottom green">01</td><td class="left bottom mono green">03</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td class="bottom left blue">&#129093;</td><td colspan="2" class="bottom mono blue">ADD_AB_FB</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">1</td><td class="mono bottom green">01</td><td class="left bottom mono green">01</td><td class="left bottom mono green">02</td><td class="left bottom mono green">03</td><td class="left bottom mono green">04</td><td class="left right bottom top mono yellow">00</td></tr>
<tr><td class="row-number"></td><td colspan="2" class="bottom mono blue">COPY_B_A</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left blue">&#129093;</td><td class="bottom left right blue">&#129093;</td></tr>

<tr><td class="row-number">0</td><td class="mono green">00</td><td class="left mono green">01</td><td class="left mono green">02</td><td class="left mono green">03</td><td class="left right mono green">04</td><td class="left right mono yellow">00</td></tr>  

<tr><td class="row-number"></td><td class="column-number">0</td><td class="column-number">1</td><td class="column-number">2</td><td class="column-number">3</td><td class="column-number">4</td><td class="column-number">5</td></tr>  
</table>

<p>The agent automatically allocates memory when a MetaTetrisScript instruction directs it to construct a function outside the pile’s bounds.</p>

<p>The agent never deallocates memory. The pile's width either remains constant or it increases.</p>

<h2 id="memory-initialization">Initialization</h2>

<p>Before the agent executes a MetaTetrisScript program, an independent process loads the initial memory state by dropping a sequence of horizontal <span class="nowrap">I-Tetriminos</span> (<span class="nowrap"><span class="mono">0</span>-nodes</span>) and <span class="nowrap">O-Tetriminos</span> (<span class="nowrap"><span class="mono">1</span>-nodes</span>) onto the playfield floor, evenly-spaced, ten columns apart, starting from <span class="nowrap">column 0</span>. For instance, here is a single byte, the value 42:</p>

<object data="forty-two.svg" type="image/svg+xml" class="diagram">42</object>

<p>All memory locations after the final byte of the initial state contain zero because, upon access, the agent automatically allocates and clears those bytes.</p>

<p>The agent is not privy to the initial memory content. But, as mentioned, it knows the initial memory size.</p>

<h2 id="infinite-array-abstraction">Infinite Array Abstraction</h2>

<p>Memory works like an infinitely long, one-dimensional, byte array, <span class="mono">a</span>, initialized as:</p>
  
<p><span class="nowrap"><span class="mono">a<span class="sub2">i&isin;[0,L-1]</span> &larr; </span><span class="mono">i<span class="sup2">th</span></span> byte of an <span class="nowrap"><span class="mono">L</span>-byte</span> initial memory state</p>

<p><span class="nowrap"><span class="mono">a<span class="sub2">i&isin;[L,&infin;)</span> &larr; 0</span></span></p>

<p>Each MetaTetrisScript instruction, <span class="mono nowrap">f x</span>, where <span class="mono">f</span> is an <span class="nowrap"><span class="mono">n</span>-byte</span> function, modifies <span class="mono">n</span> consecutive bytes, starting at <span class="nowrap">index <span class="mono">x</span></span>:</p>

<p><span class="nowrap"><span class="mono">a<span class="sub2">x</span>&nldr;a<span class="sub2">x+n&minus;1</span> &larr; f(a<span class="sub2">x</span>&nldr;a<span class="sub2">x+n&minus;1</span>)</span></span></p>

<p>This abstraction is used in the next section to construct computing machines.</p>

<h1 id="computing-machines">Computing Machines</h1>

<p>This section explores several models of computation, with a particular focus on a machine that runs Tetris.</p>

<h2 id="function-emulation">Function Emulation</h2>

<p>For all <span class="nowrap"><span class="mono">n</span>-byte</span> functions <span class="mono">F</span>, there exists a MetaTetrisScript program, <span class="mono">G</span>, that emulates <span class="mono">F</span>. This is because, regardless of how <span class="mono">F</span> is mathematically defined, it can be replaced with a lookup table, a finite&mdash;though potentially large&mdash;map from <span class="nowrap"><span class="mono">n</span>-byte</span> keys to <span class="nowrap"><span class="mono">n</span>-byte</span> values. As such, <span class="mono">G</span> simply needs to mimic the following pseudocode, when executed at index <span class="mono">x</span>.</p>

<pre class="pseudocode2">
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  <span class="keyword2">if</span> a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span></span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span></span>
<span class="line">    <span class="keyword2">break</span></span>
</pre>

<p>The code iterates over the <span class="nowrap">key-value</span> pairs of the map. For each pair, if the array segment equal the key, then it overwrites the segment with the value, and it breaks out of the loop to prevent the assigned value from matching the key of a successive entry. If it reaches the end of the loop without finding a match, it leaves the array unchanged.</p> 

<p>Unfortunately, MetaTetrisScript does not support loops, nor conditional branches (<span class="mono">if</span> statements), nor unconditional branches (such as the <span class="mono">break</span> statement). After all, it is nothing more than a shorthand for expressing an uninterrupted sequence of Tetrimino placements. But loops can be <a href="https://en.wikipedia.org/wiki/Loop_unrolling" target="_blank">unrolled</a> (at the expense of lengthy code) and the branches can be simulated with the assistance of temporary variables appended to the end of the array segment:</p>  

<p><span class="nowrap mono">p &equiv; a<span class="sub3">x+n</span></span></p>

<p><span class="nowrap mono">q &equiv; a<span class="sub3">x+n+1</span></span></p>

<p><span class="nowrap mono">r &equiv; a<span class="sub3">x+n+2</span></span></p>

<p>When a program invokes <span class="mono">G</span>, which is now an emulation of an <span class="nowrap"><span class="mono">(n+3)</span>-byte</span> function, it passes arbitrary values into the temporary variables, and it ignores their output values.</p>

<p>The code is transformed through the following steps. First, the <span class="mono">break</span> statement is replaced with <span class="mono">r</span> acting as a flag:</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  <span class="keyword2">if</span> (a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span>) <span class="keyword2">and not</span> r</span>
<span class="line">    a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span></span>
<span class="line">    r &larr; 1</span>
</pre>

<p>The loop no longer exits early, but <span class="mono">r</span> ensures the assignment happens at most once.</p>

<p>Next, the <span class="mono">if</span> statement is converted to a <a href="https://en.wikipedia.org/wiki/Ternary_operation" target="_blank">ternary operation</a>, where the condition is stored in <span class="mono">q</span>:</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; (a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">0</span>&nldr;k<span class="sub3">n&minus;1</span>) <span class="keyword2">and not</span> r</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>Each iteration overwrites the array segment with itself, except when a key matches for the first time.</p>

<p><span class="nowrap">Line 3</span> is expanded into <span class="nowrap">lines 3&ndash;6</span> below.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; a<span class="sub3">x+i</span> = k<span class="sub3">i</span></span>
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>When the inner loop is unrolled, every compare-with-constant, <span class="mono">p &larr; a<span class="sub3">x+i</span> = k<span class="sub3">i</span></span>, is replaced with a byte matcher:</p>

<p><span class="mono">MATCH_k<span class="sub3">i</span>_C &equiv; [ A, C ] &#8614; [ A, A = k<span class="sub3">i</span> ]</span></p>

<p>The first parameter is the array element that gets compared with <span class="mono">k<span class="sub3">i</span></span>. It passes through unchanged. The second parameter is the element that stores the result of the comparison. In this case, it is always <span class="mono">p</span>.</p>

<p>To make this work, 256 implementations of that byte matcher need to be added to the function catalog, one for each possible value of <span class="mono">k<span class="sub3">i</span></span>. However, the byte matchers operate on a pair of adjacent elements. So, the following version of the code repeatedly swaps the value in <span class="mono">a<span class="sub3">x+i</span></span> rightward along the array, until it reaches <span class="mono">a<span class="sub3">x+n&minus;1</span></span>, the element immediately left of <span class="mono">p</span>. Once there, the code performs the comparison. Then it does the swaps in reverse order to restore the moved value back to its original location.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p><span class="nowrap">Line 11</span> is expanded into <span class="nowrap">lines 11&ndash;13</span> below.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; v<span class="sub3">i</span>
<span class="line">    a<span class="sub3">x+i</span> &larr; q ? p : a<span class="sub3">x+i</span></span>
<span class="line">  a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span> &larr; q ? v<span class="sub3">0</span>&nldr;v<span class="sub3">n&minus;1</span> : a<span class="sub3">x</span>&nldr;a<span class="sub3">x+n&minus;1</span></span>
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>When the loop on <span class="nowrap">line 11</span> is unrolled, every assign-to-constant, <span class="mono">p &larr; v<span class="sub3">i</span></span>, is replaced with a constant function:</p>

<p><span class="mono">CONST_v<span class="sub3">i</span> &equiv; A &#8614; v<span class="sub3">i</span></span></p>

<p>The parameter is the array element to be assigned <span class="mono">v<span class="sub3">i</span></span>. In this case, it is always <span class="mono">p</span>.</p>

<p>As with the byte matchers, 256 implementations need to be added to the function catalog, one for each possible value of <span class="mono">v<span class="sub3">i</span></span>.</p>

<p>Additionally, every conditional-assignment, <span class="mono">a<span class="sub3">x+i</span> &larr; q ? p : a<span class="sub3">x+i</span></span>, is replaced with a conditional byte copy function:</p>

<p><span class="mono">COPY_B_A_C &equiv; [ A, B, C ] &#8614; [ C ? B : A, B, C ]</span>.</p>

<pre class="pseudocode2">
<span class="line">r &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  q &larr; <span class="keyword2">not</span> r</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    p &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    q &larr; q <span class="keyword2">and</span> p</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    p &larr; v<span class="sub3">i</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n&minus;1</span> &larr; q ? p : a<span class="sub3">x+n&minus;1</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">  r &larr; r <span class="keyword2">or</span> q</span>
</pre>

<p>...</p>

<pre class="pseudocode2">
<span class="line">a<span class="sub3">x+n+2</span> &larr; 0</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  a<span class="sub3">x+n+1</span> &larr; <span class="keyword2">not</span> a<span class="sub3">x+n+2</span></span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n</span> &larr; a<span class="sub3">x+n&minus;1</span> = k<span class="sub3">i</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n+1</span> &larr; a<span class="sub3">x+n+1</span> <span class="keyword2">and</span> a<span class="sub3">x+n</span></span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    a<span class="sub3">x+n</span> &larr; v<span class="sub3">i</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">    a<span class="sub3">x+n&minus;1</span> &larr; a<span class="sub3">x+n+1</span> ? a<span class="sub3">x+n</span> : a<span class="sub3">x+n&minus;1</span></span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      [a<span class="sub3">x+j</span>,a<span class="sub3">x+j+1</span>] &larr; [a<span class="sub3">x+j+1</span>,a<span class="sub3">x+j</span>]</span>    
<span class="line">  a<span class="sub3">x+n+2</span> &larr; a<span class="sub3">x+n+2</span> <span class="keyword2">or</span> a<span class="sub3">x+n+1</span></span>
</pre>

<p>...</p>

<pre class="pseudocode2">
<span class="line">CLEAR n+2</span>
<span class="line"><span class="keyword2">for each</span> (k, v) <span class="keyword2">in</span> m</span>
<span class="line">  COPY_NOT_B_A n+1</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      SWAP j</span>    
<span class="line">    MATCH_k<span class="sub3">i</span>_C n&minus;1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      SWAP j</span>
<span class="line">    AND_AB_AF n</span>
<span class="line">  <span class="keyword2">for</span> i &larr; 0 <span class="keyword2">to</span> n&minus;1</span>
<span class="line">    CONST_v<span class="sub3">i</span> n
<span class="line">    <span class="keyword2">for</span> j &larr; i <span class="keyword2">to</span> n&minus;2</span>
<span class="line">      SWAP j</span>
<span class="line">    COPY_B_A_C n-1</span>
<span class="line">    <span class="keyword2">for</span> j &larr; n&minus;2 <span class="keyword2">to</span> i</span>
<span class="line">      SWAP j</span>
<span class="line">  OR_AB_AF n+1</span>
</pre>

<h2 id="turing-machine">Turing Machine</h2>

<p>Of the many ways to define a <a href="https://en.wikipedia.org/wiki/Turing_machine" target="_blank">Turing machine</a>, for this discussion, it is an <a href="https://en.wikipedia.org/wiki/Abstract_machine" target="_blank">abstract machine</a> consisting of the following parts.</p>

<ul>
  <li>A <a href="https://en.wikipedia.org/wiki/Tape_drive" target="_blank">tape drive</a>.
    <ul style="padding-top: 1em;">
      <li>Mounted onto the drive is an infinitely long <span class="term">tape</span> capable of storing an endless sequence of bits. A finite, contiguous region of the tape is initialized with an input dataset. The remainder contains zeros.</li>
      <li>The tape passes horizontally under the drive's read/write <span class="term">head</span>. From its point of view, the tape extends forever both left and right. The head is limited to accessing a single bit at any time. But the drive can shift the tape to move the head one bit left or one bit right. The head is initially positioned over the leftmost bit of the input dataset.</li>
    </ul>
  </li>
  <li style="padding-top: 1em;">A <a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">state machine</a>.
    <ul style="padding-top: 1em;">
      <li>A <span class="term">register</span> stores the current state, one of a finite many. It is initialized to a starting state. If it transitions to a halt state, then the machine finished whatever it was setup to do.</li>
      <li>A <span class="term">state-transition table</span>, containing a finite number of entries, maps a state and a bit to a list of three instructions: 
        <ol style="padding-top: 1em;">
          <li>Write a specified bit.</li>
          <li>Move the head in a specified direction by one bit.</li> 
          <li>Transition to a specified state.</li>
        </ol>        
      </li>
    </ul>
  </li>
</ul>

<p>During each cycle, the machine reads a bit, it uses the current state and the read value to lookup instructions in the state-transition table, and it executes the instructions.</p>

<p>The following approach for emulating a Turing machine uses an <a href="#infinite-array-abstraction">infinite array abstraction</a> as its storage. The first <span class="nowrap"><span class="serif">N</span> bytes</span> of the array, <span class="nowrap"><span class="serif">a<span class="sub2">0</span></span>&nldr;<span class="serif">a<span class="sub2">N&minus;1</span></span></span>, serve as the state register. It is initialized to the starting state. The next byte, <span class="serif">a<span class="sub2">N</span></span>, acts as a <span class="term">boundary marker</span>. It is set to <span class="mono">FF</span>. The remaining bytes, <span class="nowrap"><span class="serif">a<span class="sub2">N+1</span>&nldr;a<span class="sub2">&infin;</span></span></span>, represent the tape drive. The lower-four bits of those bytes, <span class="serif">a:b<span class="sub2">i+N+1</span>, b < 4, i &ge; 0</span>, map to:</p>

<p><span class="nowrap serif">a:0<span class="sub2">i+N+1</span> &equiv; t<span class="sub2">i</span></span></p>

<p><span class="nowrap serif">a:1<span class="sub2">i+N+1</span> &equiv; t<span class="sub2"> &minus;(i+1)</span></span></p>

<p><span class="nowrap serif">a:2<span class="sub2">i+N+1</span> &equiv; h<span class="sub2">i</span></span></p>

<p><span class="nowrap serif">a:3<span class="sub2">i+N+1</span> &equiv; h<span class="sub2"> &minus;(i+1)</span></span></p>

<p><span class="serif">t<span class="sub2">i</span></span> is the <span class="serif">i<span class="sup2">th</span></span> bit of the tape, such that increasing <span class="serif">i</span> moves rightward. An input dataset&mdash;a list of <span class="serif">L</span> bits&mdash;is loaded into <span class="serif">t<span class="sub2">i&isin;&lsqb;0,L&minus;1&rsqb;</span></span>. The remaining tape is initialized to zeros.</p>

<p>The array stores the tape as if it were folded in half. <span class="nowrap serif">a:0<span class="sub2">x &ge; N+1</span></span> contains the right half and <span class="nowrap serif">a:1<span class="sub2">x &ge; N+1</span></span> contains the left half.</p>

<p><span class="serif">h<span class="sub2">i</span></span> is an attribute of the <span class="serif">i<span class="sup2">th</span></span> bit of the tape. It is zero, unless the drive’s head points to that bit. Since the head starts out above the leftmost bit of the input dataset, <span class="serif">h<span class="sub2">0</span></span> is initialized to one, and the rest are zeros.</p>

<p>Like <span class="serif">t</span>, the array stores <span class="serif">h</span> as if were folded in half. <span class="nowrap serif">a:2<span class="sub2">x &ge; N+1</span></span> contains the right half and <span class="nowrap serif">a:3<span class="sub2">x &ge; N+1</span></span> contains the left half.</p> 

<p>The upper-four bits of the tape drive bytes, <span class="serif">a:b<span class="sub2">i+N+1</span>, b &ge; 4, i &ge; 0</span>, are always zero.</p>

<p>The image below depicts the array's initial configuration.</p>

<object data="array-at-startup.svg" type="image/svg+xml" class="diagram">Array at startup</object>

<p>The register starts at <span class="nowrap">index 0</span>, but it is not fixed there. The Turing machine’s MetaTetrisScript directs the agent to repeatedly apply <span class="mono">SWAP</span> functions in patterns that slide the register back and forth through the array. The following animation shows the motion of a <span class="nowrap">3-byte</span> register.</p>  
  
<object data="animated-register.svg" type="image/svg+xml" class="diagram">Animated Register</object>
  
<p>Moving the register one step right, from <span class="serif">i</span> to <span class="serif">i+1</span>, takes <span class="serif">N</span> swaps: <span class="serif nowrap">[ a<span class="sub2">i+N</span>, a<span class="sub2">i+N&minus;1</span> ], [ a<span class="sub2">i+N&minus;1</span>, a<span class="sub2">i+N&minus;2</span> ], &mldr;, [ a<span class="sub2">i+1</span>, a<span class="sub2">i</span> ]</span>.</p>

<p>Moving the register one step left, from <span class="serif">i</span> to <span class="serif">i&minus;1</span>, also takes <span class="serif">N</span> swaps: <span class="serif nowrap">[ a<span class="sub2">i&minus;1</span>, a<span class="sub2">i</span> ], [ a<span class="sub2">i</span>, a<span class="sub2">i+1</span> ], &mldr;, [ a<span class="sub2">i+N&minus;2</span>, a<span class="sub2">i+N&minus;1</span> ]</span>.</p>

<p>After the register moves one step, in either direction, to some index <span class="serif">i</span>, the MetaTetrisScript directs the agent to apply a sequence of functions that operates on the register bytes, <span class="serif nowrap">a<span class="sub2">i</span>&nldr;a<span class="sub2">i+N&minus;1</span></span>, as well as the three bytes immediately to the right of the register, <span class="serif nowrap">a<span class="sub2">i+N</span>&nldr;a<span class="sub2">i+N+2</span></span>. The collective effect of the sequence is function <span class="serif">F</span>:</p> 

<p><span class="serif nowrap">a<span class="sub2">i</span>&nldr;a<span class="sub2">i+N+2</span> &larr; F(a<span class="sub2">i</span>&nldr;a<span class="sub2">i+N+2</span>)</span></p>

<p><span class="serif">F</span> conditionally carries out a Turing machine cycle based on <span class="serif">a<span class="sub2">i+N+1</span></span>. It checks if that byte contains the tape drive head:</p>

<object data="register-and-extra-bytes.svg" type="image/svg+xml" class="diagram">Register and Extra Bytes</object>
  
<p>If the head is not found (if <span class="serif nowrap">a:2<span class="sub2">i+N+1</span></span> and <span class="serif nowrap">a:3<span class="sub2">i+N+1</span></span> are both 0), then <span class="serif">F</span> passes its input through, unchanged. Otherwise, it uses the tape bit referenced by the head (either <span class="serif nowrap">a:0<span class="sub2">i+N+1</span></span> or <span class="serif nowrap">a:1<span class="sub2">i+N+1</span></span>) in conjunction with the register value to output bytes that modifies the tape, the register, and the head. Meaning, it performs the equivalent of executing the instructions looked up in the state-transition table.</p>  

<p><span class="serif">F</span> can move the head because the three extra bytes include both adjacent neighbors of the byte containing the head. However, the leftmost of the three, <span class="serif">a<span class="sub2">i+N</span></span>, might contain the boundary marker, <span class="mono">FF</span>, which represents the &ldquo;fold&rdquo; in the tape. This leads to the possibilities depicted in the following visualization.</p>

<object data="moving-the-head.svg" type="image/svg+xml" class="diagram">Moving the Head</object>  

<p>Each triplet represents a state of the three bytes. The upper and lower circles correspond to <span class="nowrap">bits 2</span> and 3 of each byte, where an unfilled circle is a <span class="mono">0</span> and a filled circle is a <span class="mono">1</span>.</p>

<p>The center column contains the possible initial states. The left and right columns show the eight outcomes after the head moves left and right, respectively. </p>

<p>In the first row, the head moves in the direction corresponding to the specified direction. In the second row, the head moves opposite to the specified direction because the tape is &ldquo;folded over&rdquo;. In the third and fourth rows, both circles of the leftmost byte are filled since it contains the boundary marker. In the third row, moving left transfers the head from <span class="nowrap">bit-2</span> to <span class="nowrap">bit-3</span>. Similarly, in the fourth row, moving right does the opposite.</p>

<p>A machine cycle consists of sliding the register from index 0 to a finite index <span class="serif">k</span> and then back to index 0, applying the transition function at each step along the way. <span class="serif">k</span> is initialized to 1 and it is incremented by 1 at the end of each cycle.</p>

<p>Since the head starts at the element corresponding to the leftmost bit of the input dataset and the transition function advances the head by at most one element, the expanding motion of the register is guaranteed to update the head at least once per cycle, and potentially multiple times per cycle. In this way, the machine always makes progress.</p>

<p>Each cycle of the machine requires more steps than the preceding cycle. This translates to an expanding, yet finite, number of TetrisScript instructions to execute per cycle, where <span class="serif">k</span> is encoded in increasing <span class="nowrap">x-coordinate</span> values.</p>

<p>The number cycles needed to complete the computation (for the machine to halt) is unknown in the general case. This necessitates an endless TetrisScript. However, since each cycle is an extension of its predecessor, the TetrisScript fed to the agent could be synthesized on demand.</p>

<p>Since one can realize a Turing machine in Tetris, Tetris is Turing-complete. Furthermore, the problem of determining if the information encoded on the pile’s surface will eventually transition to a given state from an initial state is <a href="https://en.wikipedia.org/wiki/Undecidable_problem" target="_blank">undecidable</a>. This is a corollary of the <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank">halting problem</a>. It is equivalent to asking if an arbitrary program will ultimately halt for some input dataset.</p>

<h2 id="tetris-machine">Tetris Machine</h2>

<p>Like the Turing machine implementation described above, the machine that runs Tetris consists of a state register traversing an array. On startup, a program written in <a href="https://en.wikipedia.org/wiki/Machine_code" target="_blank">machine code</a>&mdash;instructions and data encoded into a sequence of bytes of length <span class="serif">L</span>&mdash;is loaded into the array, followed by 2 padding bytes both set to zero, followed by a <span class="nowrap">21-byte</span> state register, as shown below.</p>

<object data="machine-code-padding-and-register.svg" type="image/svg+xml" class="diagram">Machine Code, Padding, and Register</object>

<p>The machine code bytes operate as RAM with an address space of <span class="serif">0</span> to <span class="serif">L&minus;1</span>. In the initial configuration above, the RAM addresses of the elements equal the array indices. However, as the state registers moves, elements shift position. Those below the state register retain RAM addresses equal to the array indices while those above it acquire RAM addresses equal to the indices minus the width of the state register <span class="nowrap serif">(address = index &minus; 21).</span></p>

<p>At runtime, the length of the array remains constant. The RAM filled with machine code constitutes the full extent of the machine’s memory. This constraint makes the machine a <span class="italic"><a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" target="_blank">deterministic linear bounded automata</a></span>, where &ldquo;linear bounded&rdquo; means the memory capacity is fixed at a linear function of the input size, <span class="serif">L</span>. It is not as powerful as a Turing machine. But, without a dependency on infinite storage, the machine is physically realizable.</p>

<p>The transition function operates on a <span class="nowrap">25-element</span> subarray that includes the 3 bytes immediately below the state register and the byte immediately above it. As revealed in the following diagram, those bytes are called <span class="mono">I</span>, <span class="mono">J</span>, <span class="mono">K</span>, and <span class="mono">Q</span>, respectively, regardless of the state register’s location.</p>

<object data="register-all-bytes.svg" type="image/svg+xml" class="diagram">All Byte Registers</object>

<p>Several of the bytes represent segments of <span class="nowrap">16-bit</span> or <span class="nowrap">24-bit</span> words:</p>

<object data="register-all.svg" type="image/svg+xml" class="diagram">All Registers</object>

<p>In the center is the <span class="nowrap">16-bit</span> <span class="term">address register</span>, <span class="mono">a</span>. At startup, it is initialized to the highest RAM address, <span class="serif">L&minus;1</span>. That value corresponds to the element at the state register’s start index minus 3. When the state register takes a downward step, <span class="mono">a</span> is decremented by 1. Likewise, when the state register takes an upward step, <span class="mono">a</span> is incremented by 1. This keeps <span class="mono">a</span> pointed at element <span class="mono">I</span>:</p>
  
<object data="register-a.svg" type="image/svg+xml" class="diagram">Address Register</object>

<p>Since <span class="mono">a</span> is a <span class="nowrap">16-bit</span> register, the maximum RAM size, <span class="serif">L<span class="sub3">max</span></span>, is <span class="serif">2<span class="sup3">16</span> B = 64 KiB</span>.</p>

<p>During each cycle of the machine, the state register slides from one end of the array to the other. On even cycles, it descends from index <span class="serif">L+2</span> to index 3 (<span class="mono">a</span> decrements from address <span class="serif">L&minus;1</span> to address 0). And on odd cycles, it ascends from index 3 to index <span class="serif">L+2</span> (<span class="mono">a</span> increments from address 0 to address <span class="serif">L&minus;1</span>). In other words, on each cycle, the state register traverses all of RAM.</p>

<p>In the course of the state register traversal, a machine code instruction is fetched from RAM into the <span class="term">instruction register</span>, <span class="mono">ijk</span>. Instructions vary in length from 1 to 3 bytes, where the first byte is the opcode and the rest, if any, is an <span class="nowrap">8-bit</span> or a <span class="nowrap">16-bit</span> operand. At 24 bits wide, <span class="mono">ijk</span> has the capacity to store any instruction.</p>

<p>The diagram below shows <span class="mono">ijk</span> along with the <span class="nowrap">16-bit</span> <span class="term">program counter</span>, <span class="mono">P</span>, which holds the address of the instruction to be fetched. As the state register slides across RAM, <span class="mono">IJK</span> is copied to <span class="mono">ijk</span> at the moment <span class="mono">P</span> equals <span class="mono">a</span>.</p>

<object data="register-p.svg" type="image/svg+xml" class="diagram">Program Counter</object>

<p>After the slide, the instruction in <span class="mono">ijk</span> is decoded and executed. If the instruction does not take up the full width of <span class="mono">ijk</span>, the remainder is discarded.</p>

<p>This process is orchestrated by MetaTetrisScripts. For instance, the following code decrements <span class="mono">a</span> and it moves the state register downward by repeatedly swapping <span class="mono">K</span> upward, fully across the state register.</p>

<pre class="code">
<span class="filename">MOVE_STATE_REG_DOWN.mt</span>
<span class="line"><span class="normal">DEC_16 </span><span class="number">13               </span><span class="comment">; --a;</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">2                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">3                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">4                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">8                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">9                  </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">10                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">11                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">12                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">13                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">14                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">15                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">16                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">17                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">18                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">19                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">20                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">21                 </span><span class="comment">; swap K up</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">22                 </span><span class="comment">; swap K up</span></span>
</pre>

<p>Similarly, the code below increments <span class="mono">a</span> and it moves the state register upward by repeatedly swapping <span class="mono">Q</span> downward.</p>

<pre class="code">
<span class="filename">MOVE_STATE_REG_UP.mt</span>
<span class="line"><span class="normal">INC_16 </span><span class="number">13               </span><span class="comment">; ++a;</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">23                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">22                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">21                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">20                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">19                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">18                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">17                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">16                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">15                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">14                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">13                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">12                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">11                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">10                 </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">9                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">8                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">7                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">6                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">5                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">4                  </span><span class="comment">; swap Q down</span></span>
<span class="line"><span class="normal">SWAP </span><span class="number">3                  </span><span class="comment">; swap Q down</span></span>
</pre>

<p>The instruction fetch is carried out by the following MetaTetrisScript.</p>

<pre class="code">
<span class="filename">FETCH.mt</span>
<span class="line"><span class="normal">CMP_C </span><span class="number">9                 </span><span class="comment">; s1 = (P1 == a1);</span></span>
<span class="line"><span class="normal">CMP_AND_C </span><span class="number">10            </span><span class="comment">; s1 &= (P0 == a0);</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">2            </span><span class="comment">; if (s1) i = I;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">3            </span><span class="comment">; if (s1) j = J;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">4            </span><span class="comment">; if (s1) k = K;</span></span>
</pre>

<p>The <span class="nowrap">8-bit</span> <span class="term">shuttle registers</span>, <span class="mono">s1</span> and <span class="mono">s0</span>, meander the state register, shuttling intermediate values between production sites and consumption sites. One of them, <span class="mono">s1</span>, appears in the code above. The <span class="mono">SWAP</span>s that move it and other registers around were omitted to highlight the most pertinent code. Similar lines were excluded from the programs below for the same reason.</p>

<p>The snippet compares <span class="mono">P</span> and <span class="mono">a</span>. Since there is no <span class="nowrap">16-bit</span> comparator, the high bytes, <span class="mono">P1</span> and <span class="mono">a1</span>, are checked for equality with an <span class="nowrap">8-bit</span> comparator, followed by the low bytes, <span class="mono">P0</span> and <span class="mono">a0</span>. The result is stored in <span class="mono">s1</span>.</p>

<p>If <span class="mono">s1</span> is set, <span class="mono">IJK</span> is copied to <span class="mono">ijk</span>. Because there is no <span class="nowrap">24-bit</span> copy function, an <span class="nowrap">8-bit</span> conditional-copy is applied to each byte.</p>

<p>After the state register slides across RAM, <span class="mono">P</span> is incremented by the fetched instruction length in preparation of the next fetch. This is achieved with match functions that check if the opcode in <span class="mono">i</span> fits the pattern of a <span class="nowrap">2-byte</span> or a <span class="nowrap">3-byte</span> instruction:</p>

<pre class="code">
<span class="filename">INCREMENT_P.mt</span>
<span class="line"><span class="normal">INC_16 </span><span class="number">8                </span><span class="comment">; ++P;</span></span>
<span class="line"><span class="normal">SEX_C </span><span class="number">12                </span><span class="comment">; s1 = (i is a 2-byte instruction);</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
<span class="line"><span class="normal">THREE_C </span><span class="number">12              </span><span class="comment">; s1 = (i is a 3-byte instruction);</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
<span class="line"><span class="normal">INC_16_C </span><span class="number">8              </span><span class="comment">; if (s1) ++P;</span></span>
</pre>

<p>After <span class="mono">P</span> is incremented, the fetched instruction is decoded and executed. The process begins with the <span class="term">transfer instructions</span>. Each copies a specified <span class="nowrap">8-bit</span> source register to a specified <span class="nowrap">8-bit</span> destination register. The register choices are:</p>

<ul>
  <li>The <span class="term">accumulator</span>, <span class="mono">A</span>, which operates as both an input and the output of <span class="term">arithmetic and logic instructions</span>.</li>

  <li>The <span class="term">data register</span>, <span class="mono">B</span>, which operates as an input of arithmetic and logic instructions.</li> 

  <li>The <span class="term">high memory address register</span>, <span class="mono">M</span>, which is the upper byte of the <span class="nowrap">16-bit</span> <span class="term">memory address register</span>, <span class="mono">MN</span>. <span class="mono">MN</span> is used as the source address of <span class="term">load instructions</span> and the destination address of <span class="term">store instructions</span>.</li> 

  <li>The <span class="term">low memory address register</span>, <span class="mono">N</span>, which is the lower byte of <span class="mono">MN</span>.</li>
</ul>

<p>As illustrated below, there are 12 ways to transfer data between these registers.</p>

<object data="register-copy-all.svg" type="image/svg+xml" class="diagram">Transfers</object>

<p>The implementation follows. If the opcode in <span class="mono">i</span> matches the pattern of a transfer instruction, then the specified source register is copied to <span class="mono">s0</span> (lines 1&ndash;8). Subsequently, <span class="mono">s0</span> is copied to the specified destination register, again conditioned on <span class="mono">i</span> (lines 10&ndash;17).</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_TRANSFER.mt</span>
<span class="line"><span class="normal">TMX_C </span><span class="number">12                </span><span class="comment">; s1 = (i matches TM*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">13           </span><span class="comment">; if (s1) s0 = M;</span></span>
<span class="line"><span class="normal">TNX_C </span><span class="number">13                </span><span class="comment">; s1 = (i matches TN*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) s0 = N;</span></span>
<span class="line"><span class="normal">TAX_C </span><span class="number">17                </span><span class="comment">; s1 = (i matches TA*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">18           </span><span class="comment">; if (s1) s0 = A;</span></span>
<span class="line"><span class="normal">TBX_C </span><span class="number">18                </span><span class="comment">; s1 = (i matches TB*);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">19           </span><span class="comment">; if (s1) s0 = B;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TXB_C </span><span class="number">18                </span><span class="comment">; s1 = (i matches T*B);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">19           </span><span class="comment">; if (s1) B = s0;</span></span>
<span class="line"><span class="normal">TXA_C </span><span class="number">17                </span><span class="comment">; s1 = (i matches T*A);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">18           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"><span class="normal">TXN_C </span><span class="number">13                </span><span class="comment">; s1 = (i matches T*N);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">14           </span><span class="comment">; if (s1) N = s0;</span></span>
<span class="line"><span class="normal">TXM_C </span><span class="number">12                </span><span class="comment">; s1 = (i matches T*M);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">13           </span><span class="comment">; if (s1) M = s0;</span></span>
</pre>

<p>Since the transfer instructions are <span class="nowrap">1-byte</span> instructions, <span class="mono">j</span> and <span class="mono">k</span> are ignored.</p>

<p>Arithmetic and logic instructions are handled next. Each computes an <span class="nowrap">8-bit</span> function of <span class="mono">A</span> or of <span class="nowrap"><span class="mono">A</span>-and-<span class="mono">B</span></span>, and it puts the result in <span class="mono">A</span>. If the result is negative (if <span class="nowrap">bit-7</span> of <span class="mono">A</span> is <span class="mono">1</span>), then the <span class="term">negative flag</span>, <span class="mono">n</span>, is set to <span class="mono">1</span>; otherwise, it is reset to <span class="mono">0</span>. If the result is zero, then the <span class="term">zero flag</span>, <span class="mono">z</span>, is set to <span class="mono">1</span>; otherwise, it is reset to <span class="mono">0</span>.</p>

<p>There are 12 arithmetic and logic instructions, all of which are <span class="nowrap">1-byte</span> instructions. As shown below, each implementation follows the same pattern. First, <span class="mono">s1</span> is assigned the result of a comparison between <span class="mono">i</span> and an opcode. Then, <span class="mono">s0</span> is set to a function of <span class="mono">A</span> or of <span class="mono">A</span>-and-<span class="mono">B</span>. Finally, <span class="mono">s0</span> is conditionally copied to <span class="mono">A</span> based on <span class="mono">s1</span>.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_ARITHMETIC_LOGIC.mt</span>
<span class="line"><span class="normal">CLEAR </span><span class="number">14                </span><span class="comment">; d = 0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ADD_C </span><span class="number">12                </span><span class="comment">; s1 = (i is ADD);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">ADD_AB_FB </span><span class="number">16            </span><span class="comment">; s0 += B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">AND_C </span><span class="number">12                </span><span class="comment">; s1 = (i is AND);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">16            </span><span class="comment">; s0 &= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">DEC_C </span><span class="number">12                </span><span class="comment">; s1 = (i is DEC);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">DEC </span><span class="number">15                  </span><span class="comment">; --s0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">INC_C </span><span class="number">12                </span><span class="comment">; s1 = (i is INC);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">INC </span><span class="number">15                  </span><span class="comment">; ++s0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS2_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS2);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS2 </span><span class="number">15                  </span><span class="comment">; s0 <<= 2;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS3_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS3);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS3 </span><span class="number">15                  </span><span class="comment">; s0 <<= 3;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LS4_C </span><span class="number">12                </span><span class="comment">; s1 = (i is LS4);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">LS4 </span><span class="number">15                  </span><span class="comment">; s0 <<= 4;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">OR_C </span><span class="number">12                 </span><span class="comment">; s1 = (i is OR);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">16             </span><span class="comment">; s0 |= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RS1_C </span><span class="number">12                </span><span class="comment">; s1 = (i is RS1);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">RS1 </span><span class="number">15                  </span><span class="comment">; s0 >>= 1;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RS5_C </span><span class="number">12                </span><span class="comment">; s1 = (i is RS5);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">RS5 </span><span class="number">15                  </span><span class="comment">; s0 >>= 5;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SUB_C </span><span class="number">12                </span><span class="comment">; s1 = (i is SUB);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">SUB_AB_FB </span><span class="number">16            </span><span class="comment">; s0 -= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">XOR_C </span><span class="number">12                </span><span class="comment">; s1 = (i is XOR);</span></span>
<span class="line"><span class="normal">OR_AB_FB </span><span class="number">13             </span><span class="comment">; d |= s1;</span></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">15             </span><span class="comment">; s0 = A;</span></span>
<span class="line"><span class="normal">XOR_AB_FB </span><span class="number">16            </span><span class="comment">; s0 ^= B;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (s1) A = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">CLEAR </span><span class="number">15                </span><span class="comment">; s0 = 0; // required by C_MINUS</span></span>
<span class="line"><span class="normal">C_MINUS </span><span class="number">15              </span><span class="comment">; s0 = (A < 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (d) n = s0;</span></span>
<span class="line"><span class="normal">C_ZERO </span><span class="number">15               </span><span class="comment">; s0 = (A == 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">14           </span><span class="comment">; if (d) z = s0;</span></span>
</pre>

<p>The <span class="term">destination flag</span>, <span class="mono">d</span>, whose name will be made clear when discussing the load instruction, is reset to <span class="mono">0</span> (false) on line 1. If <span class="mono">i</span> contains any of the 12 opcodes, <span class="mono">d</span> is set to <span class="mono">1</span> (true). On lines 77 and 79, <span class="mono">n</span> and <span class="mono">z</span> are respectively updated, subject to <span class="mono">d</span>.</p>

<p>The <span class="term">set instructions</span> are handled next. There are 3 of them and they vary in length. The first is a <span class="nowrap">2-byte</span> instruction that sets <span class="mono">A</span> to an <span class="nowrap">8-bit</span> immediate, a constant operand in <span class="mono">j</span>. The second is the same except <span class="mono">B</span> is the target:</p>

<object data="register-copy-j-to-ab.svg" type="image/svg+xml" class="diagram">Copy j to A or B</object>

<p>The third is a <span class="nowrap">3-byte</span> instruction that sets <span class="mono">MN</span> to a <span class="nowrap">16-bit</span> immediate contained in <span class="mono">jk</span>: </p>

<object data="register-copy-jk-to-mn.svg" type="image/svg+xml" class="diagram">Copy jk to MN</object>

<p>The following program decodes and executes the set instructions.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_SET.mt</span>
<span class="line"><span class="normal">SEA_C </span><span class="number">12                </span><span class="comment">; s1 = (i is SEA);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) A = j;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEB_C </span><span class="number">11                </span><span class="comment">; s1 = (i is SEB);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) B = j;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN_C </span><span class="number">11                </span><span class="comment">; s1 = (i is SMN);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) M = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">11           </span><span class="comment">; if (s1) N = k;</span></span>
</pre>

<p>The <span class="term">branch instructions</span> are handled next. There are 6 of them. Each consists of an opcode in <span class="mono">i</span> followed by a <span class="nowrap">16-bit</span> target address in <span class="mono">jk</span>. The first jumps to the target by copying <span class="mono">jk</span> to <span class="mono">P</span>:</p>

<object data="register-copy-jk-to-p.svg" type="image/svg+xml" class="diagram">Copy jk to P</object>

<p>The next 4 are <span class="term">conditional branch instructions</span>. They jump to the target iff a specified flag, <span class="mono">n</span> or <span class="mono">z</span>, equals a given value, <span class="mono">0</span> or <span class="mono">1</span>:</p>

<object data="register-copy-jk-to-p-with-nz.svg" type="image/svg+xml" class="diagram">Copy jk to P with n and z</object>

<p>The last is the <span class="term">jump-to-subroutine instruction</span>. It copies <span class="mono">P</span> to the <span class="nowrap">16-bit</span> <span class="term">return register</span>, <span class="mono">R</span>:</p>

<object data="register-copy-p-to-r.svg" type="image/svg+xml" class="diagram">Copy P to R</object>
    
<p>Since the copy occurs after <span class="mono">P</span> is incremented, <span class="mono">R</span> points to the instruction immediately following the jump-to-subroutine. That is, <span class="mono">R</span> contains the return address.</p>
    
<p>Following the copy, a jump happens:</p>
    
<object data="register-copy-jk-to-p.svg" type="image/svg+xml" class="diagram">Copy jk to P</object>
    
<p>Subsequently, invoking a <span class="term">return-from-subroutine instruction</span> restores <span class="mono">P</span> from <span class="mono">R</span>:</p>

<object data="register-copy-r-to-p.svg" type="image/svg+xml" class="diagram">Copy R to P</object>

<p>While the instruction set does not natively support a <a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank">call stack</a>, this <a href="https://en.wikipedia.org/wiki/Link_register" target="_blank">link register scheme</a> enables subroutine calls one level deep (all subroutines are <a href="https://en.wikipedia.org/wiki/Leaf_subroutine" target="_blank">leaf subroutines</a>).</p>

<p>Below are the implements.</p>

<pre class="code">
<span class="filename">DECODE_EXECUTE_BRANCH.mt</span>
<span class="line"><span class="comment">; Jump:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP_C </span><span class="number">9                 </span><span class="comment">; s1 = (i is JMP);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">10           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Conditional branches:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BEQ_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BEQ);</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">9             </span><span class="comment">; s1 &= z;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BNE_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BNE);</span></span>
<span class="line"><span class="normal">AND_NOT_AB_FB </span><span class="number">9         </span><span class="comment">; s1 &= !z;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BMI_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BMI);</span></span>
<span class="line"><span class="normal">AND_AB_FB </span><span class="number">9             </span><span class="comment">; s1 &= n;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">BPL_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is BPL);</span></span>
<span class="line"><span class="normal">AND_NOT_AB_FB </span><span class="number">9         </span><span class="comment">; s1 &= !n;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Jump-to-subroutine:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JSR_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is JSR);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">13           </span><span class="comment">; if (s1) R0 = P0;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">12           </span><span class="comment">; if (s1) P0 = k;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">10           </span><span class="comment">; if (s1) R1 = P1;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">9            </span><span class="comment">; if (s1) P1 = j;</span></span>
<span class="line"></span>
<span class="line"><span class="comment">; Return-from-subroutine:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RTS_C </span><span class="number">8                 </span><span class="comment">; s1 = (i is RTS);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">10           </span><span class="comment">; if (s1) P1 = R1;</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">13           </span><span class="comment">; if (s1) P0 = R0;</span></span>
</pre>

<p>The store and load instructions are handled last. A store instruction writes a specified source register, <span class="mono">A</span> or <span class="mono">B</span>, to memory at the address in <span class="mono">MN</span>. Execution takes place in 2 phases. In the first phase, the <span class="term">write flag</span>, <span class="mono">w</span>, is set to <span class="mono">1</span>, and the source register is copied to the <span class="nowrap">8-bit</span> <span class="term">memory data register</span>, m: </p>

<object data="register-copy-ab-to-m.svg" type="image/svg+xml" class="diagram">Copy A/B to m</object>

<p>The second phase occurs as the state register slides across RAM. It happens in parallel with the instruction fetch. For each address, if <span class="mono">w</span> is <span class="mono">1</span> and <span class="mono">a</span> equals <span class="mono">MN</span>, then <span class="mono">m</span> is copied to <span class="mono">I</span>:</p>

<object data="register-copy-m-to-i.svg" type="image/svg+xml" class="diagram">Copy m to I</object>

<p>When the instruction is not a store instruction, <span class="mono">w</span> is reset to <span class="mono">0</span>.</p>

<p>A load instruction reads a byte from memory at the address in <span class="mono">MN</span>, and it puts the byte in a specified destination register, <span class="mono">A</span> or <span class="mono">B</span>. Execution takes place in 3 phases. In the first phase, the <span class="term">read flag</span>, <span class="mono">r</span>, is set to <span class="mono">1</span>, and the aforementioned destination flag, <span class="mono">d</span>, is set to <span class="mono">0</span> for <span class="mono">A</span> or <span class="mono">1</span> for <span class="mono">B</span>.</p>

<p>The second phase occurs as the state register slides across RAM. It happens in parallel with the instruction fetch. For each address, if <span class="mono">r</span> is <span class="mono">1</span> and <span class="mono">a</span> equals <span class="mono">MN</span>, then <span class="mono">I</span> is copied to <span class="mono">m</span>: </p>

<object data="register-copy-i-to-m.svg" type="image/svg+xml" class="diagram">Copy I to m</object>

<p>The third phase happens after the slide and before the fetched instruction is decoded. If <span class="mono">r</span> is <span class="mono">1</span>, then the read byte in <span class="mono">m</span> is copied to <span class="mono">A</span> or <span class="mono">B</span> based on the value in <span class="mono">d</span>, and <span class="mono">n</span> and <span class="mono">z</span> are assigned as if the read byte is the result of an arithmetic or logic instruction: </p>

<object data="register-copy-m-to-ab.svg" type="image/svg+xml" class="diagram">Copy m to A/B</object>

<p>When the instruction is not a load instruction, <span class="mono">r</span> is reset to <span class="mono">0</span>.</p>

<p>Note: <span class="mono">d</span>, <span class="mono">n</span>, <span class="mono">r</span>, <span class="mono">w</span>, and <span class="mono">z</span> each occupy a full byte of the state register despite being <span class="nowrap">1-bit</span> flags. And there is no <span class="term">carry flag</span>.</p>

<p>The implementation of the first phase of the load and store instructions follows. As described above, load assigns <span class="mono">d</span> and <span class="mono">r</span>, while store assigns <span class="mono">m</span> and <span class="mono">w</span>.</p>

<pre class="code">
<span class="filename">DECODE_LOAD_STORE.mt</span>
<span class="line"><span class="normal">STB_C </span><span class="number">11                </span><span class="comment">; s1 = (i is STB);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">12           </span><span class="comment">; if (s1) m = B;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">STA_C </span><span class="number">11                </span><span class="comment">; s1 = (i is STA);</span></span>
<span class="line"><span class="normal">C_COPY_B_A </span><span class="number">12           </span><span class="comment">; if (s1) m = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LDB_C </span><span class="number">12                </span><span class="comment">; d = (i is LDB);</span></span>
<span class="line"><span class="normal">LDX_C </span><span class="number">7                 </span><span class="comment">; r = (i matches LD*);</span></span>
<span class="line"><span class="normal">STX_C </span><span class="number">6                 </span><span class="comment">; w = (i matches ST*);</span></span>
</pre>

<p>Since they are <span class="nowrap">1-byte</span> instructions, <span class="mono">j</span> and <span class="mono">k</span> are ignored. </p>

<p>The implementation of the second phase appears below. As the state register slides across RAM, <span class="mono">MN</span> is compared with <span class="mono">a</span>. When they match, <span class="mono">I</span> is copied to <span class="mono">m</span> if <span class="mono">r</span> indicates read, or <span class="mono">m</span> is copied to <span class="mono">I</span> if <span class="mono">w</span> indicates write.</p>

<pre class="code">
<span class="filename">EXECUTE_LOAD_STORE.mt</span>
<span class="line"><span class="normal">CMP_C </span><span class="number">12                </span><span class="comment">; s0 = (M == a1);</span></span>
<span class="line"><span class="normal">CMP_AND_C </span><span class="number">14            </span><span class="comment">; s0 &= (N == a0);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">11             </span><span class="comment">; s1 = s0;</span></span>
<span class="line"><span class="normal">AND_AB_AF </span><span class="number">8             </span><span class="comment">; s1 &= r;</span></span>
<span class="line"><span class="normal">COPY_A_B_C </span><span class="number">5            </span><span class="comment">; if (s1) m = I;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">COPY_B_A </span><span class="number">11             </span><span class="comment">; s1 = s0;</span></span>
<span class="line"><span class="normal">AND_AB_AF </span><span class="number">7             </span><span class="comment">; s1 &= w;</span></span>
<span class="line"><span class="normal">COPY_B_A_C </span><span class="number">5            </span><span class="comment">; if (s1) I = m;</span></span>
</pre>

<p>The implementation of the third phase of the load instruction follows. If <span class="mono">r</span> indicates read, then <span class="mono">n</span> and <span class="mono">z</span> are assigned based on the read byte, and the read byte is copied to <span class="mono">A</span> or <span class="mono">B</span> based on <span class="mono">d</span>. </p>

<pre class="code">
<span class="filename">ASSIGN_LOADED.mt</span>
<span class="line"><span class="normal">MINUS_C </span><span class="number">11              </span><span class="comment">; s0 = (m < 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">16           </span><span class="comment">; if (r) n = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ZERO_C </span><span class="number">16               </span><span class="comment">; s0 = (m == 0);</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">17           </span><span class="comment">; if (r) z = s0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">C_AND_A_NOT_B </span><span class="number">16        </span><span class="comment">; s0 = r & !d;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">18           </span><span class="comment">; if (s0) A = m;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">AND_A_B_C </span><span class="number">15            </span><span class="comment">; s0 = r & d;</span></span>
<span class="line"><span class="normal">C_COPY_A_B </span><span class="number">19           </span><span class="comment">; if (s0) B = m;</span></span>
</pre>

<p>Putting it all together, the downward cycle of the machine looks like this:</p>

<pre class="code">
<span class="filename">CYCLE_DOWN.mt</span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_DOWN </span><span class="number">L-1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_DOWN </span><span class="number">L-2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_DOWN </span><span class="number">L-3</span></span>
<span class="line"></span>
<span class="line"><span class="normal">...</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">2</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_DOWN </span><span class="number">2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">1</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_DOWN </span><span class="number">1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ASSIGN_LOADED </span><span class="number">0</span></span>
<span class="line"><span class="normal">INCREMENT_P </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_TRANSFER </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_ARITHMETIC_LOGIC </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_SET </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_BRANCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">DECODE_LOAD_STORE </span><span class="number">0</span></span>
</pre>

<p>The program moves the state register from the highest memory address to the lowest memory address. Along the way (lines 1&ndash;24), it fetches an instruction to execute and it potentially loads or stores a byte in RAM. Afterward (lines 26&ndash;32), the program assigns <span class="mono">A</span> or <span class="mono">B</span> to the loaded byte (if there is one), it increments <span class="mono">P</span>, and it decodes and executes the transfer instructions, the arithmetic and logic instructions, the set instructions, and the branch instructions. Finally, it decodes the load and store instructions in preparation of their execution during the next cycle.</p>

<p>The upward cycle of the machine follows. Aside from moving the state register in the opposite direction, it is identical to the downward cycle.</p>

<pre class="code">
<span class="filename">CYCLE_UP.mt</span>
<span class="line"><span class="normal">FETCH </span><span class="number">0</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">0</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_UP </span><span class="number">0</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">1</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_UP </span><span class="number">1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">2</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_UP </span><span class="number">2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">...</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-3</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_UP </span><span class="number">L-3</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-2</span></span>
<span class="line"><span class="normal">MOVE_STATE_REG_UP </span><span class="number">L-2</span></span>
<span class="line"></span>
<span class="line"><span class="normal">FETCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">EXECUTE_LOAD_STORE </span><span class="number">L-1</span></span>
<span class="line"></span>
<span class="line"><span class="normal">ASSIGN_LOADED </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">INCREMENT_P </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_TRANSFER </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_ARITHMETIC_LOGIC </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_SET </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_EXECUTE_BRANCH </span><span class="number">L-1</span></span>
<span class="line"><span class="normal">DECODE_LOAD_STORE </span><span class="number">L-1</span></span>
</pre>

<p>The placeholders, <span class="serif">L&minus;x</span>, presented in the listings above represent numerical values in the actual files. Consequentially, the file contents depend on the length of the machine code program. Since the maximum program length, <span class="serif">L<span class="sub3">max</span></span>, is only 65,536, it is possible to generate the full universe of files, making available whatever is required at startup. However, in practice, a pair of new files is simply created prior to loading a program based on its length.</p>

<p>Because Tetris is a game, it is designed to loop forever. The machine never halts. This necessitates an endless stream of TetrisScript fed to the agent. The stream is synthesized on demand by perpetually alternating between expansions of the downward and upward cycle MetaTetrisScript programs.</p>

<h2 id="assembly-language">Assembly Language</h2>

<p>The Tetris program was written in the <a href="https://en.wikipedia.org/wiki/Assembly_language" target="_blank">assembly language</a> detailed in this section. The <a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler" target="_blank">assembler</a> that converted it into machine code is case-insensitive. Though, as a convention, <a href="https://en.wikipedia.org/wiki/Assembly_language#Opcode_mnemonics_and_extended_mnemonics" target="_blank">opcode mnemonics</a> appear uppercase and the rest <a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank">camel case</a>. </p>

<h3 id="registers">Registers</h3>

<p>The following table lists the <a href="https://en.wikipedia.org/wiki/Processor_register#Types" target="_blank">user-accessible registers</a>, the subset of processor registers exposed to assembly language instructions.</p>

<table class="borderless high-rows">  
  <tr><th class="borderless">Register</th><th class="borderless">Name</th><th class="borderless">Bits</th><th class="borderless">Description</th></tr>
  <tr><td class="mono">A</td><td>Accumulator</td><td class="centered">8</td><td class="borderless">An input and the lone output of all arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">B</td><td>Data Register</td><td class="centered">8</td><td class="borderless">An input of some arithmetic and logic instructions.</td></tr>
  <tr><td class="mono">MN</td><td>Memory Address Register</td><td class="centered">16</td><td class="borderless">The source address of load instructions and the destination address of store instructions. The <span class="nowrap">8-bit</span> <span class="mono">M</span> and <span class="mono">N</span> registers contain its high and low bytes, respectively. </td></tr>
  <tr><td class="mono">P</td><td>Program Counter</td><td class="centered">16</td><td class="borderless">The address of the instruction to execute next.</td></tr>
  <tr><td class="mono">R</td><td>Return Register</td><td class="centered">16</td><td class="borderless">The address of the instruction to return to at the end of a subroutine.</td></tr>
  <tr><td class="mono">n</td><td>Negative Flag</td><td class="centered">1</td><td class="borderless">Indicates the output of an arithmetic, logic, or load instruction is negative.</td></tr>
  <tr><td class="mono">z</td><td>Zero Flag</td><td class="centered">1</td><td class="borderless">Indicates the output of an arithmetic, logic, or load instruction is zero.</td></tr>
</table>

<h3 id="transfer-instructions">Transfer Instructions</h3>

<p>A transfer instruction copies the value of a source register to a destination register. The instruction format is:</p>  

<p class="definition">T(source)(destination)</p>

<p>where <span class="mono">source</span>,<span class="mono">destination</span><span class="serif"> &isin; { </span><span class="mono">A</span>, <span class="mono">B</span>, <span class="mono">M</span>, <span class="mono">N</span><span class="serif"> }</span> and <span class="mono">source</span> &ne; <span class="mono">destination</span>.  

<p>Each transfer instruction corresponds to an opcode with bits <span class="mono">0000ssdd</span>, where <span class="mono">ss</span> and <span class="mono">dd</span> are one of the values below.</p>

<table class="borderless">
  <tr><th class="borderless">Value</th><th class="borderless">Register</th></tr>
  <tr><td class="mono">00</td><td class="mono">A</td></tr>
  <tr><td class="mono">01</td><td class="mono">B</td></tr>	
  <tr><td class="mono">10</td><td class="mono">M</td></tr>
  <tr><td class="mono">11</td><td class="mono">N</td></tr>
</table>

<p>The 12 transfer instructions follow.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">TAB</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">B</span></td><td class="pseudocode">B = A;</td><td class="mono">01</td></tr>
  <tr><td class="mono">TAM</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">M</span></td><td class="pseudocode">M = A;</td><td class="mono">02</td></tr>
  <tr><td class="mono">TAN</td><td class="borderless">Transfer <span class="mono">A</span> to <span class="mono">N</span></td><td class="pseudocode">N = A;</td><td class="mono">03</td></tr>
  <tr><td class="mono">TBA</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">A</span></td><td class="pseudocode">A = B;</td><td class="mono">04</td></tr>
  <tr><td class="mono">TBM</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">M</span></td><td class="pseudocode">M = B;</td><td class="mono">06</td></tr>
  <tr><td class="mono">TBN</td><td class="borderless">Transfer <span class="mono">B</span> to <span class="mono">N</span></td><td class="pseudocode">N = B;</td><td class="mono">07</td></tr>
  <tr><td class="mono">TMA</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">A</span></td><td class="pseudocode">A = M;</td><td class="mono">08</td></tr>
  <tr><td class="mono">TMB</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">B</span></td><td class="pseudocode">B = M;</td><td class="mono">09</td></tr>
  <tr><td class="mono">TMN</td><td class="borderless">Transfer <span class="mono">M</span> to <span class="mono">N</span></td><td class="pseudocode">N = M;</td><td class="mono">0B</td></tr>
  <tr><td class="mono">TNA</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">A</span></td><td class="pseudocode">A = N;</td><td class="mono">0C</td></tr>
  <tr><td class="mono">TNB</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">B</span></td><td class="pseudocode">B = N;</td><td class="mono">0D</td></tr>
  <tr><td class="mono">TNM</td><td class="borderless">Transfer <span class="mono">N</span> to <span class="mono">M</span></td><td class="pseudocode">M = N;</td><td class="mono">0E</td></tr>
</table>

<p>The transfer instructions do not affect the flags.</p>

<h3 id="arithmetic-and-logic-instructions">Arithmetic and Logic Instructions</h3>

<p>An arithmetic or logic instruction computes an <span class="nowrap">8-bit</span> function of <span class="mono">A</span> or of <span class="nowrap"><span class="mono">A</span>-and-<span class="mono">B</span></span>, and it stores the result in <span class="mono">A</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">ADD</td><td class="borderless">Add (without carry)</td><td class="pseudocode">A += B;</td><td class="mono">10</td></tr>    
  <tr><td class="mono">AND</td><td class="borderless">Bitwise AND</td><td class="pseudocode">A &= B;</td><td class="mono">11</td></tr>
  <tr><td class="mono">DEC</td><td class="borderless">Decrement</td><td class="pseudocode">--A;</td><td class="mono">12</td></tr>
  <tr><td class="mono">INC</td><td class="borderless">Increment</td><td class="pseudocode">++A;</td><td class="mono">13</td></tr>
  <tr><td class="mono">LS2</td><td class="borderless">Logical Left Shift by 2</td><td class="pseudocode">A <<= 2;</td><td class="mono">14</td></tr>
  <tr><td class="mono">LS3</td><td class="borderless">Logical Left Shift by 3</td><td class="pseudocode">A <<= 3;</td><td class="mono">15</td></tr>
  <tr><td class="mono">LS4</td><td class="borderless">Logical Left Shift by 4</td><td class="pseudocode">A <<= 4;</td><td class="mono">16</td></tr>
  <tr><td class="mono">OR</td><td class="borderless">Bitwise OR</td><td class="pseudocode">A |= B;</td><td class="mono">17</td></tr>
  <tr><td class="mono">RS1</td><td class="borderless">Logical Right Shift by 1</td><td class="pseudocode">A >>>= 1;</td><td class="mono">18</td></tr>
  <tr><td class="mono">RS5</td><td class="borderless">Logical Right Shift by 5</td><td class="pseudocode">A >>>= 5;</td><td class="mono">19</td></tr>
  <tr><td class="mono">SUB</td><td class="borderless">Subtract (without borrow)</td><td class="pseudocode">A -= B;</td><td class="mono">1A</td></tr>
  <tr><td class="mono">XOR</td><td class="borderless">Bitwise XOR</td><td class="pseudocode">A ^= B;</td><td class="mono">1B</td></tr>
</table>

<p>The <span class="nowrap">carry-outs</span> of <span class="mono">ADD</span> and <span class="mono">INC</span>, the <span class="nowrap">borrow-outs</span> of <span class="mono">SUB</span> and <span class="mono">DEC</span>, and the <span class="span">shift-outs</span> of the shift instructions are lost. There is no add-with-carry instruction nor a subtract-with-borrow instruction. All shift instructions <span class="nowrap">shift-in</span> <span class="mono">0</span>.</p> 

<p>The zero flag, <span class="mono">z</span>, is set to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is zero; otherwise, it is reset to <span class="mono">0</span>.</p>

<p>The negative flag, <span class="mono">n</span>, is set to <span class="mono">1</span> if the resultant value in <span class="mono">A</span> is negative (if <span class="nowrap">bit-7</span> is <span class="mono">1</span>); otherwise, it is reset to <span class="mono">0</span>.</p>

<p>Each arithmetic or logic instruction corresponds to an opcode with bits <span class="mono">0001xxxx</span>. Of the 16 possibilities, only 12 are assigned. Potential additions include Bitwise <span class="mono">NOT</span> and shifts by other values. The instructions above were selected to satisfy the requirements of a single program, one that runs Tetris.</p>

<h3 id="branch-instructions">Branch Instructions</h3>

<p>A branch instruction can direct execution to a specified location in the program. With one exception, the branch instructions have the following format.</p>

<p class="definition">mnemonic label</p>

<p>A label is a placeholder for an address. In this case, it is the address of the code to run if the branch is taken.</p>

<p>A label is declared immediately before target code or data, enabling resolution of its address during assembly. The declaration consists of a unique name followed by a colon, as shown below.</p>

<p class="definition">name:</p>

<p>Here are all the branch instructions:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">JMP label</td><td class="borderless pad-left pad-right">Jump</td><td class="pseudocode">P = label;</td><td class="mono">20</td></tr>    
  <tr><td class="mono">BNE label</td><td class="borderless pad-left pad-right">Branch Not Equal</td><td class="pseudocode">if (z == 0) P = label;</td><td class="mono">22</td></tr>
  <tr><td class="mono">BEQ label</td><td class="borderless pad-left pad-right">Branch Equal</td><td class="pseudocode">if (z == 1) P = label;</td><td class="mono">23</td></tr>
  <tr><td class="mono">BPL label</td><td class="borderless pad-left pad-right">Branch Plus</td><td class="pseudocode">if (n == 0) P = label;</td><td class="mono">24</td></tr>
  <tr><td class="mono">BMI label</td><td class="borderless pad-left pad-right">Branch Minus</td><td class="pseudocode">if (n == 1) P = label;</td><td class="mono">25</td></tr>
  <tr><td class="mono">JSR label</td><td class="borderless pad-left pad-right">Jump Subroutine</td><td class="pseudocode">R = P; P = label;</td><td class="mono">28</td></tr>
  <tr><td class="mono">RTS</td><td class="borderless pad-left pad-right">Return Subroutine</td><td class="pseudocode">P = R;</td><td class="mono">70</td></tr>
</table>

<p><span class="mono">RTS</span> is a <span class="nowrap">1-byte</span> instruction. The rest are <span class="nowrap">3-byte</span> instructions consisting of an opcode followed by the label address encoded <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">big-endian</a>. The opcode is composed of bits <span class="mono">0010rstu</span>:</p>

<ul>
  <li>If <span class="mono">t</span> is <span class="mono">1</span>, then the zero flag, <span class="mono">z</span>, must equal <span class="mono">u</span> to branch.</li>
  <li>If <span class="mono">s</span> is <span class="mono">1</span>, then the negative flag, <span class="mono">n</span>, must equal <span class="mono">u</span> to branch.</li>
  <li>If <span class="mono">r</span> is <span class="mono">1</span>, then the program counter, <span class="mono">P</span>, is copied to the return register, <span class="mono">R</span>, before jumping. That feature is used by <span class="mono">JSR</span> while <span class="mono">RTS</span> does the opposite. This enables subroutine calls one level deep. No other instructions access <span class="mono">R</span>.</li>
</ul>

<p>The conditional branch instructions&mdash;<span class="mono">BNE</span>, <span class="mono">BEQ</span>, <span class="mono">BPL</span>, and <span class="mono">BMI</span>&mdash;can serve as <a href="https://en.wikipedia.org/wiki/Relational_operator" target="_blank">relational operators</a> by branching on the result of <span class="nowrap mono">A - B</span>. However, <span class="mono">BPL</span> and <span class="mono">BMI</span> treat the difference as a signed number. This leads to the following limitations.</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Relation</th><th class="borderless">Limitations</th></tr>
  <tr><td class="mono">BNE</td><td class="pseudocode">A &ne; B</td><td class="pseudocode">A - B &ne; 0</td></tr>
  <tr><td class="mono">BEQ</td><td class="pseudocode">A = B</td><td class="pseudocode">A - B = 0</td></tr>
  <tr><td class="mono">BPL</td><td class="pseudocode">A &ge; B</td><td class="pseudocode">A - B &#8714; [0, 127]</td></tr>
  <tr><td class="mono">BMI</td><td class="pseudocode">A &lt; B</td><td class="pseudocode">A - B &#8714; [-128, -1]</td></tr>
</table>

<p>Since there is no <a href="https://en.wikipedia.org/wiki/Carry_flag" target="_blank">carry flag</a> nor its complementary <span class="mono">BCC</span> and <span class="mono">BCS</span> instructions, an <a href="https://en.wikipedia.org/wiki/Inequality_(mathematics)" target="_blank">inequality</a> test for an unsigned difference requires multiple steps. One option is to logical right shift <span class="mono">A</span> and <span class="mono">B</span> by <span class="mono">1</span> before subtracting. If the difference is nonzero, then the test is complete. Otherwise, the original <span class="nowrap">bit-0s</span> need to be compared.</p>

<p>While there is no <a href="https://en.wikipedia.org/wiki/Indirect_branch" target="_blank">indirect branch</a> instruction, <a href="https://en.wikipedia.org/wiki/Self-modifying_code" target="_blank">self-modifying code</a> can be used to alter a branch target at runtime.</p>

<p>By default, program execution starts with all registers initialized to <span class="mono">0</span>. Since that includes the <span class="mono">P</span> register, the default <a href="https://en.wikipedia.org/wiki/Entry_point" target="_blank">entry point</a> is the first line of code. However, if the program includes a label named <span class="mono">main</span>, then <span class="mono">P</span> is set to its address at startup, as if a jump automatically occurred to that location.</p>

<h3 id="load-instructions">Load Instructions</h3>

<p>A load reads the memory value at the address in <span class="mono">MN</span> into either <span class="mono">A</span> or <span class="mono">B</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">LDA</td><td class="borderless">Load <span class="mono">A</span></td><td class="pseudocode">A = *MN;</td><td class="mono">40</td></tr>    
  <tr><td class="mono">LDB</td><td class="borderless">Load <span class="mono">B</span></td><td class="pseudocode">B = *MN;</td><td class="mono">41</td></tr>
</table>

<p>The zero flag, <span class="mono">z</span>, is set to <span class="mono">1</span> if the read value is zero; otherwise, it is reset to <span class="mono">0</span>.</p>

<p>The negative flag, <span class="mono">n</span>, is set to <span class="mono">1</span> if the read value is negative (if <span class="nowrap">bit-7</span> is <span class="mono">1</span>); otherwise, it is reset to <span class="mono">0</span>.</p>

<p>Each load instruction maps to an opcode with bits <span class="mono">0100000d</span>, where <span class="mono">A</span> and <span class="mono">B</span> correspond to <span class="mono">d</span> values <span class="mono">0</span> and <span class="mono">1</span>, respectively.</p>

<h3 id="store-instructions">Store Instructions</h3>

<p>A store instruction writes the value in either <span class="mono">A</span> or <span class="mono">B</span> to memory at the address in <span class="mono">MN</span>:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">STA</td><td class="borderless">Store <span class="mono">A</span></td><td class="pseudocode">*MN = A;</td><td class="mono">30</td></tr>    
  <tr><td class="mono">STB</td><td class="borderless">Store <span class="mono">B</span></td><td class="pseudocode">*MN = B;</td><td class="mono">31</td></tr>
</table>

<p>No flags are affected.</p>

<p>Each store instruction maps to an opcode with bits <span class="mono">0011000s</span>, where <span class="mono">A</span> and <span class="mono">B</span> correspond to <span class="mono">s</span> values <span class="mono">0</span> and <span class="mono">1</span>, respectively.</p>

<h3 id="set-instructions">Set Instructions</h3>

<p>A set instruction moves an immediate (a constant) into a register:</p>

<table class="borderless">
  <tr><th class="borderless">Instruction</th><th class="borderless">Name</th><th class="borderless">Pseudocode</th><th class="borderless">Opcode</th></tr>
  <tr><td class="mono">SEA immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">A</span></td><td class="pseudocode">A = immediate;</td><td class="mono">50</td></tr>    
  <tr><td class="mono">SEB immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">B</span></td><td class="pseudocode">B = immediate;</td><td class="mono">51</td></tr>
  <tr><td class="mono">SMN immediate</td><td class="borderless pad-left pad-right">Set <span class="mono">MN</span></td><td class="pseudocode">MN = immediate;</td><td class="mono">2F</td></tr>
</table>

<p><span class="mono">SEA</span> and <span class="mono">SEB</span> accept a byte immediate whereas <span class="mono">SMN</span> accepts a <span class="nowrap">16-bit<span> word immediate.</p>

<p>The instructions assemble to an opcode followed by the immediate byte or bytes encoded big-endian.</p>      
      
<p>The immediate can be an <a href="https://en.wikipedia.org/wiki/Integer_literal" target="_blank">integer literal</a> written in hexadecimal. As shown below, a byte literal contains 2 hex digits while a word literal contains 4.</p>

<pre class="code">
<span class="line"><span class="normal">SEA</span> <span class="number">D3</span>                  <span class="comment">; A = 0xD3;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">7F</span>                  <span class="comment">; B = 0x7F;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="number">1234</span>                <span class="comment">; MN = 0x1234;</span></span>
</pre>

<p>The <span class="mono">define</span> directive equates a name with an integer literal:</p>

<p class="definition">define name value</p>

<p>Defined values can serve as immediate operands:</p>

<pre class="code">
<span class="line"><span class="keyword">define</span> <span class="identifier">X</span> <span class="number">D3</span>             <span class="comment">; #define X 0xD3</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">Y</span> <span class="number">7F</span>             <span class="comment">; #define Y 0x7F</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">Z</span> <span class="number">1234</span>           <span class="comment">; #define Z 0x1234</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">X</span>                   <span class="comment">; A = X;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">Y</span>                   <span class="comment">; B = Y;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">Z</span>                   <span class="comment">; MN = Z;</span></span>
</pre>

<p>To reserve and initialize a data region, an integer literal or a sequence of integer literals is written without a preceding instruction mnemonic. Accessing the region requires its address. One way to get it is to preface the region with a label. And that label can successively be used as immediate operand. This is demonstrated in the following example where the declaration of the label <span class="mono">v</span> is followed by a byte literal.</p>

<pre class="code">
<span class="line"><span class="label">v:</span> <span class="number">00</span>                   <span class="comment">; v = 0;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">v</span>                   <span class="comment">; MN = &v;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
<span class="line"><span class="normal">INC</span>                     <span class="comment">; ++A;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
</pre>

<p><span class="mono">v</span> is a placeholder for the address of the 1-byte data region. But, since it can be used as an operand, it works like a byte variable. Lines 3&ndash;6 are equivalent to <span class="mono">++v;</span></p>

<p>The next example reserves and initializes an <span class="nowrap">8-element</span> byte array, <span class="mono">table</span>, and a byte variable, <span class="mono">index</span>.</p>

<pre class="code">
<span class="line"><span class="keyword">segment</span> <span class="number">0180</span></span>
<span class="line"></span>
<span class="line"><span class="label">table:</span>                  <span class="comment">; table[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 }; </span></span>
<span class="line"><span class="number">01</span> <span class="number">02</span> <span class="number">04</span> <span class="number">08</span></span>
<span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">40</span> <span class="number">80</span></span>
<span class="line"></span>
<span class="line"><span class="label">index:</span> <span class="number">03</span>               <span class="comment">; index = 0x03;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">index</span>               <span class="comment">; MN = &index;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">table</span>               <span class="comment">; MN = table;</span></span>
<span class="line"><span class="normal">TNB</span>                     <span class="comment">; B = N;</span></span>
<span class="line"><span class="normal">ADD</span>                     <span class="comment">; A += B;</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N = A;</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; A = *MN;</span></span>
</pre>

<p>Lines 9&ndash;15 are equivalent to:</p>

<p><span class="mono">A = table[index];</span></p>

<p>That can be expressed as:</p>

<p><span class="mono">A = *(table + index);</span></p> 

<p>However, without a carry flag, adding a <span class="nowrap">16-bit</span> value to an <span class="nowrap">8-bit</span> value is challenging. Instead, the code takes advantage of the <span class="mono">segment</span> directive, which has the following format.</p> 

<p class="definition">segment address</p>

<p>It instructs the assembler to store bytes generated from subsequent code at the specified address. In this case, the effect is:</p>

<p><span class="mono">table = 0x0180;</span></p>

<p>Since the table is fully contained within the same <span class="nowrap">256-byte</span> memory page, adding <span class="mono">table</span> and <span class="mono">index</span> does not produce a carry. The code offsets only the <span class="nowrap">low-byte</span> of the address.</p>

<p>To facilitate <a href="https://en.wikipedia.org/wiki/Self-modifying_code" target="_blank">self-modifying code</a>, a label, when used as an operand, can be offset by a positive or negative constant with the notation below.</p>

<p class="definition">label[+-]offset</p> 

<p>The offset is a fixed integer value written in decimal.</p>  

<p>The notation provides a way to modify the operand of an instruction, as seen in the following example.</p> 

<pre class="code">
<span class="line"><span class="normal">SEA</span> <span class="number">FF</span>                  <span class="comment">; A = 0xFF;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">target</span><span class="normal">+</span><span class="number">1</span>            <span class="comment">; MN = target + 1;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
<span class="line"></span>
<span class="line"><span class="label">target:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span>                  <span class="comment">; B = 0x00; // until replaced with 0xFF</span></span>
</pre>

<p><span class="mono">target</span> points to the opcode of the <span class="mono">SEB</span> instruction. At runtime, lines 1&ndash;3 change the immediate operand, which is located one byte past the opcode, from <span class="mono">00</span> to <span class="mono">FF</span>.</p> 

<p>In summary, the operand of <span class="mono">SMN</span> can be any of the following.</p>

<p class="definition">SMN word | label | label+offset | label-offset</p>

<p>The same applies to branch instructions; i.e., the target of the branch can any of the above. But it is rarely worthwhile to jump to a numerical address or to a label offset by a constant.</p>

<h2 id="tetris-program">Tetris Program</h2>

<p>The Tetris program is a barebones implementation of the game that employs the right-handed Nintendo Rotation System (NRS). As a randomly-selected Tetrimino falls, the agent shifts it left or right, rotates it clockwise or counterclockwise, or soft drops it. When the piece locks into the pile, completed lines are cleared, the rows above them shift downward, and the next piece spawns.</p>

<p>The game does not keep track of the number of lines cleared, nor the score or any other statistics. That being the case, the level never increases and the drop speed remains constant. There is no hard drop, no <span class="term"><a href="https://tetris.wiki/Piece_preview" target="_blank">piece preview</a></span>, no <span class="term"><a href="https://tetris.wiki/Ghost_piece" target="_blank">ghost piece</a></span>, no <span class="term"><a href="https://tetris.wiki/Hold_piece" target="_blank">hold piece</a></span>, no music or sound effects, no multiagent or <span class="term"><a href="https://tetris.wiki/Garbage" target="_blank">garbage</a></span>, no title screen, menus, configuration, demo, or endings. There is nothing beyond the core game mechanics.</p>

<p>The program begins by defining a set of constants:</p>

<pre class="code">
<span class="line"><span class="keyword">define</span> <span class="identifier">FALL_SPEED</span> <span class="number">01</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_ATTRACT</span>     <span class="number">00</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_PLAY</span>        <span class="number">01</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">MODE_CLEAR_LINES</span> <span class="number">02</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">ACTION_DRAW</span> <span class="number">22</span> <span class="comment">; BNE</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">ACTION_TEST</span> <span class="number">23</span> <span class="comment">; BEQ</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">CELL_EMPTY</span> <span class="number">00</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">CELL_SOLID</span> <span class="number">FF</span> <span class="comment">; Any nonzero cell is solid</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">PLAYFIELD_WIDTH</span> <span class="number">0B</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_X</span> <span class="number">05</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_Y</span> <span class="number">02</span></span>
<span class="line"><span class="keyword">define</span> <span class="identifier">SPAWN_ROTATION</span> <span class="number">00</span></span>
</pre>

<p><span class="mono">FALL_SPEED</span> is the initial value of the fall timer. On each frame, if the fall timer is not <span class="mono">0</span>, then it is decremented by <span class="mono">1</span>. Otherwise, a gravity drop occurs and the fall timer is reset to <span class="mono">FALL_SPEED</span>. A <span class="mono">FALL_SPEED</span> of <span class="mono">1</span> means a gravity drop occurs every other frame. Since the frame rate is approximately 5 frames/sec, a gravity drop happens about every <span class="nowrap">400 milliseconds</span>. That fall speed is roughly equivalent to <span class="nowrap">level 5</span> in <span class="nowrap">NES Tetris</span>.</p>

<p>The program switches between the modes defined on lines 3&ndash;5. <span class="mono">MODE_ATTRACT</span> is a very basic <span class="term"><a href="https://en.wikipedia.org/wiki/Glossary_of_video_game_terms#attract_mode" target="_blank">attract mode</a></span> that simply keeps the last <span class="term"><a href="https://tetris.wiki/Top_out" target="_blank">top out</a></span> on display, or an empty playfield at startup. It is unresponsive to controls except for the Start button, which clears the playfield and transitions to <span class="mono">MODE_PLAY</span>. As its name suggests, that is the mode where the agent interacts with the falling pieces. When a piece locks into the pile, the program temporarily changes to <span class="mono">MODE_CLEAR_LINES</span>, during which it scans for and removes completed lines.</p>

<p>The program declares a single subroutine called <span class="mono">drawOrTestTetrimino</span> that performs the actions defined on lines 7 and 8. <span class="mono">ACTION_DRAW</span> directs <span class="mono">drawOrTestTetrimino</span> to paint four playfield cells corresponding to the blocks of a named Tetrimino at a specified location and orientation in a prescribed color. <span class="mono">ACTION_TEST</span> directs <span class="mono">drawOrTestTetrimino</span> to verify that four playfield cells corresponding to the blocks of a named Tetrimino at a specified location and orientation are all empty. It enables the program to determine if a requested move is a valid move.</p>

<p>Since the language does not support a call stack, <span class="mono">drawOrTestTetrimino</span> receives the Tetrimino type, coordinates, and orientation via global variables, and the action and the color via self-modifying code. The action constants are the opcodes for <span class="mono">BNE</span> and <span class="mono">BEQ</span>. They are used to overwrite an instruction in <span class="mono">drawOrTestTetrimino</span> to alter its behavior.</p>

<p>The remaining constants relate to the playfield. As revealed below, the playfield is a matrix with 23 rows and 11 columns (<span class="mono">PLAYFIELD_WIDTH</span>). Each byte contains the state of an individual cell. <span class="mono">00</span> (<span class="mono">CELL_EMPTY</span>) means the cell is empty. Any other value represents the color of a solid cell.</p>

<pre class="code" style="counter-increment: step 18;">
<span class="line"><span class="keyword">segment</span> <span class="number">0000</span></span>
<span class="line"><span class="label">playfield:</span></span>
<span class="line"><span class="comment">;  0  1  2  3  4  5  6  7  8  9 10</span></span>
<span class="line">  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">FF</span>  <span class="comment">;  0</span></span>
<span class="line">  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">FF</span>  <span class="comment">;  1</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  2</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  3</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  4</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  5</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  6</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  7</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  8</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">;  9</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 10</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 11</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 12</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 13</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 14</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 15</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 16</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 17</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 18</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 19</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 20</span></span>
<span class="line">  <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number2">00</span> <span class="number">FF</span>  <span class="comment">; 21</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">FF</span> <span class="number">00</span>  <span class="comment">; 22</span></span>
</pre>

<p>The green rectangular region is the visible playfield. It spans rows 2&ndash;21 and columns 0&ndash;9. Tetriminos spawn in the middle of its ceiling, centered at row 2 (<span class="mono">SPAWN_Y</span>) and column 5 (<span class="mono">SPAWN_X</span>).</p>

<p>Rows 0 and 1 comprise the <span class="term"><a href="https://tetris.wiki/Playfield#Vanish_zone" target="_blank">vanish zone</a></span>, the area above the ceiling that falling Tetriminos can rotate and even lock into. <span class="mono">SPAWN_ROTATION</span> ensures that newly spawned Tetriminos are oriented such that none of its blocks start out in the vanish zone.</p>

<p>Row 22 and column 10 consist entirely of solid cells (<span class="mono">CELL_SOLID</span>), except for the element in the lower-right corner. They simplify <span class="mono">drawOrTestTetrimino</span>. When it scans for empty spaces, row 22 and column 10 make out-of-bounds cells appear solid.</p>  

<p>Note: Regardless of how it is formatted, the matrix, like all data regions, is a one-dimensional array. As such, every row of the visible playfield has a solid cell after its rightmost element and before its leftmost element. This means, column 10 serves as both the right wall and the left wall. On the other hand, row 22 is just the floor.</p> 

<p>When a Tetrimino locks into the pile, four rows about its center are scanned for lines. The scan ignores the bounds of the visible playfield for code simplicity. To prevent row 22 from inadvertently being detected as a line, its rightmost element is marked empty and the scan is rigged to check for a row of eleven solid cells, rather than ten. The eleven-solids check works on the visible rows due the solid elements of column 10.</p>

<p>Clearing a line means all the rows above it shift downward. This is accomplished by overwriting each row with a copy of its preceding row. Row 0, which has no preceding row, is reset to ten empty cells followed by a solid cell.</p> 

<p>At the start of a new game, the playfield is reset to the initial state seen in the listing above.</p> 

<p>The segment directive (line 19) is superfluous because no instructions or data appear before the playfield. But the directive makes it clear the playfield is located at the beginning of RAM. I.e., the label <span class="mono">playfield</span> resolves to address <span class="mono">0</span>.</p>

<p>At <span class="nowrap">23 &times; 11 = 253 bytes</span> long, the playfield fits in the first <span class="nowrap">256-byte</span> page of memory with 3 bytes to spare. This means, the cell at <span class="nowrap">(<span class="mono">row</span>, <span class="mono">col</span>)</span> is addressable with the following pseudocode.</p> 

<pre class="pseudocode">
M = 0;               // page zero

N = 11 * row + col;  // offset within page zero
</pre>

<p>As discussed thus far, the machine that runs Tetris is comprised of an <span class="nowrap">8-bit</span> CPU and up to <span class="nowrap">64 KiB</span> of RAM initialized with the instructions and the data of the program to be executed. RAM initialization is carried out by a mechanism analogous to a peripheral data storage device. However, with that peripheral alone, the machine is limited to <a href="https://en.wikipedia.org/wiki/Batch_processing" target="_blank">batch processing</a>. To establish a real-time interface between the machine and a human agent, additional peripherals are required.</p>

<p>One such peripheral is a display device that presents a graphical representation of the visible playfield. It takes the form of the window below.</p>

<object data="sample-gameplay.png" type="image/png" class="diagram">Sample Gameplay</object>

<p>The window portrays a <span class="nowrap">20 row</span> by <span class="nowrap">10 column</span> grid of colored cells, where each color corresponds to the <span class="nowrap">lower-3</span> bits of a byte of visible playfield RAM per the following mapping.</p>

<table class="borderless">
<tr><th class="borderless">Value</th><th class="borderless">Tetrimino</th><th class="borderless">Color</th></tr>
<tr><td class="mono">0</td><td class="roboto centered">(empty)</td><td class="borderless">Black</td></tr>
<tr><td class="mono">1</td><td class="roboto centered">T</td><td class="borderless">Purple</td></tr>
<tr><td class="mono">2</td><td class="roboto centered">J</td><td class="borderless">Blue</td></tr>
<tr><td class="mono">3</td><td class="roboto centered">Z</td><td class="borderless">Red</td></tr>
<tr><td class="mono">4</td><td class="roboto centered">O</td><td class="borderless">Yellow</td></tr>
<tr><td class="mono">5</td><td class="roboto centered">S</td><td class="borderless">Green</td></tr>
<tr><td class="mono">6</td><td class="roboto centered">L</td><td class="borderless">Orange</td></tr>
<tr><td class="mono">7</td><td class="roboto centered">I</td><td class="borderless">Cyan</td></tr>
</table>

<p>The displayed image is backed by a two-dimensional array that works like a VRAM <a href="https://en.wikipedia.org/wiki/Framebuffer" target="_blank">framebuffer</a>. Its independence from RAM enables the program to incrementally update the playfield without revealing the intermediate changes. In other words, the playfield in RAM is an off-screen buffer.</p> 

<p>The program and the window communicate via <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O" target="_blank">memory-mapped I/O</a>. After the program updates the off-screen buffer, it writes <span class="mono">01</span> to <span class="mono">00FD</span>, the <span class="mono">drawFrame</span> flag in the listing below.

<pre class="code" style="counter-increment: step 45;">
<span class="line"><span class="keyword">segment</span> <span class="number">00FD</span></span>
<span class="line"><span class="label">drawFrame:</span>           <span class="number">00</span> <span class="comment">; 00 = generating frame; otherwise, finished generating frame</span></span>
<span class="line"><span class="label">leftButton:</span>          <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">rightButton:</span>         <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
</pre>

<p>The window polls that location. When it reads a nonzero value, it copies the visible playfield from RAM to the two-dimensional array. Then it repaints the displayed image, revealing the array's new content.</p>

<p>Following a repaint, the window provides the program with a status update of the game controls. For each button, it writes either <span class="mono">00</span> for released or <span class="mono">01</span> for pressed to an address specific to the button. Then, it resets <span class="mono">drawFrame</span> to <span class="mono">00</span> in preparation of the next frame.</p>

<p>As shown in the code above, the window transfers the states of left and right buttons in the final-two bytes of memory page zero. The addresses of the remaining buttons appear later in the code because aligned with the start of page one is the Tetriminos table:</p>

<pre class="code" style="counter-increment: step 50;">
<span class="line"><span class="keyword">segment</span> <span class="number">0100</span></span>
<span class="line"><span class="label">tetriminos:</span></span>
<span class="line"><span class="comment">;  0  1  2  3</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">;  0 td {  -1,   0,   1,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">;  1 tl { -11,  -1,   0,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">F5</span> <span class="comment">;  2 tu {  -1,   0,   1, -11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">;  3 tr { -11,   0,   1,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">;  4 jd {  -1,   0,   1,  12 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">;  5 jl { -11,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">F4</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">;  6 ju { -12,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">F6</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">;  7 jr { -11, -10,   0,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">;  8 zh {  -1,   0,  11,  12 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">;  9 zv { -10,   0,   1,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">; 10 zh {  -1,   0,  11,  12 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0B</span> <span class="comment">; 11 zv { -10,   0,   1,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 12 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 13 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 14 o  {  -1,   0,  10,  11 }</span></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 15 o  {  -1,   0,  10,  11 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 16 sh {   0,   1,  10,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">; 17 sv { -11,   0,   1,  12 }</span></span>
<span class="line">  <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="number">0B</span> <span class="comment">; 18 sh {   0,   1,  10,  11 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0C</span> <span class="comment">; 19 sv { -11,   0,   1,  12 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="number">0A</span> <span class="comment">; 20 ld {  -1,   0,   1,  10 }</span></span>
<span class="line">  <span class="number">F4</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 21 ll { -12, -11,   0,  11 }</span></span>
<span class="line">  <span class="number">F6</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 22 lu { -10,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">0C</span> <span class="comment">; 23 lr { -11,   0,  11,  12 }</span></span>
<span class="line"></span>
<span class="line">  <span class="number">FE</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 24 ih {  -2,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">EA</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 25 iv { -22, -11,   0,  11 }</span></span>
<span class="line">  <span class="number">FE</span> <span class="number">FF</span> <span class="number">00</span> <span class="number">01</span> <span class="comment">; 26 ih {  -2,  -1,   0,   1 }</span></span>
<span class="line">  <span class="number">EA</span> <span class="number">F5</span> <span class="number">00</span> <span class="number">0B</span> <span class="comment">; 27 iv { -22, -11,   0,  11 }</span></span>
</pre>

<p>Each row contains the coordinates of four blocks of a rotated Tetrimino encoded as signed offsets relative to the Tetrimino’s center. Since the playfield is a one-dimensional data region representing a two-dimensional matrix of width 11, the relative coordinates of each block, <span class="nowrap">(<span class="mono">x</span>, <span class="mono">y</span>)</span>, are encoded as:</p> 

<p><span class="mono">offset = 11 * y + x;</span></p>

<p>To simplify the code, each Tetrimino is assumed to have four orientations. Table rows are repeated to pad out <span class="serif">I</span>, <span class="serif">S</span>, and <span class="serif">Z</span>, which only have two orientations per the NRS, and <span class="serif">O</span>, which only has one. </p>

<p>Because the table is aligned with the start of memory page one, each element is addressable with the following pseudocode.</p>

<pre class="pseudocode">
M = 1;  // page one

N = 16 * tetriminoType + 4 * tetriminoRotation + blockIndex;  // offset within page one
</pre>

<p>Immediately following the table are the bytes that carry the remaining button states:</p>

<pre class="code" style="counter-increment: step 88;">
<span class="line"><span class="keyword">segment</span> <span class="number">0170</span></span>
<span class="line"><span class="label">startButton:</span>         <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">ccwRotateButton:</span>     <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed </span></span>
<span class="line"><span class="label">cwRotateButton:</span>      <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
<span class="line"><span class="label">downButton:</span>          <span class="number">00</span> <span class="comment">; 00 = released; otherwise, pressed</span></span>
</pre>

<p><span class="mono">ccw</span> and <span class="mono">cw</span> are abbreviations for &ldquo;counterclockwise&rdquo; and &ldquo;clockwise&rdquo;, respectively.</p>

<p>The variables containing the entire state of the game are defined next:</p>

<pre class="code" style="counter-increment: step 94;">
<span class="line"><span class="label">tetriminoType:</span>       <span class="number">00</span> <span class="comment">; 00--06 (T, J, Z, O, S, L, I)</span></span>
<span class="line"><span class="label">tetriminoRotation:</span>   <span class="number">00</span> <span class="comment">; 00--03</span></span>
<span class="line"><span class="label">tetriminoX:</span>          <span class="number">00</span> <span class="comment">; 00--09</span></span>
<span class="line"><span class="label">tetriminoY:</span>          <span class="number">00</span> <span class="comment">; 02--15</span></span>
<span class="line"></span>
<span class="line"><span class="label">lastRotation:</span>        <span class="number">00</span> <span class="comment">; 00--03</span></span>
<span class="line"><span class="label">lastX:</span>               <span class="number">00</span> <span class="comment">; 00--09</span></span>
<span class="line"></span>
<span class="line"><span class="label">frameCounter:</span>        <span class="number">00</span> <span class="comment">; 00--FF (wraps around)</span></span>
<span class="line"></span>
<span class="line"><span class="label">seedHigh:</span>            <span class="number">89</span> <span class="comment">; randomizer</span></span>
<span class="line"><span class="label">seedLow:</span>             <span class="number">88</span></span>
<span class="line"><span class="label">nextBit:</span>             <span class="number">00</span></span>
<span class="line"></span>
<span class="line"><span class="label">i:</span>                   <span class="number">00</span> <span class="comment">; loops index</span></span>
<span class="line"><span class="label">origin:</span>              <span class="number">00</span> <span class="comment">; playfield index corresponding to Tetrimino center</span></span>
<span class="line"><span class="label">tetriminosIndex:</span>     <span class="number">00</span> <span class="comment">; tetriminos table index corresponding to a Tetrimino block</span></span>
<span class="line"></span>
<span class="line"><span class="label">fallTimer:</span>           <span class="number">00</span> <span class="comment">; 00 = drop Tetrimino</span></span>
<span class="line"><span class="label">mode:</span>                <span class="number">00</span> <span class="comment">; 00 = attract, 01 = play, 02 = clear lines</span></span>
<span class="line"><span class="label">minY:</span>                <span class="number">00</span> <span class="comment">; minimal locked Tetrimino Y (00--16)</span></span>
</pre>

<p>The variables on lines 95&ndash;98 describe the falling Tetrimino. Prior servicing a request to rotate or shift it, its orientation and <span class="nowrap">x-coordinate</span> are backed up in the variables on lines 100&ndash;101. If the requested move is found to be invalid, the original values are restored from the backups.</p>

<p>The variables on lines 103&ndash;107 are related to the randomizer. It updates the <span class="nowrap">16-bit</span> value spread across <span class="mono">seedHigh</span> and <span class="mono">seedLow</span> by passing it through a randomization function. The function also takes as input the variable <span class="mono">frameCounter</span>, which is incremented at the start of each frame. Since the randomization function is only applied when a Tetrimino spawns, <span class="mono">frameCounter</span> provides a source of randomness linked to the timing of the human agent’s actions. The output of the function, a single, randomly generated bit, is stored in <span class="mono">nextBit</span>.</p>

<p>Code comments describe the rest of the variables, though <span class="mono">minY</span> deserves an extra explanation. <span class="mono">minY</span> stores the row index of the highest Tetrimino on the pile. It is used to speed up line clears by limiting the shifted rows to those containing solid cells. The empty rows above the highest Tetrimino do not need to shift because empty space looks the same shifted or not.</p>

<p>That completes the data region. The rest of the program is instructions, beginning with <span class="mono">main</span>, the entry point of the application:</p>

<pre class="code" style="counter-increment: step 116;">
<span class="line"><span class="label">main:</span> <span class="comment">; ------------------------------------------------------------------------------------------------------</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawFrame</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">01</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; render frame</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">frameCounter</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++frameCounter;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_PLAY</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (mode == MODE_PLAY) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">playing</span>             <span class="comment">;   goto playing;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_CLEAR_LINES</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (mode == MODE_CLEAR_LINES) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">clearLines</span>          <span class="comment">;   goto clearLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">startButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (startButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">main</span><span class="comment">;               ;   goto main;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The code signals the window to repaint by writing <span class="mono">01</span> to <span class="mono">drawFrame</span>. It does not wait for <span class="mono">drawFrame</span> to reset because the processor pauses until the window writes <span class="mono">00</span> back to that address.</p>

<p>The code increments the <span class="mono">frameCounter</span> by <span class="mono">1</span>.</p>

<p>In play mode or clear lines mode, the code jumps to respective handlers. Otherwise, the program is in attract mode. There, it monitors the status of the start button. If released, the program loops back to the entry point. Else, the following code executes.</p>

<pre class="code" style="counter-increment: step 142;">
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span>                <span class="comment">; // Start button pressed</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">16</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; minY = 22;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="number">F1</span>                  <span class="comment">; A = 0xF1; // 22 * PLAYFIELD_WIDTH - 1, index of last element of row 21</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="label">clearLoop:</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; playfield[A] = CELL_EMPTY;</span></span>
<span class="line"><span class="normal">DEC</span>                     <span class="comment">; if (--A != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">clearLoop</span>           <span class="comment">;   goto clearLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; playfield[0] = CELL_EMPTY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="number">00F1</span>                <span class="comment">; MN = 0x00F1; // 22 * PLAYFIELD_WIDTH - 1, address of last element of row 21 </span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_SOLID</span></span>
<span class="line"><span class="label">edgeLoop:</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; *MN = CELL_SOLID;</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; MN -= PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">FF</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (*MN != -1) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">edgeLoop</span>            <span class="comment">;   goto edgeLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The code resets <span class="mono">minY</span> to its maximum value, the index of the hidden row beneath the floor.</p> 

<p>The code clears all cells of the playfield in <span class="nowrap">rows 21</span> and below. Subsequently, it solidifies the cells of <span class="nowrap">column 10</span> in the same rows. This restores the playfield to its initial state.</p> 

<p>Next, the first Tetrimino of the game spawns:</p>

<pre class="code" style="counter-increment: step 169;">
<span class="line"><span class="label">spawn:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_PLAY</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_PLAY;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_ROTATION</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoRotation = SPAWN_ROTATION;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_X</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoX = SPAWN_X;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoY</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">SPAWN_Y</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoY = SPAWN_Y;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">FALL_SPEED</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = FALL_SPEED;</span></span>
</pre>

<p>The program finally changes to play mode. It happens here, rather than earlier, because this spawn code also executes at the completion of clear lines mode to resume play.</p>

<p>The code positions and orients the Tetrimino at the spawn point.</p> 

<p>The code resets the <span class="mono">fallTimer</span> to its maximum value to prevent the Tetrimino from gravity dropping immediately after spawning.</p> 

<p>Next, the program randomly chooses the Tetrimino type:</p> 

<pre class="code" style="counter-increment: step 186;">
<span class="line"><span class="label">randomlyChoose:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">02</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedLow</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">STA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">XOR</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">bit9Clear</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">80</span></span>
<span class="line"><span class="label">bit9Clear:</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; nextBit = ((seedHigh & 0x02) ^ (seedLow & 0x02)) << 6;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">01</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">bit8Clear</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">80</span></span>
<span class="line"><span class="label">bit8Clear:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedLow</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">RS1</span></span>
<span class="line"><span class="normal">OR</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; seedLow = (seedHigh << 7) | (seedLow >>> 1);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">nextBit</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">seedHigh</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">RS1</span></span>
<span class="line"><span class="normal">OR</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; seedHigh = nextBit | (seedHigh >>> 1);</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">frameCounter</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">XOR</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">1F</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">RS5</span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; B = ((seedHigh ^ frameCounter) & 0x1F) * 7 / 32;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (B == tetriminoType) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">randomlyChoose</span>      <span class="comment">;   goto randomlyChoose;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; tetriminoType = B;</span></span>
</pre>

<p>The randomization function employs the same <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Fibonacci_LFSRs" target="_blank">Fibonacci linear-feedback shift register</a> (LFSR) at the core of the pseudorandom number generator (PRNG) in <a href="https://meatfighter.com/nintendotetrisai/#Picking_Tetriminos" target="_blank">NES Tetris</a>. As shown below, the next random bit, <span class="mono">nextBit</span>, is generated by XORing <span class="nowrap">bit-1s</span> of <span class="mono">seedHigh</span> and <span class="mono">seedLow</span>.</p>

<object data="lfsr-schematic.svg" type="image/svg+xml" class="diagram">LFSR</object>

<p><span class="mono">seedHigh</span> and <span class="mono">seedLow</span> collectively operate as a <span class="nowrap">16-bit</span> register. It is logical right shifted, during which the lowest bit is lost and the highest bit is set to <span class="mono">nextBit</span>.</p>

<p>The initial high and low seeds are <span class="mono">89</span> and <span class="mono">88</span>, respectively, the same, arbitrary quantities used in <span class="nowrap">NES Tetris</span>.</p>

<p>The LFSR produces a sequence of 32,767 unique values before cycling, one less-than half the numbers that fit in a <span class="nowrap">16-bit</span> register. To prevent that deterministic sequence from producing a constant Tetrimino order, the code bases its selection on <span class="mono">seedHigh</span> XORed with the <span class="mono">frameCounter</span>. As explained above, the <span class="mono">frameCounter</span> increments at the beginning of every frame, even during attract mode. This means, the order depends on the number of frames between program startup (or game over) and Start button activation. It is similarly affected by the number of frames between spawns. In other words, the code taps into the inherent randomness of the human agent.</p>

<p>Because there are seven Tetriminos, the XORed value needs to be reduced to the range <span class="nowrap">[ 0, 6 ]</span>. That could be achieved with a <a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank">modulo operation</a> that produces the remainder of integer division by 7. But mod is computationally expensive. Instead, code based on the following expression is used, where <span class="mono">v</span> is the lower-five bits of the XORed value.</p> 

<p><span class="mono">7 * v / 32</span></p>

<p>Since <span class="nowrap"><span class="mono">v</span><span class="serif"> &isin; </span>[ 0, 31 ]</span>, 7 is multiplied by a fraction less-than 1.0, producing a value in the correct range.</p>

<p>The expression is transformed into a version that is both efficient and readily implementable thusly:</p>

<pre class="pseudocode">
= (8 * v - v) / 32

= ((v << 3) - v) / 32

= ((v << 3) - v) >>> 5
</pre>

<p>If the randomly chosen Tetrimino is the same as the last one, the program picks again. That simple strategy does not prevent alternating duplicate pieces. Nor does it inhibit droughts.</p>

<p>Next, the program verifies that the Tetrimino spawned into empty space by calling the <span class="mono">drawOrTestTetrimino</span> subroutine:</p>

<pre class="code" style="counter-increment: step 242;">
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_TEST</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_TEST;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetrimino</span> <span class="comment">; if (drawOrTestTetrimino()) { // verify Tetrimino spawned into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">keepPosition</span>        <span class="comment">;   goto playing;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span>               <span class="comment"> ; // Bad Tetrimino position. It's game over.</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_ATTRACT</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_ATTRACT;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">endFall</span>             <span class="comment">; goto endFall; // draws the Tetrimino that failed to spawn</span></span>
</pre>

<p>Based on the action constant written to <span class="mono">drawOrTest</span>, <span class="mono">drawOrTestTetrimino</span> either paints or examines the four playfield cells corresponding to the blocks of the falling Tetrimino. But, unlike the inputs that describe the falling Tetrimino&mdash;<span class="mono">tetriminoType</span>, <span class="mono">tetriminoRotation</span>, <span class="mono">tetriminoX</span>, and <span class="mono">tetriminoY</span>&mdash;<span class="mono">drawOrTest</span> is not a global variable. Rather, it resolves to the address an instruction inside of <span class="mono">drawOrTestTetrimino</span>. Meaning, writing to <span class="mono">drawOrTest</span> modifies code. </p>

<p><span class="mono">ACTION_TEST</span> causes <span class="mono">drawOrTestTetrimino</span> to set the zero flag iff all four examined cells are empty. If they are, the code jumps the play handler, where button presses manipulate the falling Tetrimino. Otherwise, a top out occurred, in which case, the code switches to attract mode and it jumps to <span class="mono">endFall</span>. There, the Tetrimino is drawn at the invalid location, overlaid on solid blocks, to provide a visual indication of spawn failure. Then, the program loops back to the beginning, where it waits for the Start button to be pressed.</p>

<pre class="code" style="counter-increment: step 256;">
<span class="line"><span class="label">playing:</span>                <span class="comment">; // Play handler</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_DRAW</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_DRAW;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawCell</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(drawCell+1) = CELL_EMPTY;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetrimino</span> <span class="comment">; drawOrTestTetrimino(); // erase Tetrimino</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastRotation</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; lastRotation = tetriminoRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastX</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; lastX = tetriminoX;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">leftButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (leftButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testRightButton</span>     <span class="comment">;   goto testRightButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span>          <span class="comment">; // Left button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --tetriminoX;</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">testCcwRotateButton</span> <span class="comment">; goto testCcwRotateButton;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testRightButton:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">rightButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (rightButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testCcwRotateButton</span> <span class="comment">;   goto testCcwRotateButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span>          <span class="comment">; // Right button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++tetriminoX;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testCcwRotateButton:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">03</span>                  <span class="comment">; B = 3;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">ccwRotateButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (ccwRotateButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">testCwRotateButton</span>  <span class="comment">;   goto testCwRotateButton;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span>   <span class="comment">; // CCW button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoRotation = (tetriminoRotation - 1) & 3;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">validatePosition</span>    <span class="comment">; goto validatePosition;</span></span>
<span class="line"></span>
<span class="line"><span class="label">testCwRotateButton:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">cwRotateButton</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (cwRotateButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">validatePosition</span>    <span class="comment">;   goto validatePosition;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span>   <span class="comment">; // CW button pressed</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">AND</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoRotation = (tetriminoRotation + 1) & 3;</span></span>
<span class="line"></span>
<span class="line"><span class="label">validatePosition:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_TEST</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_TEST;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetrimino</span> <span class="comment">; if (drawOrTestTetrimino()) { // verify Tetrimino shifted/rotated into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">keepPosition</span>        <span class="comment">;   goto keepPosition;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastRotation</span>        <span class="comment">; // Bad Tetrimino position. Undo shift or rotation.</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoRotation = lastRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">lastX</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminoX = lastX;</span></span>
</pre>

<p>The handler calls <span class="mono">drawOrTestTetrimino</span> to paint the falling Tetrimino with empty cells, erasing it from the playfield. The paint value, <span class="mono">CELL_EMPTY</span>, is written to <span class="mono">drawCell+1</span>, the address of an operand of an instruction in <span class="mono">drawOrTestTetrimino</span>. Meaning, as with <span class="mono">drawOrTest</span>, the write modifies code.</p>

<p>The handler backs up the orientation and the <span class="nowrap">x-coordinate</span> of the falling Tetrimino.</p>

<p>If the Left button is pressed, the handler decrements the <span class="nowrap">x-coordinate</span> by 1. Otherwise, if the Right button is pressed, the handler increments the <span class="nowrap">x-coordinate</span> by 1.</p>

<p>If the Counterclockwise Rotation button is pressed, the handler decrements the orientation by 1, such that 0 wraps to 3. Otherwise, if the Clockwise Rotation button is pressed, the handler increments the orientation by 1, such that 3 wraps to 0.</p>

<p>The handler verifies that the manipulated Tetrimino is fully within empty space by calling <span class="mono">drawOrTestTetrimino</span>. If it is not, the original orientation and <span class="nowrap">x-coordinate</span> are restored from the backups.</p>

<p>Next, the handler deals with drops:</p>

<pre class="code" style="counter-increment: step 340;">
<span class="line"><span class="label">keepPosition:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">downButton</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span>           <span class="comment">; if (downButton == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">updateFallTimer</span>     <span class="comment">;   goto updateFallTimer;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEA</span> <span class="number">00</span>                  <span class="comment">; // Down button pressed</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = 0;                  </span></span>
<span class="line"></span>
<span class="line"><span class="label">updateFallTimer:</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (fallTimer != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">decFallTimer</span>        <span class="comment">;   goto decFallTimer;</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">FALL_SPEED</span>          <span class="comment">; } </span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; fallTimer = FALL_SPEED;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoY</span>          <span class="comment">; // Drop Tetrimino</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++tetriminoY;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetrimino</span> <span class="comment">; if (drawOrTestTetrimino()) { // verify Tetrimino dropped into empty space</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">endFall</span>             <span class="comment">;   goto endFall;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoY</span>          <span class="comment">; // Bad Tetrimino position. Undo drop and lock Tetrimino in place.</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --tetriminoY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">BMI</span> <span class="identifier">keepMinY</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; minY = min(minY, tetriminoY);</span></span>
<span class="line"></span>
<span class="line"><span class="label">keepMinY:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">mode</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">MODE_CLEAR_LINES</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; mode = MODE_CLEAR_LINES;</span></span>
<span class="line"></span>
<span class="line"><span class="label">decFallTimer:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">fallTimer</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --fallTimer;</span></span>
<span class="line"></span>
<span class="line"><span class="label">endFall:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawOrTest</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">ACTION_DRAW</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; drawOrTest = ACTION_DRAW;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">drawCell</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(drawCell+1) = tetriminoType + 1;</span></span>
<span class="line"><span class="normal">JSR</span> <span class="identifier">drawOrTestTetrimino</span> <span class="comment">; drawOrTestTetrimino(); // draw Tetrimino</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">main</span>                <span class="comment">; goto main;</span></span>
</pre>

<p>If the Down button is pressed, <span class="mono">fallTimer</span> is assigned zero.</p>  

<p>If <span class="mono">fallTimer</span> is zero, the handler resets it to <span class="mono">FALL_SPEED</span>. Then, the handler drops the Tetrimino by incrementing its <span class="nowrap">y-coordinate</span> by 1. If the dropped Tetrimino is not fully within empty space, per a check by <span class="mono">drawOrTestTetrimino</span>, then the <span class="nowrap">y-coordinate</span> is decremented by 1, restoring its position to where it now locks into the pile. Subsequently, <span class="mono">minY</span> is updated based off the new pile height and the program switches to clear lines mode.</p> 

<p>After that, the program flows into the code that normally runs when <span class="mono">fallTimer</span> is not zero. It decrements <span class="mono">fallTimer</span> by 1 and it calls <span class="mono">drawOrTestTetrimino</span> to draw the Tetrimino, which may now be at a different location and orientation from where it was erased at the start of the play handler. The paint value is <span class="mono nowrap">tetriminoType + 1</span>, because 0 represents an empty cell.</p>  

<p>The handler ends by jumping back to the beginning of the program, where, if the Tetrimino locked into the pile, it will invoke the clear lines handler in the listing below. It scans for and vanishes lines, without displaying a clearing animation.</p> 

<pre class="code" style="counter-increment: step 401;">
<span class="line"><span class="label">clearLines:</span>             <span class="comment">; // Clear lines handler</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">03</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; i = 3; // loop 4 times, from i = 3 down to 0.</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin = PLAYFIELD_WIDTH * (tetriminoY + 1); // row below Tetrimino center</span></span>
<span class="line"></span>
<span class="line"><span class="label">clearLinesLoop:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">16</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">notLine0</span></span>
<span class="line"><span class="normal">SEA</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="label">notLine0:</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minN</span><span class="normal">+</span><span class="number">1</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *(minN+1) = PLAYFIELD_WIDTH * max(1, minY - 2) - 1; // minimum index to copy from</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; MN = playfield + origin;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SEB</span> <span class="number">0A</span>                  <span class="comment">; B = PLAYFIELD_WIDTH - 1;</span></span>
<span class="line"><span class="label">scanLine:</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (*MN == CELL_EMPTY) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">continueClearLines</span>  <span class="comment">;   goto continueClearLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">TBA</span></span>
<span class="line"><span class="normal">DEC</span>                     <span class="comment">; if (--B < 0) { </span></span>
<span class="line"><span class="normal">BMI</span> <span class="identifier">copyLines</span>           <span class="comment">;   goto copyLines; // Found a line         </span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; ++N;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">scanLine</span>            <span class="comment">; goto scanLine;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TBA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAB</span>                     <span class="comment">; if (--B >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">scanLine</span>            <span class="comment">;   goto scanLine;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The NRS centers the 7 Tetriminos at 19 different orientations in 5&times;5 matrices. But none of the matrices contain solid cells in the bottom row. This means, only rows in the range <span class="nowrap"><span class="serif">[ </span><span class="mono">tetriminoY–2</span>, <span class="mono">tetriminoY+1</span><span class="serif"> ]</span></span> need to be checked for lines. The handler loops backwards over that range, using <span class="mono">i</span> as the loop index.</p>

<p><span class="mono">origin</span> is a pointer to the row to be checked. It is initialized to the index of the first element of row <span class="mono">tetriminoY+1</span>. At the end of each iteration, if a line was not found, <span class="mono">origin</span> is decremented by <span class="mono">PLAYFIELD_WIDTH</span> to reposition it to the next row. However, if a line was found, all the rows above it shift downward. In that case, <span class="mono">origin</span> is not decremented because the row that shifted into the cleared line is the next row to be checked.</p> 

<p>As previously mentioned, as an optimization, the empty rows above the pile are not shifted because empty space looks the same shifted or not. The first row above the pile guaranteed to be completed empty is derived from <span class="mono">minY</span>, the <span class="nowrap">y-coordinate</span> of the highest Tetrimino on the pile. It is either row <span class="mono">minY–3</span> or 0, whichever is larger. In another example of self-modifying code, the handler assigns the byte at <span class="mono">minN+1</span> to the index of the last element of that row.</p>

<p>Lines 434&ndash;459 comprises an inner-loop that examines the cells of a row, including the element in <span class="nowrap">column 10</span>. If an empty cell is found, it breaks out of the loop and <span class="mono">origin</span> is decremented as described above. If no empty cells are found, then its a line and the following code clears it.</p>

<pre class="code" style="counter-increment: step 460;">
<span class="line"><span class="label">copyLines:</span>              <span class="comment">; // Clear line by copying down the lines above it</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N -= PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">TAM</span>                     <span class="comment">; M = *MN;</span></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N += PLAYFIELD_WIDTH;</span></span>
<span class="line"><span class="normal">TMA</span>                     <span class="comment">; A = M;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span></span>
<span class="line"><span class="normal">TBM</span>                     <span class="comment">; M = 0;</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; *MN = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="label">minN:</span></span>
<span class="line"><span class="normal">SEB</span> <span class="number">00</span>                  <span class="comment">; *** self-modifying code [minN+1] ***</span></span>
<span class="line"><span class="normal">SUB</span>                     <span class="comment">; if (--N != *(minN+1)) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">copyLines</span>           <span class="comment">;   goto copyLines;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">09</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; N = 9;</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">CELL_EMPTY</span></span>
<span class="line"><span class="label">clearTopLine:</span></span>
<span class="line"><span class="normal">STB</span>                     <span class="comment">; *MN = CELL_EMPTY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">TNA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">TAN</span>                     <span class="comment">; if (--N >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">clearTopLine</span>        <span class="comment">;   goto clearTopLine;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">minY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; ++minY;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">continueClear</span>       <span class="comment">; goto continueClear;</span></span>
<span class="line"></span>
<span class="line"><span class="label">continueClearLines:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">SEB</span> <span class="identifier">PLAYFIELD_WIDTH</span></span>
<span class="line"><span class="normal">SUB</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin -= PLAYFIELD_WIDTH;</span></span>
<span class="line"></span>
<span class="line"><span class="label">continueClear:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; if (--i >= 0) {</span></span>
<span class="line"><span class="normal">BPL</span> <span class="identifier">clearLinesLoop</span>      <span class="comment">;   goto clearLinesLoop;</span></span>
<span class="line">                        <span class="comment">; } else {</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">spawn</span>               <span class="comment">;   goto spawn;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
</pre>

<p>The program enters the code above with <span class="mono">N</span> assigned to the index of the last element of the line. The inner-loop at 461&ndash;483 copies the nonempty rows above the line down by one row. It is equivalent to:</p>

<pre class="pseudocode">
M = 0;
do {
  *MN = *(MN - PLAYFIELD_WIDTH);
} while (--N != *(minN+1));
</pre>

<p>The inner-loop at 484&ndash;494 resets <span class="nowrap">row 0</span> to all empty cells, except for <span class="nowrap">column 10</span>. It is necessary for the rare case that a Tetrimino locks into the vanish zone.</p>

<p>The code increments <span class="mono">minY</span> by 1 because clearing a line reduces the height of the pile by that amount.</p> 

<p>Finally, the end of the outer-loop is reached where <span class="mono">i</span> is decremented by 1 and <span class="mono">origin</span> is decremented by <span class="mono">PLAYFIELD_WIDTH</span> iff a line was not found.</p>  

<p>The only remaining code is the definition of the <span class="mono">drawOrTestTetrimino</span> subroutine:</p>

<pre class="code" style="counter-increment: step 518;">
<span class="line"><span class="label">drawOrTestTetrimino:</span> <span class="comment">; ---------------------------------------------------------------------------------------</span></span>
<span class="line"><span class="comment">; drawOrTest        - 22 = draw, 23 = test</span></span>
<span class="line"><span class="comment">; drawCell+1        - cell to draw</span></span>
<span class="line"><span class="comment">;</span></span>
<span class="line"><span class="comment">; tetriminoType     - type</span></span>
<span class="line"><span class="comment">; tetriminoRotation - rotation</span></span>
<span class="line"><span class="comment">; tetriminoX        - x</span></span>
<span class="line"><span class="comment">; tetriminoY        - y</span></span>
<span class="line"><span class="comment">;</span></span>
<span class="line"><span class="comment">; z: 0 = some solid, 1 = all empty</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">03</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; i = 3; // Loop 4 times, once for each Tetrimino block</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoY</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS3</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoX</span></span>
<span class="line"><span class="normal">LDB</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; origin = PLAYFIELD_WIDTH * tetriminoY + tetriminoX;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoType</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS4</span></span>
<span class="line"><span class="normal">TAB</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminoRotation</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">LS2</span></span>
<span class="line"><span class="normal">ADD</span>                     <span class="comment">; A = 16 * tetriminoType + 4 * tetriminoRotation;</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminosIndex</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; tetriminosIndex = A;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">origin</span></span>
<span class="line"><span class="normal">LDB</span>                     <span class="comment">; B = origin;</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawLoop:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminos</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">ADD</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">playfield</span></span>
<span class="line"><span class="normal">TAN</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawOrTest:</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">drawCell</span>            <span class="comment">; *** self-modifying code [BNE = draw, BEQ = test] ***</span></span>
<span class="line"></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (playfield[tetriminos[tetriminosIndex] + origin] != 0) {</span></span>
<span class="line"><span class="normal">BNE</span> <span class="identifier">endDrawLoop</span>         <span class="comment">;   goto endDrawLoop;</span></span>
<span class="line">                        <span class="comment">; } else {</span></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">incDrawLoop</span>         <span class="comment">;   goto incDrawLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"></span>
<span class="line"><span class="label">drawCell:</span></span>
<span class="line"><span class="normal">SEA</span> <span class="number">00</span>                  <span class="comment">; *** self-modifying code [ 00 = empty; otherwise solid ] ***</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; playfield[tetriminos[tetriminosIndex] + origin] = *(drawCell+1);</span></span>
<span class="line"></span>
<span class="line"><span class="label">incDrawLoop:</span></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">i</span></span>
<span class="line"><span class="normal">LDA</span>                     <span class="comment">; if (i == 0) {</span></span>
<span class="line"><span class="normal">BEQ</span> <span class="identifier">endDrawLoop</span>         <span class="comment">;   goto endDrawLoop;</span></span>
<span class="line">                        <span class="comment">; }</span></span>
<span class="line"><span class="normal">DEC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; --i;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">SMN</span> <span class="identifier">tetriminosIndex</span></span>
<span class="line"><span class="normal">LDA</span></span>
<span class="line"><span class="normal">INC</span></span>
<span class="line"><span class="normal">STA</span>                     <span class="comment">; A = ++tetriminosIndex;</span></span>
<span class="line"></span>
<span class="line"><span class="normal">JMP</span> <span class="identifier">drawLoop</span>            <span class="comment">; goto drawLoop;</span></span>
<span class="line"></span>
<span class="line"><span class="label">endDrawLoop:</span></span>
<span class="line"></span>
<span class="line"><span class="normal">RTS</span>                     <span class="comment">; return; // -------------------------------------------------------------------------</span></span>
</pre>

<p>The code on lines 530&ndash;559 prepares three variables. It assigns <span class="mono">origin</span> to the playfield index corresponding to the center of the falling Tetrimino. It assigns <span class="mono">tetriminosIndex</span> to the index of the first element of the <span class="mono">tetriminos</span> table row associated with the type and orientation of the falling Tetrimino. And it assigns <span class="mono">i</span> to 3 to make the loop on lines 561&ndash;598 iterate over the four Tetrimino blocks.</p> 

<p>Writing <span class="mono">ACTION_DRAW</span> or <span class="mono">ACTION_TEST</span> to <span class="mono">drawOrTest</span> changes the instruction on <span class="nowrap">line 571</span> to <span class="mono">BNE</span> or <span class="mono">BEQ</span>, respectively. The zero flag is guaranteed to be reset when the program arrives at that line due to the <span class="mono">ADD</span> instruction on <span class="nowrap">line 566</span>; that <span class="mono">ADD</span> cannot set the zero flag because it is not possible to move the falling Tetrimino into the upper-right corner of the vanish zone. Consequentially, <span class="mono">ACTION_TEST</span> runs lines 573&ndash;577 and <span class="mono">ACTION_DRAW</span> runs lines 580&ndash;581.</p> 

<p>Both pathways access the playfield element at <span class="nowrap mono">tetriminos[tetriminosIndex] + origin</span>, the center of the falling Tetrimino offset by the relative location of one of its blocks. The <span class="mono">ACTION_TEST</span> code reads from that location. If the read value is nonzero, the subroutine returns with the zero flag reset. If all read values are zero, the subroutine returns with the zero flag set, thanks to <span class="nowrap">line 585</span>.</p>

<p>The <span class="mono">ACTION_DRAW</span> code writes the value at <span class="mono">drawCell+1</span> to that location. Self-modifying code is used in both instances because the alternative&mdash;moving values in and out of memory&mdash;imposes a performance cost and introduces complexity.</p>

<p>Each iteration decrements <span class="mono">i</span> by 1 and it increments <span class="mono">tetriminosIndex</span> by 1.</p>

<h2 id="simulation">Simulation</h2>

<p>The assembled Tetris program&mdash;a binary of length 1,019 bytes&mdash;represents the starting state of the playfield. Or, more specifically, it is the configuration of the <span class="nowrap">bottom-two</span> rows of an otherwise empty workspace with:</p>

<p>1,019 bytes &times; 8 bits/byte &times; 10 columns/bit = 81,520 columns.</p>
  
<p>A process generates a pair of MetaTetrisScripts for the downward and upward cycles of the machine based on that size.</p>

<p>To bring the game to life, a simulator loads the assembled Tetris program, the TetrisScripts for all components, and the pair of MetaTetrisScripts. It allocates and initialized a playfield with the Tetris program. It pops open a window to display the game’s graphics and to listen for button presses. Then, it enters an infinite loop, where it actualizes the MetaTetrisScripts, alternating between the downward and upward cycles of the machine.</p>

<p>At the end of each cycle, the simulator examines the surface of the pile in the columns corresponding to memory address <span class="mono">00FD</span>, the location of the <span class="mono">drawFrame</span> flag. When the flag indicates a frame is ready for display, the simulator copies the visible playfield from the pile to the window and it copies the button states from the window to the pile.</p>

<p>Instead of individually placing Tetriminos to compute every state of the evolving playfield, the simulator employs a <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">memoized</a> algorithm to evaluate its long-term fate. The algorithm precomputes a table for each component that maps all possible inputs to their corresponding outputs. The tables allow the algorithm to emulate the effects of building components without actually building them. For example, here are the full constructions of the swap circuit for all possible inputs:</p>

<object data="swap.svg" type="image/svg+xml" class="diagram">swap</object>

<p>Rather than manipulating all those pieces, the algorithm inspects the input cells, it performs a table lookup, and it sets the output cells, omitting everything in between:</p>

<object data="swap-memoized.svg" type="image/svg+xml" class="diagram">swap memoized</object>

<p>Despite their seeming levitation, the output cells are capable of supporting structures built on top of them as if the swap circuit was really there.</p>

<p>To efficiently compute the tables, the algorithm orders the TetrisScripts into a dependency tree. Then, starting from those that have no dependencies and working outward through the tree, it repeatedly builds components, plugging in all possible inputs and recording the results. When a TetrisScript invokes a component for which a table already exists, the algorithm uses a previously computed result, per the technique described above, instead of recomputing it. That memoized method considerably reduces construction time. To finish even faster, the algorithm processes multiple TetrisScripts in parallel.</p>

<p>The algorithm does not precompute tables for intermediate components because the side effects of leaking Tetriminos cannot be determined in advance. However, at runtime, the algorithm performs lookups only for the components in the MetaTetrisScripts. And, since intermediate components are confined to the interior of circuits, they never appear in the MetaTetrisScripts.</p>

<p>When the simulator executes a MetaTetrisScript instruction, the always-rectangular pile grows by the uniform function height. This is because the instruction directs the simulator to build a specified function at a particular location on the pile and to level the remaining surface by assembling identity functions everywhere else.</p>

<p>Rather than accommodating an ever-taller pile, the algorithm only keeps track of its surface. For each MetaTetrisScript instruction, it reads input from the surface, it performs a table lookup, and it stores output back to surface, overwriting what it just read. The effect is the equivalent to growing the pile and truncating everything below the surface.</p>

<p>The algorithm implements the surface as a one-dimensional byte array, <span class="serif">s</span>, where each byte contains the data normally spaced across <span class="nowrap">80 columns</span> of the <span class="nowrap">top-two</span> rows of the pile. For each MetaTetrisScript instruction, <span class="mono nowrap">f x</span>, where <span class="mono">f</span> is the name of an <span class="nowrap"><span class="serif">n</span>-byte</span> function, the algorithm updates <span class="serif">n</span> consecutive bytes of the surface, starting at index <span class="serif">x</span>, via the following table lookup and assignment.</p>

<p><span class="nowrap"><span class="serif">s<span class="sub2">x</span>&nldr;s<span class="sub2">x+n&minus;1</span> &larr; lookup(</span><span class="mono">f</span><span class="serif">, s<span class="sub2">x</span>&nldr;s<span class="sub2">x+n&minus;1</span>)</span></span></p>

<p>That read-lookup-write operation is performant, but an <span class="nowrap"><span class="serif">n</span>-byte</span> function requires a precomputed table of size <span class="nowrap"><span class="serif">(2<span class="sup3">8</span>)<span class="sup3">n</span></span> bytes</span>; i.e., <span class="nowrap">1-,</span> <span class="nowrap">2-,</span> and <span class="nowrap">3-byte</span> functions require <span class="nowrap">256 B</span>, <span class="nowrap">64 KiB</span>, and <span class="nowrap">16 MiB</span> tables, respectively. However, as the algorithm computes a table for a <span class="nowrap">3-byte</span> function, it monitors the output for a byte constrained to <span class="mono">0</span> and <span class="mono">1</span>. If it finds such a byte, it assumes the corresponding input parameter is a Boolean, effectively reducing a <span class="nowrap">24-bit</span> function to a <span class="nowrap">17-bit</span> function. In the general case, that is a risky assumption. But in this particular situation, the first or third parameter of every <span class="nowrap">3-byte</span> function is a Boolean, enabling the algorithm to safely cache their results in <span class="nowrap">128 KiB</span> tables.</p>

<p>The simulator’s speed&mdash;the number of machines cycles it simulates per second&mdash;is proportional to the MetaTetrisScript length, the total operations required to slide the state register across RAM. That, in turn, depends on the amount of RAM, which is equal to the assembled Tetris program size. In other words, the smaller the program, the faster it runs.</p>

<p>A potential way to slim down the program is to shrink its playfield representation, which, at <span class="nowrap">253 bytes</span>, takes up nearly a quarter of the space. It can be reduced to the <span class="nowrap">200 bytes</span> of the visible playfield by introducing boundary checks that eliminate the need for solid <span class="nowrap">row 22</span> and solid <span class="nowrap">column 10</span> (the floor and walls), as well as <span class="nowrap">rows 0</span> and 1 (the vanish zone). From there, the size can be halved by packing each cell into a nibble rather than a full byte. And, if the palette is reduced to two colors, the size can be halved twice more by packing each cell into a single bit. The resultant playfield would be a mere <span class="nowrap">25 bytes</span>, less than a tenth of its current size.</p>

<p>However, with the machine's minimal instruction set, the code modifications required to support an alternate playfield representation may increase the program size to the point that it negates the benefit of a smaller playfield. Worse, the change could decrease the frame rate because it requires extra code in the <span class="mono">drawOrTestTetrimino</span> loop. At five subroutine calls per frame and four blocks per Tetrimino, the execution time of each of those instructions is amplified twenty-fold.</p>

<p>Drawbacks aside, the proposed change would likely speed up line clears. As revealed in the video below, there is a noticeable delay when clearing lines due to the amount of data copied. But, if multiple cells were packed into each byte, then they get copied in parallel, hastening the process.</p>

<p>[ TODO VIDEO OF LINE CLEARS ]</p>

<p>At <span class="nowrap">112 bytes</span>, the <span class="mono">tetriminos</span> table is another possible target for program size reduction. Nearly a third of its rows are duplicates. Deleting them would save 36 bytes. However, the indirection table required to compensate for the missing rows requires 28 bytes. And indirection increases access time.</p>

<p>The choices made in designing the Tetris program presented here were guided by the principle of keeping the code simple even at the expense of larger data representations. The optimal balance between data, instruction path lengths, and program size that maximizes the game’s frame rate is left for future research.</p>

</body>

</html>
