package tetriscircuits.computer.ui;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Path2D;
import java.awt.geom.RoundRectangle2D;

import static tetriscircuits.computer.ui.PlayfieldModel.PLAYFIELD_HEIGHT;
import static tetriscircuits.computer.ui.PlayfieldModel.PLAYFIELD_WIDTH;

public class PlayfieldPanel extends javax.swing.JPanel {
    
    private static final Color GRID_COLOR = new Color(0x151816);
    private static final Color BORDER_COLOR = new Color(0xFFFFFF);
    private static final Color BACKGROUND_COLOR = new Color(0x090909);
    
    private static final Color[] BLOCK_FILL_COLORS = {
        new Color(0xB802FD),
        new Color(0x1801FF),
        new Color(0xFE103C),
        new Color(0xFFDE00),
        new Color(0x66FD00),
        new Color(0xFF7308),
        new Color(0x00E6FE),
    };    
    
    private static final Color[] BLOCK_DRAW_COLORS = new Color[BLOCK_FILL_COLORS.length];
    static {
        for (int i = BLOCK_FILL_COLORS.length - 1; i >= 0; --i) {
            BLOCK_DRAW_COLORS[i] = BLOCK_FILL_COLORS[i].darker();
        }
    }
    
    private static final int CELL_SIZE = 32;
    private static final int PLAYFIELD_PADDING = 10;
    
    private static final float BORDER_ARC_SIZE = 7;
    private static final float BLOCK_ARC_SIZE = 14;
    
    private static final float GRID_STROKE_WIDTH = 2.5f;
    private static final Stroke GRID_STROKE = new BasicStroke(GRID_STROKE_WIDTH);
    
    private static final float BORDER_STROKE_WIDTH = 3.5f;
    private static final Stroke BORDER_STROKE = new BasicStroke(BORDER_STROKE_WIDTH);
    
    private static final float BLOCK_STROKE_WIDTH = 8f / 3f;
    private static final Stroke BLOCK_STROKE = new BasicStroke(BLOCK_STROKE_WIDTH);
    
    private static final int PREFERRED_WIDTH = 2 * PLAYFIELD_PADDING + CELL_SIZE * PLAYFIELD_WIDTH;
    private static final int PREFERRED_HEIGHT = 2 * PLAYFIELD_PADDING + CELL_SIZE * PLAYFIELD_HEIGHT;
    private static final Dimension PREFERRED_SIZE = new Dimension(PREFERRED_WIDTH, PREFERRED_HEIGHT);
    
    private static final Path2D.Float GRID_PATH = new Path2D.Float();
    private static final Shape BORDER_SHAPE = new RoundRectangle2D.Float(
            PLAYFIELD_PADDING - BLOCK_STROKE_WIDTH / 2, PLAYFIELD_PADDING - BLOCK_STROKE_WIDTH / 2, 
            CELL_SIZE * PLAYFIELD_WIDTH + BLOCK_STROKE_WIDTH, CELL_SIZE * PLAYFIELD_HEIGHT + BLOCK_STROKE_WIDTH, 
            BORDER_ARC_SIZE, BORDER_ARC_SIZE);    
    private static final Shape BLOCK_SHAPE = new RoundRectangle2D.Float(
            0, 0, 
            CELL_SIZE - BLOCK_STROKE_WIDTH, CELL_SIZE - BLOCK_STROKE_WIDTH, 
            BLOCK_ARC_SIZE, BLOCK_ARC_SIZE);
    
    static {
        final float maxX = PLAYFIELD_PADDING + CELL_SIZE * PLAYFIELD_WIDTH;
        for (int i = PLAYFIELD_HEIGHT - 1; i >= 1; --i) {
            float y = PLAYFIELD_PADDING + i * CELL_SIZE;
            GRID_PATH.moveTo(PLAYFIELD_PADDING, y);
            GRID_PATH.lineTo(maxX, y);
        }
        final float maxY = PLAYFIELD_PADDING + CELL_SIZE * PLAYFIELD_HEIGHT;
        for (int i = PLAYFIELD_WIDTH - 1; i >= 1; --i) {
            float x = PLAYFIELD_PADDING + i * CELL_SIZE;
            GRID_PATH.moveTo(x, PLAYFIELD_PADDING);
            GRID_PATH.lineTo(x, maxY);
        }
    }
    
    private int[][] cells = new int[PLAYFIELD_HEIGHT][PLAYFIELD_WIDTH];
    
    public PlayfieldPanel() {
        initComponents();
    }    

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    public void update(final PlayfieldModel playfieldModel) {
        final int[][] cells = playfieldModel.getCells();
        playfieldModel.setCells(this.cells);
        this.cells = cells;
        repaint();
    }
    
    @Override
    protected void paintComponent(final Graphics G) {
        
        final Graphics2D g = (Graphics2D)G; 
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);        
        
        final Dimension size = getSize();
        final int wH = PREFERRED_WIDTH * size.height;
        final int hW = PREFERRED_HEIGHT * size.width;
        final int ox;
        final int oy;
        final int width;
        final int height;
        if (wH == hW) {
            ox = 0;
            oy = 0;
            width = size.width;
            height = size.height;
        } else if (wH < hW) {
            height = size.height;
            width = (int)Math.round(PREFERRED_WIDTH * height / (double)PREFERRED_HEIGHT);
            oy = 0;
            ox = (size.width - width) / 2;
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, ox, height);
            g.fillRect(ox + width, 0, size.width - (ox + width), height);
        } else {
            width = size.width;
            height = (int)Math.round(PREFERRED_HEIGHT * width / (double)PREFERRED_WIDTH);
            ox = 0;
            oy = (size.height - height) / 2;
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, width, oy);
            g.fillRect(0, oy + height, width, size.height - (oy + height));
        }
             
        g.translate(ox, oy);
        g.scale(width / (double)PREFERRED_WIDTH, height / (double)PREFERRED_HEIGHT);
        
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(0, 0, PREFERRED_WIDTH, PREFERRED_HEIGHT);
        
        g.setColor(GRID_COLOR);
        g.setStroke(GRID_STROKE);
        g.draw(GRID_PATH);
        
        g.setColor(BORDER_COLOR);
        g.setStroke(BORDER_STROKE);
        g.draw(BORDER_SHAPE);
        
        g.translate(GRID_STROKE_WIDTH / 2, GRID_STROKE_WIDTH / 2);
        g.setStroke(BLOCK_STROKE);
        for (int i = PLAYFIELD_HEIGHT - 1; i >= 0; --i) {
            float ty = PLAYFIELD_PADDING + i * CELL_SIZE;
            for (int j = PLAYFIELD_WIDTH - 1; j >= 0; --j) {
                int index = cells[i][j];
                if (index == 0) {
                    continue;
                }
                --index;
                float tx = PLAYFIELD_PADDING + j * CELL_SIZE;
                g.translate(tx, ty);
                g.setColor(BLOCK_FILL_COLORS[index]);
                g.fill(BLOCK_SHAPE);
                g.setColor(BLOCK_DRAW_COLORS[index]);
                g.draw(BLOCK_SHAPE);
                g.translate(-tx, -ty);
            }
        }
    }

    @Override
    public Dimension getPreferredSize() {
        return PREFERRED_SIZE;
    }
}
